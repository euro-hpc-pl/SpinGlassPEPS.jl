<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · SpinGlassPEPS.jl</title><meta name="title" content="Library · SpinGlassPEPS.jl"/><meta property="og:title" content="Library · SpinGlassPEPS.jl"/><meta property="twitter:title" content="Library · SpinGlassPEPS.jl"/><meta name="description" content="Documentation for SpinGlassPEPS.jl."/><meta property="og:description" content="Documentation for SpinGlassPEPS.jl."/><meta property="twitter:description" content="Documentation for SpinGlassPEPS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpinGlassPEPS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Getting started</a></li><li><a class="tocitem" href="../../algorithm/">Brief description of the algorithm</a></li><li><a class="tocitem" href="../../examples/">More examples</a></li><li><span class="tocitem">SpinGlassNetworks</span><ul><li><a class="tocitem" href="../../sgn/userguide/">User guide</a></li><li><a class="tocitem" href="../../sgn/ising/">Ising graph</a></li><li><a class="tocitem" href="../../sgn/lattice/">Lattice geometries</a></li><li><a class="tocitem" href="../../sgn/clh/">Potts hamiltonian</a></li><li><a class="tocitem" href="../../sgn/bp/">Local dimensional reduction</a></li></ul></li><li><span class="tocitem">SpinGlassEngine</span><ul><li><a class="tocitem" href="../guide/">User Guide</a></li><li><a class="tocitem" href="../peps/">Tensor network</a></li><li><a class="tocitem" href="../params/">Search parameters</a></li><li><a class="tocitem" href="../search/">Low energy spectrum</a></li></ul></li><li><span class="tocitem">SpinGlassTensors</span><ul><li><a class="tocitem" href="../../sgt/">User guide</a></li><li><a class="tocitem" href="../../sgt/mpo/">Matrix Product States and Matrix Product Operations</a></li><li><a class="tocitem" href="../../sgt/api/">API Reference</a></li></ul></li><li><a class="tocitem" href="../../examples/">More examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl/blob/master/docs/src/sge/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><hr/><h2 id="Search"><a class="docs-heading-anchor" href="#Search">Search</a><a id="Search-1"></a><a class="docs-heading-anchor-permalink" href="#Search" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.empty_solution" href="#SpinGlassEngine.empty_solution"><code>SpinGlassEngine.empty_solution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">empty_solution(::Type{T}) -&gt; Solution
empty_solution(::Type{T}, n::Int64) -&gt; Solution
</code></pre><p>Create an empty <code>Solution</code> object with a specified number of states.</p><p>This function creates an empty <code>Solution</code> object with the given number of states, initializing its fields with default values.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int</code>: The number of states for which the <code>Solution</code> object is created.</li></ul><p><strong>Returns</strong></p><p>An empty <code>Solution</code> object with default field values, ready to store search results for a specified number of states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.gibbs_sampling" href="#SpinGlassEngine.gibbs_sampling"><code>SpinGlassEngine.gibbs_sampling</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gibbs_sampling(
    ctr::MpsContractor{T, R, S},
    sparams::SearchParameters;
    ...
) -&gt; Solution
gibbs_sampling(
    ctr::MpsContractor{T, R, S},
    sparams::SearchParameters,
    merge_strategy;
    no_cache
) -&gt; Solution
</code></pre><p>Perform Gibbs sampling on a spin glass PEPS network.</p><p>This function performs Gibbs sampling on a spin glass PEPS (Projected Entangled Pair State) network using a branch-and-bound search algorithm. It takes as input a <code>ctr</code> object representing the PEPS network, <code>sparams</code> specifying search parameters, and <code>merge_strategy</code> for merging branches. Optionally, you can disable caching using the <code>no_cache</code> flag.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::AbstractContractor</code>: The contractor object representing the PEPS network, which should be a subtype of <code>AbstractContractor</code>.</li><li><code>sparams::SearchParameters</code>: Parameters for controlling the search, including the maximum number of states and a cutoff probability.</li><li><code>merge_strategy=no_merge</code>: (Optional) Merge strategy for branches. Defaults to <code>no_merge</code>.</li><li><code>no_cache=false</code>: (Optional) If <code>true</code>, disables caching. Defaults to <code>false</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>Solution</code> object representing the result of the Gibbs sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L656">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.bound_solution" href="#SpinGlassEngine.bound_solution"><code>SpinGlassEngine.bound_solution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bound_solution(
    psol::Solution,
    max_states::Int64,
    δprob::Real
) -&gt; Solution
bound_solution(
    psol::Solution,
    max_states::Int64,
    δprob::Real,
    merge_strategy
) -&gt; Solution
</code></pre><p>Bound the solution to a specified number of states while discarding low-probability states.</p><p>This function takes a <code>Solution</code> object <code>psol</code>, bounds it to a specified number of states <code>max_states</code>, and discards low-probability states based on the probability threshold <code>δprob</code>. You can specify a <code>merge_strategy</code> for merging branches in the <code>psol</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>psol::Solution</code>: A <code>Solution</code> object representing the solution to be bounded.</li><li><code>max_states::Int</code>: The maximum number of states to retain in the bounded solution.</li><li><code>δprob::Real</code>: The probability threshold for discarding low-probability states.</li><li><code>merge_strategy=no_merge</code>: (Optional) Merge strategy for branches. Defaults to <code>no_merge</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>Solution</code> object representing the bounded solution with a maximum of <code>max_states</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.no_merge" href="#SpinGlassEngine.no_merge"><code>SpinGlassEngine.no_merge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">no_merge(partial_sol::Solution) -&gt; Solution
</code></pre><p>No-op merge function that returns the input <code>partial_sol</code> as is.</p><p>This function is a no-op merge function that takes a <code>Solution</code> object <code>partial_sol</code> as input and returns it unchanged. It is used as a merge strategy when you do not want to perform any merging of branches in a solution.</p><p><strong>Arguments</strong></p><ul><li><code>partial_sol::Solution</code>: A <code>Solution</code> object representing partial solutions.</li></ul><p><strong>Returns</strong></p><p>The input <code>partial_sol</code> object, unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.branch_energy" href="#SpinGlassEngine.branch_energy"><code>SpinGlassEngine.branch_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_energy(
    ctr::MpsContractor{T},
    eσ::Tuple{Real, Vector{Int64}}
) -&gt; Any
</code></pre><p>Calculates the energy contribution of a branch given a base energy and a spin configuration.</p><p>This function calculates the energy contribution of a branch in a SpinGlassPEPS calculation. It takes a <code>MpsContractor</code> object <code>ctr</code> and a tuple <code>eσ</code> containing a base energy as the first element and a spin configuration represented as a vector of integers as the second element. The function calculates the branch energy by adding the base energy to the energy contribution of the given spin configuration obtained from the <code>update_energy</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: An instance of the <code>MpsContractor</code> type parameterized by the strategy type <code>T</code>.</li><li><code>eσ::Tuple{&lt;:Real, Vector{Int}}</code>: A tuple containing the base energy as the first element (a real number)</li></ul><p>and the spin configuration as the second element (a vector of integers).</p><p><strong>Returns</strong></p><p>The branch energy, which is the sum of the base energy and the energy contribution of the spin configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L120">source</a></section></article><h2 id="Core"><a class="docs-heading-anchor" href="#Core">Core</a><a id="Core-1"></a><a class="docs-heading-anchor-permalink" href="#Core" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.error_measure" href="#SpinGlassEngine.error_measure"><code>SpinGlassEngine.error_measure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">error_measure(probs) -&gt; Any
</code></pre><p>Calculate an error measure based on the given probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>probs</code>: An array representing a probability distribution.</li></ul><p><strong>Description</strong></p><p>The <code>error_measure</code> function calculates an error measure based on the provided probability distribution.  The error measure is designed to capture discrepancies or irregularities in the distribution. The function checks for extreme cases, such as when the maximum probability less or equal zero, and returns a predefined value (<code>2.0</code>).  If the minimum probability is negative, the error measure is calculated as the absolute value of the minimum  probability divided by the maximum absolute value of the probabilities.  If neither of these conditions is met, the error measure is set to <code>0.0</code>. The error measure provides a quantitative assessment of the deviation from a well-behaved probability distribution,  helping to identify potential issues or anomalies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/util.jl#L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.conditional_probability" href="#SpinGlassEngine.conditional_probability"><code>SpinGlassEngine.conditional_probability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conditional_probability(
    _::Type{T&lt;:SquareSingleNode},
    ctr::MpsContractor{S},
    ∂v::Vector{Int64}
) -&gt; Any
</code></pre><p>Calculates conditional probability for a SquareSingleNode Layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_single_node.jl#L240">source</a></section><section><div><pre><code class="language-julia hljs">conditional_probability(
    _::Type{T&lt;:SquareCrossDoubleNode},
    ctr::MpsContractor{S},
    ∂v::Vector{Int64}
) -&gt; Any
</code></pre><p>Compute the conditional probability of states for a square cross double node tensor geometry.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Type representing a square cross double node tensor network.</li><li><code>ctr::MpsContractor{S}</code>: Tensor contractor for the tensor network.</li><li><code>∂v::Vector{Int}</code>: Vector of indices representing the contracted environment indices.</li></ul><p><strong>Returns</strong></p><ul><li>Vector{Float64}: Conditional probabilities for different states.</li></ul><p><strong>Description</strong></p><p>The <code>conditional_probability</code> function computes the conditional probabilities of different states for a specified square cross double node tensor geometry. It takes into account the geometry of the tensor network, interaction energies, and precomputed values. The function supports both left and right environments, and the resulting probabilities are normalized. The function is specialized for the <code>SquareCrossDoubleNode</code> tensor network type and is parametrized by the layout type <code>S</code> of the contractor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L380">source</a></section><section><div><pre><code class="language-julia hljs">conditional_probability(
    ctr::MpsContractor{S},
    w::Vector{Int64}
) -&gt; Any
</code></pre><p>Calculate the conditional probability of a given state within the context of an MPS (Matrix Product State) contractor.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{S}</code>: An MPS contractor representing the contracted state and associated parameters.</li><li><code>w::Vector{Int}</code>: A vector representing the encoded state.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The calculated conditional probabilities for each possible outcome.</li></ul><p><strong>Description</strong></p><p>The <code>conditional_probability</code> function calculates the conditional probability distribution of a given state within the context of an MPS contractor.  It delegates the calculation to the <code>conditional_probability</code> function with a specified tensor layout using the <code>layout</code> function. This function is a convenience wrapper that allows users to calculate conditional probabilities without explicitly specifying the tensor layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/util.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.update_energy" href="#SpinGlassEngine.update_energy"><code>SpinGlassEngine.update_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_energy(
    _::Type{T&lt;:SquareCrossDoubleNode},
    ctr::MpsContractor{S},
    σ::Vector{Int64}
) -&gt; Any
</code></pre><p>Update the energy of a specific tensor node in a matrix product states (MPS).</p><p><strong>Arguments</strong></p><ul><li><code>T::Type</code>: Tensor network type, specialized for <code>SquareCrossDoubleNode</code>.</li><li><code>ctr::MpsContractor{S}</code>: MPS tensor network contractor containing relevant information for contraction.</li><li><code>σ::Vector{Int}</code>: State vector representing the current configuration of the tensor network.</li></ul><p><strong>Returns</strong></p><ul><li>Real: Updated energy value for the specified tensor node.</li></ul><p><strong>Description</strong></p><p>The <code>update_energy</code> function calculates the energy contribution of a specific tensor node in a matrix product states (MPS). The energy is computed based on the local energy at the node and the interaction energies with its neighboring nodes, considering the provided state vector <code>σ</code>. The function is specialized for the <code>SquareCrossDoubleNode</code> tensor network type and is parametrized by the layout type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L680">source</a></section><section><div><pre><code class="language-julia hljs">update_energy(
    ctr::MpsContractor{S},
    w::Vector{Int64}
) -&gt; Any
</code></pre><p>Update the energy associated with the current state within the context of an MPS (Matrix Product State) contractor.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{S}</code>: An MPS contractor representing the contracted state and associated parameters.</li><li><code>w::Vector{Int}</code>: A vector representing the encoded state.</li></ul><p><strong>Description</strong></p><p>The <code>update_energy</code> function updates the energy associated with the current state within the context of an MPS contractor.  It delegates the calculation to the <code>update_energy</code> function with a specified tensor layout using the <code>layout</code> function. This function is a convenience wrapper that allows users to update the energy without explicitly specifying the tensor layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/util.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.boundary" href="#SpinGlassEngine.boundary"><code>SpinGlassEngine.boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary(
    _::Type{T&lt;:SquareCrossDoubleNode},
    ctr::MpsContractor{S},
    node::NTuple{N, Int64} where N
) -&gt; Any
</code></pre><p>Compute the boundary states for a specific node in a matrix product states (MPS).</p><p><strong>Arguments</strong></p><ul><li><code>T::Type</code>: Tensor network type, specialized for <code>SquareCrossDoubleNode</code>.</li><li><code>ctr::MpsContractor{S}</code>: MPS tensor network contractor containing relevant information.</li><li><code>node::Node</code>: Tuple representing the coordinates of the node in the tensor network.</li></ul><p><strong>Returns</strong></p><ul><li>Vector{Tuple{Tuple, Tuple}}: Vector of tuples representing the boundary states for the given node.</li></ul><p>Each tuple contains pairs of indices representing connected sites in the tensor network.</p><p><strong>Description</strong></p><p>The <code>boundary</code> function computes the boundary states for a specific node in a matrix product states (MPS). The boundary states are determined by analyzing the connections between the current node and its neighboring nodes, considering different physical indices. The function is specialized for the <code>SquareCrossDoubleNode</code> tensor network type and is parametrized by the layout type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.boundary_indices" href="#SpinGlassEngine.boundary_indices"><code>SpinGlassEngine.boundary_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_indices(
    ctr::MpsContractor{T},
    nodes::Union{NTuple{4, S}, Tuple{S, Tuple{S, S}, S, Tuple{S, S}}},
    states::Vector{Vector{Int64}}
) -&gt; Any
</code></pre><p>boundary index formed from outer product of two projectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.Gauges" href="#SpinGlassEngine.Gauges"><code>SpinGlassEngine.Gauges</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Stores gauges and corresponding information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/geometry.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.GaugeInfo" href="#SpinGlassEngine.GaugeInfo"><code>SpinGlassEngine.GaugeInfo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Defines information how to create gauges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/geometry.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.PEPSNode" href="#SpinGlassEngine.PEPSNode"><code>SpinGlassEngine.PEPSNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Node for the SquareSingleNode and KingSingleNode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/geometry.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.SuperPEPSNode" href="#SpinGlassEngine.SuperPEPSNode"><code>SpinGlassEngine.SuperPEPSNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Node for the Pegasus type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/geometry.jl#L49">source</a></section></article><h2 id="Contractor"><a class="docs-heading-anchor" href="#Contractor">Contractor</a><a id="Contractor-1"></a><a class="docs-heading-anchor-permalink" href="#Contractor" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.MpoLayers" href="#SpinGlassEngine.MpoLayers"><code>SpinGlassEngine.MpoLayers</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A struct representing different layers of a Matrix Product Operator (MPO) used in contraction algorithms.</p><p><strong>Fields</strong></p><ul><li><code>main::Dict{Site, Sites}</code>: A dictionary mapping sites to the main layers of the MPO.</li><li><code>dress::Dict{Site, Sites}</code>: A dictionary mapping sites to the dress layers of the MPO.</li><li><code>right::Dict{Site, Sites}</code>: A dictionary mapping sites to the right layers of the MPO.</li></ul><p>The <code>MpoLayers</code> struct distinguishes the various layers of an MPO, which is often used in tensor network contraction algorithms. MPOs are commonly employed in quantum many-body physics and condensed matter physics to represent operators acting on quantum states in a factorized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.layout" href="#SpinGlassEngine.layout"><code>SpinGlassEngine.layout</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">layout(net::PEPSNetwork{T, S}) -&gt; Any
</code></pre><p>A function that provides the layout used to construct the PEPS (Projected Entangled Pair States) network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{T, S}</code>: The PEPS network for which the layout is provided.</li></ul><p><strong>Returns</strong></p><ul><li>The layout type <code>T</code> used to construct the PEPS network.</li></ul><p>The <code>layout</code> function returns the layout type used in the construction of a PEPS network. This layout type specifies the geometric arrangement and sparsity pattern of the tensors in the PEPS network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.sparsity" href="#SpinGlassEngine.sparsity"><code>SpinGlassEngine.sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparsity(net::PEPSNetwork{T, S}) -&gt; Any
</code></pre><p>A function that provides the sparsity used to construct the PEPS (Projected Entangled Pair States) network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{T, S}</code>: The PEPS network for which the sparsity is provided.</li></ul><p><strong>Returns</strong></p><ul><li>The sparsity type <code>S</code> used to construct the PEPS network.</li></ul><p>The <code>sparsity</code> function returns the sparsity type used in the construction of a PEPS network. This sparsity type specifies the pattern of zero elements in the tensors of the PEPS network, which can affect the computational efficiency and properties of the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.strategy" href="#SpinGlassEngine.strategy"><code>SpinGlassEngine.strategy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">strategy(_::MpsContractor{T}) -&gt; Any
</code></pre><p>Get the strategy used to contract the PEPS network.</p><p><strong>Arguments</strong></p><ul><li><code>::MpsContractor{T}</code>: The MpsContractor object representing the PEPS network contraction.</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: The strategy used for network contraction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.mpo" href="#SpinGlassEngine.mpo"><code>SpinGlassEngine.mpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpo(
    ctr::MpsContractor{T&lt;:SpinGlassEngine.AbstractStrategy, R, S},
    layers::Dict{Union{Rational{Int64}, Int64}, NTuple{N, Union{Rational{Int64}, Int64}} where N},
    r::Int64
) -&gt; Any
</code></pre><p>Construct and memoize a Matrix Product Operator (MPO) for a given set of layers.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: The MpsContractor object representing the PEPS network contraction.</li><li><code>layers::Dict{Site, Sites}</code>: A dictionary mapping sites to their corresponding layers.</li><li><code>r::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMpo</code>: The constructed MPO for the specified layers.</li></ul><p>This function constructs an MPO by iterating through the specified layers and assembling the corresponding tensors. The resulting MPO is memoized for efficient reuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.mps_top" href="#SpinGlassEngine.mps_top"><code>SpinGlassEngine.mps_top</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mps_top(
    ctr::MpsContractor{SVDTruncate, R, S},
    i::Int64
) -&gt; Any
</code></pre><p>Construct and memoize the top Matrix Product State (MPS) using Singular Value Decomposition (SVD) for a given row.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{SVDTruncate}</code>: The MpsContractor object representing the PEPS network contraction with SVD truncation.</li><li><code>i::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMps</code>: The constructed top MPS for the specified row.</li></ul><p>This function constructs the top MPS using SVD for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, truncation, and compression steps as needed based on the specified parameters in <code>ctr.params</code>. The resulting MPS is memoized for efficient reuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L296">source</a></section><section><div><pre><code class="language-julia hljs">mps_top(ctr::MpsContractor{Zipper, R, S}, i::Int64) -&gt; Any
</code></pre><p>Construct and memoize the top Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{Zipper}</code>: The MpsContractor object representing the PEPS network contraction with the Zipper method.</li><li><code>i::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMps</code>: The constructed top MPS using the Zipper method for the specified row.</li></ul><p>This function constructs the top Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, and truncation steps based on the specified parameters in <code>ctr.params</code>. The resulting MPS is memoized for efficient reuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.mps" href="#SpinGlassEngine.mps"><code>SpinGlassEngine.mps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mps(ctr::MpsContractor{SVDTruncate, R, S}, i::Int64) -&gt; Any
</code></pre><p>Construct and memoize the (bottom) Matrix Product State (MPS) using Singular Value Decomposition (SVD) for a given row.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{SVDTruncate}</code>: The MpsContractor object representing the PEPS network contraction with SVD truncation.</li><li><code>i::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMps</code>: The constructed (bottom) MPS for the specified row.</li></ul><p>This function constructs the (bottom) MPS using SVD for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, truncation, and compression steps as needed based on the specified parameters in <code>ctr.params</code>. The resulting MPS is memoized for efficient reuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L335">source</a></section><section><div><pre><code class="language-julia hljs">mps(ctr::MpsContractor{Zipper, R, S}, i::Int64) -&gt; Any
</code></pre><p>Construct and memoize the (bottom) Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{Zipper}</code>: The MpsContractor object representing the PEPS network contraction with the Zipper method.</li><li><code>i::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMps</code>: The constructed (bottom) MPS using the Zipper method for the specified row.</li></ul><p>This function constructs the (bottom) Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, and truncation steps based on the specified parameters in <code>ctr.params</code>. The resulting MPS is memoized for efficient reuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.mps_approx" href="#SpinGlassEngine.mps_approx"><code>SpinGlassEngine.mps_approx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mps_approx(
    ctr::MpsContractor{SVDTruncate, R, S},
    i::Int64
) -&gt; Any
</code></pre><p>Construct and memoize the (bottom) Matrix Product State (MPS) approximation using Singular Value Decomposition (SVD) for a given row.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{SVDTruncate}</code>: The MpsContractor object representing the PEPS network contraction with SVD truncation.</li><li><code>i::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMps</code>: The constructed (bottom) MPS approximation for the specified row.</li></ul><p>This function constructs the (bottom) MPS approximation using SVD for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, and truncation steps based on the specified parameters in <code>ctr.params</code>. The resulting MPS approximation is memoized for efficient reuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.dressed_mps" href="#SpinGlassEngine.dressed_mps"><code>SpinGlassEngine.dressed_mps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dressed_mps(
    ctr::MpsContractor{T&lt;:SpinGlassEngine.AbstractStrategy},
    i::Int64
) -&gt; Any
</code></pre><p>Construct (and memoize) dressed Matrix Product State (MPS) for a given row and strategy.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: The MpsContractor object representing the PEPS network contraction.</li><li><code>i::Int</code>: The current row index.</li></ul><p><strong>Returns</strong></p><ul><li><code>QMps</code>: The constructed dressed MPS for the specified row and strategy.</li></ul><p>This function constructs the dressed Matrix Product State (MPS) for a given row in the PEPS network contraction using the specified strategy and memoizes the result for future use. It internally calls other functions such as <code>mps</code> and <code>mpo</code> to construct the dressed MPS. Additionally, it normalizes the MPS tensors to ensure numerical stability.</p><p>Note: The memoization ensures that the dressed MPS is only constructed once for each combination of arguments and is reused when needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.right_env" href="#SpinGlassEngine.right_env"><code>SpinGlassEngine.right_env</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_env(
    ctr::MpsContractor{T&lt;:SpinGlassEngine.AbstractStrategy, R, S},
    i::Int64,
    ∂v::Vector{Int64}
) -&gt; Any
</code></pre><p>Construct (and memoize) the right environment tensor for a given node in the PEPS network contraction.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: The MpsContractor object representing the PEPS network contraction.</li><li><code>i::Int</code>: The current row index.</li><li><code>∂v::Vector{Int}</code>: A vector representing the partial environment configuration.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{S,2}</code>: The constructed right environment tensor for the specified node.</li></ul><p>This function constructs the right environment tensor for a given node in the PEPS network contraction using the specified strategy and memoizes the result for future use. It internally calls other functions such as <code>dressed_mps</code> and <code>mpo</code> to construct the right environment tensor. Additionally, it normalizes the right environment tensor to ensure numerical stability.</p><p>Note: The memoization ensures that the right environment tensor is only constructed once for each combination of arguments and is reused when needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.left_env" href="#SpinGlassEngine.left_env"><code>SpinGlassEngine.left_env</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_env(
    ctr::MpsContractor{T, R, S},
    i::Int64,
    ∂v::Vector{Int64}
) -&gt; Any
</code></pre><p>Construct (and memoize) the left environment tensor for a given node in the PEPS network contraction.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: The MpsContractor object representing the PEPS network contraction.</li><li><code>i::Int</code>: The current row index.</li><li><code>∂v::Vector{Int}</code>: A vector representing the partial environment configuration.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{S,2}</code>: The constructed left environment tensor for the specified node.</li></ul><p>This function constructs the left environment tensor for a given node in the PEPS network contraction using the specified strategy and memoizes the result for future use. It internally calls other functions such as <code>dressed_mps</code> to construct the left environment tensor. Additionally, it normalizes the left environment tensor to ensure numerical stability.</p><p>Note: The memoization ensures that the left environment tensor is only constructed once for each combination of arguments and is reused when needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.clear_memoize_cache" href="#SpinGlassEngine.clear_memoize_cache"><code>SpinGlassEngine.clear_memoize_cache</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear_memoize_cache() -&gt; Vector
</code></pre><p>Clear all memoization caches used by the PEPS network contraction.</p><p>This function clears all memoization caches that store previously computed results for various operations and environments in the PEPS network contraction. Memoization is used to optimize the contraction process by avoiding redundant computations. Calling this function removes all cached results, which can be useful when you want to free up memory or ensure that the caches are refreshed with updated data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L655">source</a></section><section><div><pre><code class="language-julia hljs">clear_memoize_cache(
    ctr::MpsContractor{T, S},
    row::Union{Rational{Int64}, Int64}
)
</code></pre><p>Clear memoization cache for specific operations for a given row and index beta.</p><p>This function clears the memoization cache for specific operations used in the PEPS network contraction for a given row. The cleared operations include <code>mps_top</code>, <code>mps</code>, <code>mpo</code>, <code>dressed_mps</code>, and related operations. Memoization is used to optimize the contraction process by avoiding redundant computations. Calling this function allows you to clear the cache for these specific operations for a particular row and index beta, which can be useful when you want to free up memory or ensure that the cache is refreshed with updated data for a specific computation.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T, S}</code>: The PEPS network contractor object.</li><li><code>row::Site</code>: The row for which the cache should be cleared.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L679">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.clear_memoize_cache_after_row" href="#SpinGlassEngine.clear_memoize_cache_after_row"><code>SpinGlassEngine.clear_memoize_cache_after_row</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear_memoize_cache_after_row() -&gt; NTuple{4, Vector}
</code></pre><p>Clear memoization caches for specific operations after processing a row. This function clears the memoization caches for specific operations used in the PEPS network contraction after processing a row. The cleared operations include <code>left_env</code>, <code>right_env</code>, <code>mpo</code>, and <code>dressed_mps</code>. Memoization is used to optimize the contraction process by avoiding redundant computations. Calling this function allows you to clear the caches for these specific operations, which can be useful when you want to free up memory or ensure that the caches are refreshed with updated data after processing a row in the contraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/contractor.jl#L667">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.vertex_map" href="#SpinGlassEngine.vertex_map"><code>SpinGlassEngine.vertex_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_map(
    vert_permutation::NTuple{4, Int64},
    nrows,
    ncols
) -&gt; SpinGlassEngine.var&quot;#vmap#18&quot;
</code></pre><p>Create a vertex mapping function for a lattice transformation.</p><p><strong>Arguments</strong></p><ul><li><code>vert_permutation::NTuple{4, Int}</code>: A permutation of vertex labels, defining a specific lattice transformation.</li><li><code>nrows::Int</code>: The number of rows in the lattice.</li><li><code>ncols::Int</code>: The number of columns in the lattice.</li></ul><p><strong>Returns</strong></p><p>A vertex mapping function <code>vmap</code> that takes a tuple of vertex coordinates and returns their new coordinates after applying the specified lattice transformation.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/operations.jl#L111">source</a></section><section><div><pre><code class="language-julia hljs">vertex_map(
    trans::LatticeTransformation,
    m::Int64,
    n::Int64
) -&gt; SpinGlassEngine.var&quot;#vmap#18&quot;
</code></pre><p>Create a vertex map function based on a given lattice transformation.</p><p>This function generates a vertex map function that can be used to transform lattice vertex coordinates according to a specified lattice transformation. The <code>trans</code> argument should be a <code>LatticeTransformation</code> object, and <code>m</code> and <code>n</code> specify the dimensions of the lattice.</p><p><strong>Arguments</strong></p><ul><li><code>trans::LatticeTransformation</code>: The lattice transformation to apply.</li><li><code>m::Int</code>: The number of rows in the lattice.</li><li><code>n::Int</code>: The number of columns in the lattice.</li></ul><p><strong>Returns</strong></p><p>A vertex map function that takes vertex coordinates and returns the transformed coordinates.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/operations.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.check_bounds" href="#SpinGlassEngine.check_bounds"><code>SpinGlassEngine.check_bounds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_bounds(m, n) -&gt; SpinGlassEngine.var&quot;#_check#1&quot;
</code></pre><p>Create a bounds-checking function for a lattice of size (m, n).</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: The number of rows in the lattice.</li><li><code>n::Int</code>: The number of columns in the lattice.</li></ul><p><strong>Returns</strong></p><p>A bounds-checking function that can be used to ensure that lattice points are within the specified bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/operations.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.LatticeTransformation" href="#SpinGlassEngine.LatticeTransformation"><code>SpinGlassEngine.LatticeTransformation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A struct representing a lattice transformation.</p><p><strong>Fields</strong></p><ul><li><code>permutation::NTuple{4, Int}</code>: A tuple defining a permutation of the vertex labels.</li><li><code>flips_dimensions::Bool</code>: A boolean indicating whether dimension flips are applied.</li></ul><p>The <code>LatticeTransformation</code> struct defines a transformation that can be applied to the vertices of a lattice.  It specifies a permutation of vertex labels, allowing for rotations and reflections, as well as an option to flip dimensions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/operations.jl#L7">source</a></section></article><h2 id="Droplets"><a class="docs-heading-anchor" href="#Droplets">Droplets</a><a id="Droplets-1"></a><a class="docs-heading-anchor-permalink" href="#Droplets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.Flip" href="#SpinGlassEngine.Flip"><code>SpinGlassEngine.Flip</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A data structure representing a set of flips or changes in states for nodes in the SpinGlassPEPS package.</p><p>A <code>Flip</code> object contains information about the support, state changes, and spinxor values for a set of node flips in the SpinGlassPEPS system.</p><p><strong>Fields</strong></p><ul><li><code>support::Vector{Int}</code>: An array of integers representing the indices of nodes where flips occur.</li><li><code>state::Vector{Int}</code>: An array of integers representing the new states for the nodes in the <code>support</code>.</li><li><code>spinxor::Vector{Int}</code>: An array of integers representing the spin-xor values for the nodes in the <code>support</code>.</li></ul><p><strong>Constructors</strong></p><ul><li><code>Flip(support::Vector{Int}, state::Vector{Int}, spinxor::Vector{Int})</code>:</li></ul><p>Creates a new <code>Flip</code> object with the specified support, state changes, and spinxor values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L51-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.Droplet" href="#SpinGlassEngine.Droplet"><code>SpinGlassEngine.Droplet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A data structure representing a droplet in the context of the SpinGlassPEPS package. A <code>Droplet</code> represents an excitation in the SpinGlassPEPS system. It contains information about the excitation energy, the site where the droplet starts, the site where it ends, the states of nodes flipped by the droplet, and any sub-droplets on top of the current droplet.</p><p><strong>Fields</strong></p><ul><li><code>denergy::Real</code>: The excitation energy of the droplet, typically a real number.</li><li><code>first::Int</code>: The site index where the droplet starts.</li><li><code>last::Int</code>: The site index where the droplet ends.</li><li><code>flip::Flip</code>: The states of nodes flipped by the droplet, often represented using a <code>Flip</code> type.</li><li><code>droplets::Union{NoDroplets, Vector{Droplet}}</code>: A field that can be either <code>NoDroplets()</code> if there are no sub-droplets</li></ul><p>on top of the current droplet or a vector of <code>Droplet</code> objects representing sub-droplets. This field may be used to build a hierarchy of droplets in more complex excitations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.NoDroplets" href="#SpinGlassEngine.NoDroplets"><code>SpinGlassEngine.NoDroplets</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This is a method used to calculate excitation information for the <code>NoDroplets</code> strategy in the context of a SpinGlassPEPS contractor. The <code>NoDroplets</code> strategy represents a scenario in which no droplets are present in the system, and therefore, no excitation information is calculated.</p><p><strong>Arguments</strong></p><ul><li><code>method::NoDroplets</code>: An instance of the <code>NoDroplets</code> strategy.</li><li><code>ctr::MpsContractor{T}</code>: A SpinGlassPEPS contractor of type <code>T</code> representing the system.</li><li><code>best_idx::Int</code>: The index of the best state.</li><li><code>energies::Vector{&lt;:Real}</code>: A vector of energies associated with different states.</li><li><code>states::Vector{Vector{Int}}</code>: A vector of states represented as arrays of integers.</li><li><code>droplets::Vector{Droplets}</code>: A vector of droplets in the system.</li><li><code>spins::Vector{Vector{Int}}</code>: A vector of spin configurations associated with states.</li></ul><p><strong>Returns</strong></p><ul><li><code>NoDroplets()</code>: An instance of the <code>NoDroplets</code> strategy indicating that no excitation information is calculated in this scenario.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.hamming_distance" href="#SpinGlassEngine.hamming_distance"><code>SpinGlassEngine.hamming_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hamming_distance(flip::Flip, s::Symbol) -&gt; Int64
</code></pre><p>Calculate the Hamming distance for a &#39;Flip&#39; object.</p><p><strong>Arguments</strong></p><ul><li><code>flip::Flip</code>: The &#39;Flip&#39; object for which the Hamming distance will be calculated.</li></ul><p><strong>Returns</strong></p><ul><li><code>d::Int</code>: The computed Hamming distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L263">source</a></section><section><div><pre><code class="language-julia hljs">hamming_distance(state1, state2, s::Symbol) -&gt; Int64
</code></pre><p>Calculate the Hamming distance between two vectors of states.</p><p><strong>Arguments</strong></p><ul><li><code>state1::Vector{Int}</code>: The first vector.</li><li><code>state2::Vector{Int}</code>: The second vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>d::Int</code>: The computed Hamming distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L279">source</a></section><section><div><pre><code class="language-julia hljs">hamming_distance(
    flip1::Flip,
    flip2::Flip,
    s::Symbol
) -&gt; Int64
</code></pre><p>Calculate the Hamming distance between two Flip objects representing states with support and flip information.</p><p><strong>Arguments</strong></p><ul><li><code>flip1::Flip</code>: The first Flip object, containing support, state, and spinxor information.</li><li><code>flip2::Flip</code>: The second Flip object, with support, state, and spinxor information.</li></ul><p><strong>Returns</strong></p><ul><li><code>hd::Int</code>: The computed Hamming distance between the two Flip objects.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.unpack_droplets" href="#SpinGlassEngine.unpack_droplets"><code>SpinGlassEngine.unpack_droplets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpack_droplets(sol, β) -&gt; Solution
</code></pre><p>Unpack droplets in a solution structure to create a new solution with individual excitations.</p><p><strong>Arguments</strong></p><ul><li><code>sol</code>: The input solution containing droplets to be unpacked.</li><li><code>β::Real</code>: The inverse temperature parameter used for probability adjustments.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_sol</code>: A new solution where droplets are unpacked into individual excitations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.perm_droplet" href="#SpinGlassEngine.perm_droplet"><code>SpinGlassEngine.perm_droplet</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">perm_droplet(
    drop::NoDroplets,
    perm::Vector{Int64}
) -&gt; NoDroplets
</code></pre><p>Apply a permutation to a &#39;NoDroplets&#39; object, resulting in an unchanged &#39;NoDroplets&#39;.</p><p><strong>Arguments</strong></p><ul><li><code>drop::NoDroplets</code>: The &#39;NoDroplets&#39; object that remains unchanged.</li><li><code>perm::Vector{Int}</code>: A permutation vector that is applied to indices.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::NoDroplets</code>: The &#39;NoDroplets&#39; object, which remains the same.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L510">source</a></section><section><div><pre><code class="language-julia hljs">perm_droplet(
    drops::Vector{Droplet},
    perm::Vector{Int64}
) -&gt; Vector{Droplet}
</code></pre><p>Apply a permutation to a collection of &#39;Droplet&#39; objects.</p><p><strong>Arguments</strong></p><ul><li><code>drops::Vector{Droplet}</code>: A vector of &#39;Droplet&#39; objects to which the permutation is applied.</li><li><code>perm::Vector{Int}</code>: A permutation vector that is applied to indices.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::Vector{Droplet}</code>: A vector of &#39;Droplet&#39; objects after applying the permutation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L523">source</a></section><section><div><pre><code class="language-julia hljs">perm_droplet(drop::Droplet, perm::Vector{Int64}) -&gt; Droplet
</code></pre><p>Apply a permutation to a &#39;Droplet&#39; object.</p><p><strong>Arguments</strong></p><ul><li><code>drop::Droplet</code>: A &#39;Droplet&#39; object to which the permutation is applied.</li><li><code>perm::Vector{Int}</code>: A permutation vector that is applied to indices.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::Droplet</code>: A &#39;Droplet&#39; object after applying the permutation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.filter_droplets" href="#SpinGlassEngine.filter_droplets"><code>SpinGlassEngine.filter_droplets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_droplets(
    all_droplets::Vector{Droplet},
    method::SingleLayerDroplets
) -&gt; Vector{Droplet}
</code></pre><p>Filter a vector of droplets based on specified criteria and strategy parameters.</p><p><strong>Arguments</strong></p><ul><li><code>all_droplets::Vector{Droplet}</code>: A vector of <code>Droplet</code> objects representing the droplets to be filtered.</li><li><code>method::SingleLayerDroplets</code>: An instance of the <code>SingleLayerDroplets</code> strategy used to determine filtering criteria.</li></ul><p><strong>Returns</strong></p><ul><li><code>filtered_droplets::Vector{Droplet}</code>: A filtered vector of <code>Droplet</code> objects based on the specified criteria and strategy parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.my_push!" href="#SpinGlassEngine.my_push!"><code>SpinGlassEngine.my_push!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">my_push!(
    ndroplets::Union{NoDroplets, Vector{Droplet}},
    droplet::Droplet,
    method
) -&gt; Union{NoDroplets, Vector{Droplet}}
</code></pre><p>Push a &#39;Droplet&#39; object into a vector of droplets (&#39;Droplets&#39;) while considering the strategy parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ndroplets::Droplets</code>: A vector of &#39;Droplet&#39; objects to which the new &#39;Droplet&#39; object will be added.</li><li><code>droplet::Droplet</code>: The &#39;Droplet&#39; object to be added to the vector.</li><li><code>method</code>: The strategy parameter that determines whether or not the &#39;Droplet&#39; object is added based on the defined criteria.</li></ul><p><strong>Returns</strong></p><ul><li><code>ndroplets::Droplets</code>: The updated vector of &#39;Droplet&#39; objects after the addition of the new &#39;Droplet&#39; object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.diversity_metric" href="#SpinGlassEngine.diversity_metric"><code>SpinGlassEngine.diversity_metric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diversity_metric(
    drop1::Droplet,
    drop2::Droplet,
    metric::Symbol,
    mode::Symbol
) -&gt; Union{Float64, Int64}
</code></pre><p>Calculate the diversity metric between two &#39;Droplet&#39; objects based on the specified metric.</p><p><strong>Arguments</strong></p><ul><li><code>drop1::Droplet</code>: The first &#39;Droplet&#39; object for comparison.</li><li><code>drop2::Droplet</code>: The second &#39;Droplet&#39; object for comparison.</li><li><code>metric::Symbol</code>: A symbol specifying the metric to be used for the diversity calculation. Currently, only the &quot;hamming&quot; metric is supported.</li></ul><p><strong>Returns</strong></p><ul><li><code>d::Real</code>: The calculated diversity metric value between the two &#39;Droplet&#39; objects.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.merge_droplets" href="#SpinGlassEngine.merge_droplets"><code>SpinGlassEngine.merge_droplets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_droplets(
    method::SingleLayerDroplets,
    droplet::Droplet,
    subdroplet::Droplet
) -&gt; Droplet
</code></pre><p>Merge two Droplets according to the specified <code>SingleLayerDroplets</code> method.</p><p><strong>Arguments</strong></p><ul><li><code>method::SingleLayerDroplets</code>: The method used to determine whether and how to merge the droplets.</li><li><code>droplet::Droplet</code>: The main droplet to be merged.</li><li><code>subdroplet::Droplet</code>: The subdroplet to be merged with the main droplet.</li></ul><p><strong>Returns</strong></p><ul><li><code>merged_droplet::Droplet</code>: The merged droplet created based on the merging method.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.flip_state" href="#SpinGlassEngine.flip_state"><code>SpinGlassEngine.flip_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flip_state(
    state::Vector{Int64},
    flip::Flip
) -&gt; Vector{Int64}
</code></pre><p>Apply a flip operation to a state.</p><p><strong>Arguments</strong></p><ul><li><code>state::Vector{Int}</code>: The original state vector.</li><li><code>flip::Flip</code>: The flip operation to be applied to the state.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_state::Vector{Int}</code>: The modified state after applying the flip operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/droplets.jl#L442">source</a></section></article><h2 id="PEPS"><a class="docs-heading-anchor" href="#PEPS">PEPS</a><a id="PEPS-1"></a><a class="docs-heading-anchor-permalink" href="#PEPS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.local_energy" href="#SpinGlassEngine.local_energy"><code>SpinGlassEngine.local_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_energy(
    network::AbstractGibbsNetwork{S, T, R},
    vertex
) -&gt; Any
</code></pre><p>Retrieve the local energy spectrum associated with a specific vertex in the Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>network::AbstractGibbsNetwork{S, T}</code>: Gibbs network containing the Potts Hamiltonian.</li><li><code>vertex::S</code>: Vertex for which the local energy spectrum is to be retrieved.</li></ul><p><strong>Returns</strong></p><ul><li>Local energy spectrum associated with the specified vertex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.interaction_energy" href="#SpinGlassEngine.interaction_energy"><code>SpinGlassEngine.interaction_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interaction_energy(
    network::AbstractGibbsNetwork{S, T, R},
    v,
    w
) -&gt; Any
</code></pre><p>Compute the interaction energy between two vertices in a Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>network::AbstractGibbsNetwork{S, T}</code>: Gibbs network containing the Potts Hamiltonian.</li><li><code>v::S</code>: First vertex.</li><li><code>w::S</code>: Second vertex.</li></ul><p><strong>Returns</strong></p><ul><li><code>energy::Matrix{T}</code>: Interaction energy matrix between vertices <code>v</code> and <code>w</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.normalize_probability" href="#SpinGlassEngine.normalize_probability"><code>SpinGlassEngine.normalize_probability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize_probability(probs::Vector{&lt;:Real}) -&gt; Any
</code></pre><p>Normalize a probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>probs::Vector{&lt;:Real}</code>: A vector representing a probability distribution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Normalized probability distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.initialize_gauges!" href="#SpinGlassEngine.initialize_gauges!"><code>SpinGlassEngine.initialize_gauges!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_gauges!(net::AbstractGibbsNetwork{S, T, R})
initialize_gauges!(
    net::AbstractGibbsNetwork{S, T, R},
    type::Symbol
)
</code></pre><p>Initialize gauge tensors in a Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>net::AbstractGibbsNetwork{S, T}</code>: Gibbs network to initialize.</li><li><code>type::Symbol=:id</code>: Type of initialization, either <code>:id</code> for identity or <code>:rand</code> for random values.</li></ul><p><strong>Description</strong></p><p>This function initializes gauge tensors in a Gibbs network according to the specified type.  Each gauge tensor is associated with two positions in the network and a type.  The positions are determined by the gauge&#39;s <code>positions</code> field, and the type is specified by the gauge&#39;s <code>type</code> field.  The initialization type can be either <code>:id</code> for identity tensors or <code>:rand</code> for random tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.decode_state" href="#SpinGlassEngine.decode_state"><code>SpinGlassEngine.decode_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decode_state(
    peps::AbstractGibbsNetwork{S, T},
    σ::Vector{Int64}
) -&gt; Any
decode_state(
    peps::AbstractGibbsNetwork{S, T},
    σ::Vector{Int64},
    potts_h_order::Bool
) -&gt; Any
</code></pre><p>Decode a state vector into a dictionary representation.</p><p><strong>Arguments</strong></p><ul><li><code>peps::AbstractGibbsNetwork{S, T}</code>: The Gibbs network.</li><li><code>σ::Vector{Int}</code>: State vector to be decoded.</li><li><code>potts_h_order::Bool=false</code>: If true, use the order of nodes in the Potts Hamiltonian.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Symbol, Int}</code>: A dictionary mapping node symbols to corresponding values in the state vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.bond_energy" href="#SpinGlassEngine.bond_energy"><code>SpinGlassEngine.bond_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bond_energy(
    net::AbstractGibbsNetwork{T, S, R},
    u::NTuple{N, Int64} where N,
    v::NTuple{N, Int64} where N,
    σ::Int64
) -&gt; Any
</code></pre><p>Calculate the bond energy between nodes <code>u</code> and <code>v</code> for a given index <code>σ</code> in the Gibbs network <code>net</code>.</p><p><strong>Arguments</strong></p><ul><li><code>net::AbstractGibbsNetwork{T, S}</code>: The Gibbs network.</li><li><code>u::Node</code>: One of the nodes connected by the bond.</li><li><code>v::Node</code>: The other node connected by the bond.</li><li><code>σ::Int</code>: The index for which the bond energy is calculated.</li></ul><p><strong>Returns</strong></p><ul><li><code>energies::Vector{T}</code>: Vector containing the bond energies between nodes <code>u</code> and <code>v</code> for index <code>σ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.projector" href="#SpinGlassEngine.projector"><code>SpinGlassEngine.projector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">projector(network::AbstractGibbsNetwork{S, T}, v, w) -&gt; Any
</code></pre><p>Compute the projector between two nodes <code>v</code> and <code>w</code> in the Gibbs network <code>network</code>.</p><p><strong>Arguments</strong></p><ul><li><code>network::AbstractGibbsNetwork{S, T}</code>: The Gibbs network.</li><li><code>v::S</code>: Source node.</li><li><code>w::S</code>: Target node.</li></ul><p><strong>Returns</strong></p><ul><li><code>projector::Matrix{T}</code>: Projector matrix between nodes <code>v</code> and <code>w</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L148">source</a></section><section><div><pre><code class="language-julia hljs">projector(
    net::AbstractGibbsNetwork{S, T},
    v,
    vertices::NTuple{N, S}
) -&gt; Any
</code></pre><p>Compute the projector matrix for the given node <code>v</code> onto a tuple of target nodes <code>vertices</code> in the Gibbs network <code>net</code>.</p><p><strong>Arguments</strong></p><ul><li><code>net::AbstractGibbsNetwork{S, T}</code>: The Gibbs network.</li><li><code>v::S</code>: Source node.</li><li><code>vertices::NTuple{N, S}</code>: Tuple of target nodes onto which the projector is computed.</li></ul><p><strong>Returns</strong></p><ul><li>first fused projector matrix for node <code>v</code> onto the specified target nodes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.spectrum" href="#SpinGlassEngine.spectrum"><code>SpinGlassEngine.spectrum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectrum(network::AbstractGibbsNetwork{S, T}, vertex) -&gt; Any
</code></pre><p>Retrieve the spectrum associated with a specific vertex in the Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>network::AbstractGibbsNetwork{S, T}</code>: Gibbs network containing the Potts Hamiltonian.</li><li><code>vertex::S</code>: Vertex for which the spectrum is to be retrieved.</li></ul><p><strong>Returns</strong></p><ul><li>Spectrum associated with the specified vertex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.is_compatible" href="#SpinGlassEngine.is_compatible"><code>SpinGlassEngine.is_compatible</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_compatible(
    potts_hamiltonian::LabelledGraphs.LabelledGraph,
    network_graph::LabelledGraphs.LabelledGraph
) -&gt; Union{Missing, Bool}
</code></pre><p>Check if a Potts Hamiltonian is compatible with a given network graph.</p><p><strong>Arguments</strong></p><ul><li><code>potts_hamiltonian::LabelledGraph</code>: Graph representing the Potts Hamiltonian.</li><li><code>network_graph::LabelledGraph</code>: Graph representing the network.</li></ul><p><strong>Returns</strong></p><ul><li><code>compatibility::Bool</code>: <code>true</code> if the Potts Hamiltonian is compatible with the network graph, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.ones_like" href="#SpinGlassEngine.ones_like"><code>SpinGlassEngine.ones_like</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ones_like(x::Number) -&gt; Any
</code></pre><p>Create an identity with the same type as the input number <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A numeric value.</li></ul><p><strong>Returns</strong></p><ul><li>a multiplicative identity with the same type as <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L98">source</a></section><section><div><pre><code class="language-julia hljs">ones_like(x::AbstractArray) -&gt; Any
</code></pre><p>Create an array of ones with the same element type and size as the input array <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: An array serving as a template.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::Array</code>: An array of ones with the same element type and size as <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.tensor_map" href="#SpinGlassEngine.tensor_map"><code>SpinGlassEngine.tensor_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensor_map(
    _::Type{SquareSingleNode{T&lt;:Union{EnergyGauges, GaugesEnergy}}},
    _::Type{S&lt;:AbstractSparsity},
    nrows::Int64,
    ncols::Int64
) -&gt; Dict{PEPSNode, Symbol}
</code></pre><p>Assigns type of tensor to a PEPS node coordinates for a given Layout and Sparsity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_single_node.jl#L53">source</a></section><section><div><pre><code class="language-julia hljs">tensor_map(
    _::Type{SquareSingleNode{T&lt;:EngGaugesEng}},
    _::Type{S&lt;:AbstractSparsity},
    nrows::Int64,
    ncols::Int64
) -&gt; Dict{PEPSNode, Symbol}
</code></pre><p>Assigns type of tensor to a PEPS node coordinates for a given Layout and Sparsity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_single_node.jl#L78">source</a></section><section><div><pre><code class="language-julia hljs">tensor_map(
    _::Type{SquareCrossDoubleNode{T&lt;:Union{EnergyGauges, GaugesEnergy}}},
    _::Type{S&lt;:AbstractSparsity},
    nrows::Int64,
    ncols::Int64
) -&gt; Dict{PEPSNode, Symbol}
</code></pre><p>Create a mapping of tensor network nodes for a square cross double node geometry.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{SquareCrossDoubleNode{T}}</code>: Type representing a square cross double node geometry.</li><li><code>::Type{S}</code>: Type representing sparsity in the tensor network.</li><li><code>nrows::Int</code>: Number of rows in the tensor network.</li><li><code>ncols::Int</code>: Number of columns in the tensor network.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{PEPSNode, Symbol}</code>: A dictionary mapping PEPS nodes to symbols representing their corresponding tensor network nodes.</li></ul><p><strong>Description</strong></p><p>The <code>tensor_map</code> function generates a mapping of tensor network nodes for a square cross double node geometry. The mapping includes different types of nodes, such as site double nodes, virtual double nodes, central vertical double nodes, and central diagonal double nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(
    net::PEPSNetwork{SquareCrossDoubleNode{T&lt;:AbstractTensorsLayout}, S&lt;:AbstractSparsity},
    node::PEPSNode,
    _::Val{:central_d_double_node}
) -&gt; Tuple{Any, Any}
</code></pre><p>Determine the size of the tensor corresponding to a central double node in a projected entangled pair states (PEPS) tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{SquareCrossDoubleNode{T}, S}</code>: PEPS tensor network with square cross double nodes.</li><li><code>node::PEPSNode</code>: Node representing the position of the central double node.</li><li><code>::Val{:central_d_double_node}</code>: symbol to indicate the central double node.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int, Int}</code>: Tuple representing the size of the tensor for the central double node.</li></ul><p><strong>Description</strong></p><p>The <code>Base.size</code> function is used to determine the size of the tensor corresponding to a central double node in a PEPS tensor network. It calculates the size by considering the sizes of the two central tensors associated with neighboring positions. The function is parametrized by the abstract tensors layout type <code>T</code> and the abstract sparsity type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L755">source</a></section><section><div><pre><code class="language-julia hljs">size(
    net::AbstractGibbsNetwork{NTuple{N, Int64} where N, PEPSNode},
    node::PEPSNode,
    _::Union{Val{:virtual_double_node}, Val{:sparse_virtual_double_node}}
) -&gt; NTuple{4, Any}
</code></pre><p>Determine the size of the virtual tensor associated with a virtual double node in a tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>net::AbstractGibbsNetwork{Node, PEPSNode}</code>: Abstract Gibbs PEPS tensor network with nodes and virtual tensors.</li><li><code>node::PEPSNode</code>: PEPS node representing the position of the virtual double node.</li><li><code>::Union{Val{:virtual_double_node}, Val{:sparse_virtual_double_node}}</code>: Tag indicating whether the virtual tensor is dense or sparse.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple <code>(s1, s2, s3, s4)</code>: Size information for the virtual tensor.</li></ul><p><strong>Description</strong></p><p>The <code>size</code> function determines the size of the virtual tensor associated with a virtual double node in an Abstract Gibbs PEPS tensor network. The size is specified by the dimensions along the left, top, right, and bottom directions. The function is parametrized by the types of nodes (<code>Node</code> and <code>PEPSNode</code>) and the tag indicating whether the virtual tensor is dense or sparse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L949">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.exact_spectrum" href="#SpinGlassEngine.exact_spectrum"><code>SpinGlassEngine.exact_spectrum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_spectrum(
    potts_hamiltonian::LabelledGraphs.LabelledGraph{S, T}
) -&gt; Any
</code></pre><p>Calculate the exact spectrum and corresponding eigenstates for a Potts Hamiltonian using memoization.</p><p><strong>Arguments</strong></p><ul><li><code>potts_hamiltonian::LabelledGraph{S, T}</code>: A Potts Hamiltonian represented as a labelled graph.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple <code>(energies, states)</code>: A tuple containing the calculated energies and corresponding eigenstates.</li></ul><p><strong>Description</strong></p><p>The <code>exact_spectrum</code> function calculates the exact spectrum and corresponding eigenstates for a Potts Hamiltonian using memoization.  The function utilizes memoization to efficiently store and retrieve previously computed results for different inputs, reducing redundant calculations. The Hamiltonian is represented as a labelled graph (<code>LabelledGraph</code>) with vertices corresponding to clusters and edges  representing interactions between clusters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/util.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.discard_probabilities!" href="#SpinGlassEngine.discard_probabilities!"><code>SpinGlassEngine.discard_probabilities!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discard_probabilities!(
    psol::Solution,
    cutoff_prob::Real
) -&gt; Solution
</code></pre><p>Discards low-probability states from the given solution.</p><p><strong>Arguments</strong></p><ul><li><code>psol::Solution</code>: The input solution containing states and their probabilities.</li><li><code>cutoff_prob::Real</code>: The cutoff probability below which states will be discarded.</li></ul><p><strong>Returns</strong></p><ul><li><code>Solution</code>: A new solution with low-probability states discarded.</li></ul><p><strong>Description</strong></p><p>This function removes states from the solution <code>psol</code> whose probabilities are below the specified <code>cutoff_prob</code>. It calculates a cutoff probability (<code>pcut</code>) based on the maximum probability in <code>psol</code> and the provided <code>cutoff_prob</code>. States with probabilities lower than <code>pcut</code> are considered discarded. The largest discarded probability (<code>ldp</code>) in the resulting solution is updated based on the maximum discarded probability among the removed states and the existing <code>ldp</code> in <code>psol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.mod_wo_zero" href="#SpinGlassEngine.mod_wo_zero"><code>SpinGlassEngine.mod_wo_zero</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mod_wo_zero(k, m) -&gt; Any
</code></pre><p>Calculate the modulo operation of <code>k</code> with respect to <code>m</code>, ensuring the result is not zero.</p><p><strong>Arguments</strong></p><ul><li><code>k</code>: The dividend.</li><li><code>m</code>: The divisor.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::Int</code>: The result of <code>k % m</code>, ensuring it is not zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.exact_marginal_probability" href="#SpinGlassEngine.exact_marginal_probability"><code>SpinGlassEngine.exact_marginal_probability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_marginal_probability(
    ctr::MpsContractor{T},
    σ::Vector{Int64}
) -&gt; Any
</code></pre><p>Calculate the exact marginal probability of a target state within the context of an MPS (Matrix Product State) contractor.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: An MPS contractor representing the contracted state and associated parameters.</li><li><code>σ::Vector{Int}</code>: A vector representing the encoded state.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The calculated exact marginal probability of the target state.</li></ul><p><strong>Description</strong></p><p>The <code>exact_marginal_probability</code> function calculates the exact marginal probability of a target state within the context of an MPS contractor.  It decodes the provided state vector <code>σ</code> using the <code>decode_state</code> function, obtains the exact spectrum and states  from the Potts Hamiltonian of the associated PEPS, and computes the marginal probability of the target state using the Boltzmann distribution. The function utilizes the <code>exact_spectrum</code> function to obtain the energies and states of the Potts Hamiltonian,  exponentiates the negative energies multiplied by the inverse temperature (<code>ctr.beta</code>), normalizes the probabilities,  and calculates the marginal probability of the target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/util.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine._normalize" href="#SpinGlassEngine._normalize"><code>SpinGlassEngine._normalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_normalize(probs::Vector{&lt;:Real}) -&gt; Any
</code></pre><p>Normalize a probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>probs::Vector{&lt;:Real}</code>: A vector representing a probability distribution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Normalized probability distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.projectors_site_tensor" href="#SpinGlassEngine.projectors_site_tensor"><code>SpinGlassEngine.projectors_site_tensor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">projectors_site_tensor(
    net::PEPSNetwork{T&lt;:SquareCrossDoubleNode, S},
    vertex::NTuple{N, Int64} where N
) -&gt; NTuple{4, Any}
</code></pre><p>Construct the set of projectors associated with a site tensor in a projected entangled pair states (PEPS) tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{T, S}</code>: PEPS tensor network with nodes of type <code>T</code> and tensors of sparsity type <code>S</code>.</li><li><code>vertex::Node</code>: Node representing the position of the site tensor.</li></ul><p><strong>Returns</strong></p><ul><li><code>(plf, pt, prf, pb)</code>: Tuple of projectors associated with the site tensor, corresponding to the left (plf), top (pt), right (prf), and bottom (pb) directions.</li></ul><p><strong>Description</strong></p><p>The <code>projectors_site_tensor</code> function constructs the set of projectors associated with a site tensor at the specified position in a PEPS tensor network. The projectors are created based on the neighboring tensors and directions in the network. The function is parametrized by the abstract node type <code>T</code> and the abstract sparsity type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L886">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.branch_probability" href="#SpinGlassEngine.branch_probability"><code>SpinGlassEngine.branch_probability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_probability(
    ctr::MpsContractor{T},
    pσ::Tuple{Real, Vector{Int64}}
) -&gt; Any
</code></pre><p>Calculates the branch probability for a given state.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: The MPS contractor object.</li><li><code>pσ::Tuple{&lt;:Real, Vector{Int}}</code>: Tuple containing the energy and state configuration.</li></ul><p><strong>Returns</strong></p><ul><li><code>Real</code>: The calculated branch probability.</li></ul><p><strong>Description</strong></p><p>This function calculates the branch probability for a specific state configuration using the conditional probability provided by the MPS contractor. The branch probability is computed as the logarithm of the conditional probability of the given state. The conditional probability is obtained from the MPS contractor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.exact_conditional_probability" href="#SpinGlassEngine.exact_conditional_probability"><code>SpinGlassEngine.exact_conditional_probability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_conditional_probability(
    ctr::MpsContractor{T},
    σ::Vector{Int64}
) -&gt; Any
</code></pre><p>Calculate the exact conditional probability of a target state within the context of an MPS (Matrix Product State) contractor.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: An MPS contractor representing the contracted state and associated parameters.</li><li><code>σ::Vector{Int}</code>: A vector representing the encoded state.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The calculated exact conditional probabilities for each possible outcome.</li></ul><p><strong>Description</strong></p><p>The <code>exact_conditional_probability</code> function calculates the exact conditional probability distribution of a target state within the context of an MPS contractor.  It uses the <code>exact_marginal_probability</code> function for different branch states generated by <code>branch_state</code> and normalizes the probabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/util.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.branch_solution" href="#SpinGlassEngine.branch_solution"><code>SpinGlassEngine.branch_solution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_solution(
    psol::Solution,
    ctr::SpinGlassEngine.AbstractContractor
) -&gt; Solution
</code></pre><p>Generate a new solution by branching the given partial solution in a contracting Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>psol::Solution</code>: The partial solution.</li><li><code>ctr::T</code>: The contractor representing the contracting Gibbs network.</li></ul><p><strong>Returns</strong></p><ul><li><code>Solution</code>: A new solution obtained by branching the partial solution in the contracting network.</li></ul><p><strong>Description</strong></p><p>This function generates a new solution by branching the given partial solution in a contracting Gibbs network. It computes the energies, states, probabilities, degeneracies, discarded probabilities, droplets, and spins for the resulting solution. The branching process involves considering the current node in the contractor and updating the solution accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.gauges_list" href="#SpinGlassEngine.gauges_list"><code>SpinGlassEngine.gauges_list</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareSingleNode{T&lt;:GaugesEnergy}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Assigns gauges and corresponding information to GaugeInfo structure for a given Layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_single_node.jl#L107">source</a></section><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareSingleNode{T&lt;:EnergyGauges}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Assigns gauges and corresponding information to GaugeInfo structure for a given Layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_single_node.jl#L127">source</a></section><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareSingleNode{T&lt;:EngGaugesEng}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Assigns gauges and corresponding information to GaugeInfo structure for a given Layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_single_node.jl#L147">source</a></section><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareDoubleNode{T&lt;:GaugesEnergy}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Assigns gauges and corresponding information to GaugeInfo structure for a given Layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_double_node.jl#L81">source</a></section><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareDoubleNode{T&lt;:EnergyGauges}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Assigns gauges and corresponding information to GaugeInfo structure for a given Layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_double_node.jl#L100">source</a></section><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareCrossDoubleNode{T&lt;:GaugesEnergy}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Create a list of gauge information for a square cross double node geometry and GaugesEnergy Layout.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{SquareCrossDoubleNode{T}}</code>: Type representing a square cross double node geometry.</li><li><code>nrows::Int</code>: Number of rows in the tensor network.</li><li><code>ncols::Int</code>: Number of columns in the tensor network.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{GaugeInfo}</code>: A vector of <code>GaugeInfo</code> objects representing gauge information for the specified geometry.</li></ul><p><strong>Description</strong></p><p>The <code>gauges_list</code> function generates a list of <code>GaugeInfo</code> objects for a square cross double node geometry. Each <code>GaugeInfo</code> object contains information about the positions of gauge links, the position of the attached tensor, the leg index, and the type of gauge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L130">source</a></section><section><div><pre><code class="language-julia hljs">gauges_list(
    _::Type{SquareCrossDoubleNode{T&lt;:EnergyGauges}},
    nrows::Int64,
    ncols::Int64
) -&gt; Vector{GaugeInfo}
</code></pre><p>Create a list of gauge information for a square cross double node geometry and EnergyGauges Layout.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{SquareCrossDoubleNode{T}}</code>: Type representing a square cross double node geometry.</li><li><code>nrows::Int</code>: Number of rows in the tensor network.</li><li><code>ncols::Int</code>: Number of columns in the tensor network.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{GaugeInfo}</code>: A vector of <code>GaugeInfo</code> objects representing gauge information for the specified geometry.</li></ul><p><strong>Description</strong></p><p>The <code>gauges_list</code> function generates a list of <code>GaugeInfo</code> objects for a square cross double node geometry. Each <code>GaugeInfo</code> object contains information about the positions of gauge links, the position of the attached tensor, the leg index, and the type of gauge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.branch_energies" href="#SpinGlassEngine.branch_energies"><code>SpinGlassEngine.branch_energies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_energies(
    ctr::MpsContractor{T},
    psol::Solution
) -&gt; Any
</code></pre><p>Compute and branch the energies from different branches in a solution.</p><p><strong>Arguments</strong></p><ul><li><code>ctr::MpsContractor{T}</code>: The MPS contractor.</li><li><code>psol::Solution</code>: The partial solution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:Real}</code>: A vector containing the energies of individual branches.</li></ul><p><strong>Description</strong></p><p>This function computes the energies of branches in a solution by applying the <code>branch_energy</code> function to each pair of energy and state in the given partial solution. The result is a vector of energies corresponding to the branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine._equalize" href="#SpinGlassEngine._equalize"><code>SpinGlassEngine._equalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_equalize(probs::Vector{&lt;:Real}) -&gt; Any
</code></pre><p>Equalize a probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>probs::Vector{&lt;:Real}</code>: A vector representing a probability distribution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Equalized probability distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.nodes_search_order_Mps" href="#SpinGlassEngine.nodes_search_order_Mps"><code>SpinGlassEngine.nodes_search_order_Mps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodes_search_order_Mps(
    peps::PEPSNetwork{T&lt;:SquareCrossDoubleNode, S}
) -&gt; Tuple{Vector, Tuple{Int64, Int64, Int64}}
</code></pre><p>Generate the search order of nodes for a matrix product states (MPS).</p><p><strong>Arguments</strong></p><ul><li><code>peps::PEPSNetwork{T, S}</code>: PEPS tensor network with a specific tensor layout.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple{Vector{Tuple{Int, Int, Int}}, Tuple{Int, Int, Int}}: Tuple containing the list of node coordinates and the size of the tensor network.</li></ul><p><strong>Description</strong></p><p>The <code>nodes_search_order_Mps</code> function generates the search order of nodes for a matrix product states (MPS). It creates a list of node coordinates <code>(i, j, k)</code> representing rows, columns, and index of group of spins, respectively. The resulting order is suitable for traversing the nodes in the tensor network during contraction. The function is specialized for the <code>SquareCrossDoubleNode</code> tensor network type and is parametrized by the layout type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.sampling" href="#SpinGlassEngine.sampling"><code>SpinGlassEngine.sampling</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sampling(
    psol::Solution,
    max_states::Int64,
    δprob::Real
) -&gt; Solution
sampling(
    psol::Solution,
    max_states::Int64,
    δprob::Real,
    merge_strategy
) -&gt; Solution
</code></pre><p>Generate a new solution by sampling states based on their probabilities.</p><p><strong>Arguments</strong></p><ul><li><code>psol::Solution</code>: The partial solution from which to sample states.</li><li><code>max_states::Int</code>: The maximum number of states to sample.</li><li><code>δprob::Real</code>: The probability threshold for discarding states.</li><li><code>merge_strategy=no_merge</code>: The merging strategy, defaults to <code>no_merge</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Solution</code>: A new solution obtained by sampling states.</li></ul><p><strong>Description</strong></p><p>This function generates a new solution by sampling states from the given partial solution. The sampling is performed based on the probabilities associated with each state. The number of sampled states is determined by the <code>max_states</code> argument. Additionally, states with probabilities below the threshold <code>δprob</code> are discarded. The optional argument <code>merge_strategy</code> specifies the merging strategy to be used during the sampling process. It defaults to <code>no_merge</code>, indicating no merging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.VirtualDoubleNode" href="#SpinGlassEngine.VirtualDoubleNode"><code>SpinGlassEngine.VirtualDoubleNode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VirtualDoubleNode(_::Type{Dense}) -&gt; Symbol
</code></pre><p>Create a symbol representing a virtual double node for a dense tensor layout.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{Dense}</code>: The <code>Dense</code> tensor layout type.</li></ul><p><strong>Returns</strong></p><ul><li><code>Symbol</code>: A symbol representing the virtual double node.</li></ul><p><strong>Description</strong></p><p>The <code>VirtualDoubleNode</code> function generates a symbol (<code>:virtual_double_node</code>) that represents a virtual double node in the context of a dense tensor layout. This symbol is often used to indicate the presence of a virtual double node when working with certain tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L56">source</a></section><section><div><pre><code class="language-julia hljs">VirtualDoubleNode(_::Type{Sparse}) -&gt; Symbol
</code></pre><p>Create a symbol representing a virtual double node for a sparse tensor layout.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{Sparse}</code>: The <code>Sparse</code> tensor layout type.</li></ul><p><strong>Returns</strong></p><ul><li><code>Symbol</code>: A symbol representing the virtual double node.</li></ul><p><strong>Description</strong></p><p>The <code>VirtualDoubleNode</code> function generates a symbol (<code>:virtual_double_node</code>) that represents a virtual double node in the context of a sparse tensor layout. This symbol is often used to indicate the presence of a virtual double node when working with certain tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.fuse_projectors" href="#SpinGlassEngine.fuse_projectors"><code>SpinGlassEngine.fuse_projectors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fuse_projectors(
    projectors::NTuple{N, K}
) -&gt; Tuple{Any, Tuple}
</code></pre><p>Fuse a tuple of projector matrices into a single projector matrix using rank-revealing techniques.</p><p><strong>Arguments</strong></p><ul><li><code>projectors::NTuple{N, K}</code>: Tuple of projector matrices to be fused.</li></ul><p><strong>Returns</strong></p><ul><li><code>fused::Matrix{Float64}</code>: Fused projector matrix.</li><li><code>transitions::NTuple{N, Vector{Int}}</code>: Tuple of transition vectors indicating the indices of the non-zero rows in each original projector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/PEPS.jl#L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.local_spins" href="#SpinGlassEngine.local_spins"><code>SpinGlassEngine.local_spins</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_spins(
    network::AbstractGibbsNetwork{S, T},
    vertex
) -&gt; Any
</code></pre><p>Retrieve the local spin configurations associated with a vertex in the Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>network::AbstractGibbsNetwork{S, T}</code>: The Gibbs network.</li><li><code>vertex::S</code>: The vertex for which local spins are requested.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: An array representing the local spin configurations.</li></ul><p><strong>Description</strong></p><p>This function retrieves the local spin configurations associated with a given vertex in the Gibbs network. The local spins are extracted from the spectrum of the Potts Hamiltonian associated with the vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.tensor" href="#SpinGlassEngine.tensor"><code>SpinGlassEngine.tensor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensor(
    net::PEPSNetwork{T&lt;:AbstractGeometry, Sparse},
    node::PEPSNode,
    β::Real,
    _::Val{:central_d_double_node}
) -&gt; DiagonalTensor{_A, 2} where _A&lt;:Real
</code></pre><p>Generate the tensor for a central double node in a projected entangled pair states (PEPS) tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{T, Sparse}</code>: PEPS tensor network.</li><li><code>node::PEPSNode</code>: Node representing the position of the central double node.</li><li><code>β::Real</code>: Inverse temperature parameter.</li><li><code>::Val{:central_d_double_node}</code>: symbol to indicate the central double node.</li></ul><p><strong>Returns</strong></p><ul><li><code>DiagonalTensor</code>: Tensor representing the central double node.</li></ul><p><strong>Description</strong></p><p>The <code>tensor</code> function generates the tensor for a central double node in a PEPS tensor network. It uses the inverse temperature parameter <code>β</code> to construct the central tensor based on the geometry of the tensor network. The function is specialized for PEPS tensor networks with sparse tensors (<code>Sparse</code>) and is parametrized by the abstract geometry type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L725">source</a></section><section><div><pre><code class="language-julia hljs">tensor(
    net::PEPSNetwork{SquareCrossDoubleNode{T&lt;:AbstractTensorsLayout}, S&lt;:Union{Dense, Sparse}},
    node::PEPSNode,
    β::Real,
    _::Val{:sparse_virtual_double_node}
) -&gt; VirtualTensor{_A, 4} where _A&lt;:Real
</code></pre><p>Create a sparse virtual double node tensor in a projected entangled pair states (PEPS) tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{SquareCrossDoubleNode{T}, S}</code>: PEPS tensor network with square cross double nodes.</li><li><code>node::PEPSNode</code>: Node representing the position of the virtual double node.</li><li><code>β::Real</code>: Inverse temperature parameter.</li><li><code>::Val{:sparse_virtual_double_node}</code>: symbol to indicate the creation of a sparse virtual double node tensor.</li></ul><p><strong>Returns</strong></p><ul><li><code>VirtualTensor{T, S}</code>: Sparse virtual double node tensor.</li></ul><p><strong>Description</strong></p><p>The <code>tensor</code> function is used to create a sparse virtual double node tensor in a PEPS tensor network. It constructs the tensor by incorporating information about the central tensor and surrounding projectors associated with the specified position. The function is parametrized by the abstract tensors layout type <code>T</code>, and the abstract sparsity type <code>S</code>, which can be either <code>Sparse</code> or <code>Dense</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L783">source</a></section><section><div><pre><code class="language-julia hljs">tensor(
    net::PEPSNetwork{T&lt;:AbstractGeometry, Dense},
    node::PEPSNode,
    β::Real,
    _::Val{:virtual_double_node}
) -&gt; Any
</code></pre><p>Create a dense virtual double node tensor in a projected entangled pair states (PEPS) tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>net::PEPSNetwork{T, Dense}</code>: PEPS tensor network with nodes of type <code>T</code> and dense tensors.</li><li><code>node::PEPSNode</code>: Node representing the position of the virtual double node.</li><li><code>β::Real</code>: Inverse temperature parameter.</li><li><code>::Val{:virtual_double_node}</code>: symbol to indicate the creation of a dense virtual double node tensor.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tensor{T}</code>: Dense virtual double node tensor.</li></ul><p><strong>Description</strong></p><p>The <code>tensor</code> function is used to create a dense virtual double node tensor in a PEPS tensor network. It constructs the tensor by combining information from the sparse virtual double node tensor, including projectors and the dense central tensor associated with the specified position. The function is parametrized by the abstract geometry type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L840">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.branch_states" href="#SpinGlassEngine.branch_states"><code>SpinGlassEngine.branch_states</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_states(
    local_basis::Vector{Int64},
    vec_states::Vector{Vector{Int64}}
) -&gt; Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}
</code></pre><p>Constructs branch states based on a local basis and vectorized states.</p><p><strong>Arguments</strong></p><ul><li><code>local_basis::Vector{Int}</code>: The local basis states.</li><li><code>vec_states::Vector{Vector{Int}}</code>: Vectorized states for each branch.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Int}}</code>: A vector containing the constructed branch states.</li></ul><p><strong>Description</strong></p><p>This function constructs branch states by combining a local basis with vectorized states. The local basis provides the unique states for each branch, and the vectorized states represent the state configuration for each branch. The resulting vector contains the constructed branch states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/search.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassEngine.precompute_conditional" href="#SpinGlassEngine.precompute_conditional"><code>SpinGlassEngine.precompute_conditional</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precompute_conditional(
    266::Type{T&lt;:SquareCrossDoubleNode},
    ctr::MpsContractor{S},
    current_node
) -&gt; Any
</code></pre><p>Precompute conditional probabilities and energies for a square cross double node tensor contraction.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Type representing a square cross double node tensor network.</li><li><code>ctr::MpsContractor{S}</code>: Tensor contractor for the tensor network.</li><li><code>current_node</code>: Current node position in the tensor network.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple: A tuple containing precomputed conditional probabilities and energies.</li></ul><p><strong>Description</strong></p><p>The <code>precompute_conditional</code> function computes and returns precomputed conditional probabilities and energies for the specified square cross double node tensor contraction. It takes into account the geometry of the tensor network, interaction energies, and projectors. The precomputed values are used during the tensor contraction process to speed up the computation. The function is specialized for the <code>SquareCrossDoubleNode</code> tensor network type and is parametrized by the layout type <code>S</code> of the contractor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.6.0/src/square_cross_double_node.jl#L219">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 24 January 2025 12:27">Friday 24 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
