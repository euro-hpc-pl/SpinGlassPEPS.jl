<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference for auxiliary functions · SpinGlassPEPS.jl</title><meta name="title" content="API Reference for auxiliary functions · SpinGlassPEPS.jl"/><meta property="og:title" content="API Reference for auxiliary functions · SpinGlassPEPS.jl"/><meta property="twitter:title" content="API Reference for auxiliary functions · SpinGlassPEPS.jl"/><meta name="description" content="Documentation for SpinGlassPEPS.jl."/><meta property="og:description" content="Documentation for SpinGlassPEPS.jl."/><meta property="twitter:description" content="Documentation for SpinGlassPEPS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpinGlassPEPS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Getting started</a></li><li><a class="tocitem" href="../../algorithm/">Brief description of the algorithm</a></li><li><span class="tocitem">SpinGlassNetworks</span><ul><li><a class="tocitem" href="../userguide/">User guide</a></li><li><a class="tocitem" href="../ising/">Ising graph</a></li><li><a class="tocitem" href="../lattice/">Lattice geometries</a></li><li><a class="tocitem" href="../clh/">Clustered hamiltonian</a></li><li><a class="tocitem" href="../bp/">Local dimensional reduction</a></li><li class="is-active"><a class="tocitem" href>API Reference for auxiliary functions</a><ul class="internal"><li><a class="tocitem" href="#Ising-Graphs"><span>Ising Graphs</span></a></li><li><a class="tocitem" href="#Clustered-Hamiltonian"><span>Clustered Hamiltonian</span></a></li><li><a class="tocitem" href="#Belief-propagation"><span>Belief propagation</span></a></li><li><a class="tocitem" href="#Projectors"><span>Projectors</span></a></li><li><a class="tocitem" href="#Spectrum"><span>Spectrum</span></a></li><li><a class="tocitem" href="#Truncate"><span>Truncate</span></a></li><li><a class="tocitem" href="#Auxiliary-Functions"><span>Auxiliary Functions</span></a></li></ul></li></ul></li><li><span class="tocitem">SpinGlassEngine</span><ul><li><a class="tocitem" href="../../sge/guide/">User Guide</a></li><li><a class="tocitem" href="../../sge/peps/">Tensor network</a></li><li><a class="tocitem" href="../../sge/params/">Search parameters</a></li><li><a class="tocitem" href="../../sge/search/">Low energy spectrum</a></li><li><a class="tocitem" href="../../sge/api/">API Reference for auxiliary functions</a></li></ul></li><li><span class="tocitem">SpinGlassTensors</span><ul><li><a class="tocitem" href="../../sgt/">User guide</a></li><li><a class="tocitem" href="../../sgt/mpo/">Matrix Product States and Matrix Product Operations</a></li><li><a class="tocitem" href="../../sgt/api/">API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SpinGlassNetworks</a></li><li class="is-active"><a href>API Reference for auxiliary functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference for auxiliary functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl/blob/master/docs/src/sgn/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Ising-Graphs"><a class="docs-heading-anchor" href="#Ising-Graphs">Ising Graphs</a><a id="Ising-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Ising-Graphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.inter_cluster_edges" href="#SpinGlassNetworks.inter_cluster_edges"><code>SpinGlassNetworks.inter_cluster_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inter_cluster_edges(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},
    cl1::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},
    cl2::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}}
) -&gt; Tuple{Vector, Union{Array{Float64, 3}, Matrix}}
</code></pre><p>Return the dense adjacency matrix between clusters of vertices in an Ising graph.</p><p>This function computes and returns the dense adjacency matrix <code>J</code> between clusters of vertices represented by two Ising graphs, <code>cl1</code> and <code>cl2</code>, within the context of the larger Ising graph <code>ig</code>. The adjacency matrix represents the interaction strengths between clusters of vertices, where each element <code>(i, j)</code> corresponds to the interaction strength between cluster <code>i</code> in <code>cl1</code> and cluster <code>j</code> in <code>cl2</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>ig::IsingGraph{T}</code>: The Ising graph representing a system of spins with associated interaction strengths.</li><li><code>cl1::IsingGraph{T}</code>: The first Ising graph representing one cluster of vertices.</li><li><code>cl2::IsingGraph{T}</code>: The second Ising graph representing another cluster of vertices.</li></ul><p><strong>Returns:</strong></p><ul><li><code>outer_edges::Vector{LabelledEdge}</code>: A vector of labeled edges representing the interactions between clusters.</li><li><code>J::Matrix{T}</code>: A dense adjacency matrix representing interaction strengths between clusters.</li></ul><p>The function first identifies the outer edges that connect vertices between the two clusters in the context of the larger Ising graph <code>ig</code>. It then computes the interaction strengths associated with these outer edges and populates the dense adjacency matrix <code>J</code> accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/ising.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.prune" href="#SpinGlassNetworks.prune"><code>SpinGlassNetworks.prune</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prune(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}} where T;
    atol
) -&gt; LabelledGraphs.LabelledGraph
</code></pre><p>Used only in MPS<em>search, would be obsolete if MPS</em>search uses QMps. Remove non-existing spins from an Ising graph.</p><p>This function removes non-existing spins from the given Ising graph <code>ig</code>. Non-existing spins are those that have zero degree (no connections to other spins) and also have an external magnetic field (<code>h</code>) that is not approximately equal to zero within the specified tolerance <code>atol</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>ig::IsingGraph</code>: The Ising graph to be pruned.</li><li><code>atol::Real</code>: The tolerance for considering the external magnetic field as zero. The default value is <code>1e-14</code>.</li></ul><p><strong>Returns:</strong></p><ul><li><code>pruned_graph::IsingGraph</code>: A new Ising graph with non-existing spins removed.</li></ul><p>The function returns a pruned version of the input Ising graph, where non-existing spins and their associated properties are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/ising.jl#L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.couplings" href="#SpinGlassNetworks.couplings"><code>SpinGlassNetworks.couplings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">couplings(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}}
) -&gt; Union{Array{Float64, 3}, Matrix}
</code></pre><p>Return the coupling strengths between vertices of an Ising graph.</p><p>This function computes and returns the coupling strengths (interaction energies) between pairs of vertices in an Ising graph <code>ig</code>. The coupling strengths are represented as a matrix, where each element <code>(i, j)</code> corresponds to the interaction energy between vertex <code>i</code> and vertex <code>j</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>ig::IsingGraph{T}</code>: The Ising graph representing a system of spins with associated interaction strengths.</li></ul><p><strong>Returns:</strong></p><ul><li><code>J::Matrix{T}</code>: A matrix of coupling strengths between vertices of the Ising graph.</li></ul><p>The function iterates over the edges of the Ising graph and extracts the interaction strengths associated with each edge, populating the <code>J</code> matrix accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/ising.jl#L83">source</a></section></article><h2 id="Clustered-Hamiltonian"><a class="docs-heading-anchor" href="#Clustered-Hamiltonian">Clustered Hamiltonian</a><a id="Clustered-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Clustered-Hamiltonian" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.split_into_clusters" href="#SpinGlassNetworks.split_into_clusters"><code>SpinGlassNetworks.split_into_clusters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_into_clusters(
    ig::LabelledGraphs.LabelledGraph{G, L},
    assignment_rule
) -&gt; Dict
</code></pre><p>Group spins into clusters based on an assignment rule, mapping clustered Hamiltonian coordinates to groups of spins in the Ising graph. Dict(clustered Hamiltonian coordinates -&gt; group of spins in Ising graph)</p><p><strong>Arguments:</strong></p><ul><li><code>ig::LabelledGraph{G, L}</code>: The Ising graph represented as a labeled graph.</li><li><code>assignment_rule</code>: A mapping that assigns Ising graph vertices to clusters based on clustered Hamiltonian coordinates.</li></ul><p><strong>Returns:</strong></p><ul><li><code>clusters::Dict{L, Vertex}</code>: A dictionary mapping cluster identifiers to representative vertices in the Ising graph.</li></ul><p>This function groups spins in the Ising graph into clusters based on an assignment rule.  The assignment rule defines how clustered Hamiltonian coordinates correspond to clusters of spins in the Ising graph.  Each cluster is represented by a vertex from the Ising graph.</p><p>The <code>split_into_clusters</code> function is useful for organizing and analyzing spins in complex spin systems, particularly in the context of clustered Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.decode_clustered_hamiltonian_state" href="#SpinGlassNetworks.decode_clustered_hamiltonian_state"><code>SpinGlassNetworks.decode_clustered_hamiltonian_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decode_clustered_hamiltonian_state(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    state::Vector{Int64}
) -&gt; Dict{Int64, Int64}
</code></pre><p>TODO: check the order consistency over external packages.</p><p>Decode a clustered Hamiltonian state into Ising graph spin values.</p><p>This function decodes a state from a clustered Hamiltonian into Ising graph spin values and  returns a dictionary mapping each Ising graph vertex to its corresponding spin value.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>state::Vector{Int}</code>: The state to be decoded, represented as an array of state indices for each vertex in the clustered Hamiltonian.</li></ul><p><strong>Returns:</strong></p><ul><li><code>spin_values::Dict{Int, Int}</code>: A dictionary mapping each Ising graph vertex to its corresponding spin value.</li></ul><p>This function assumes that the state has the same order as the vertices in the clustered Hamiltonian.  It decodes the state consistently based on the cluster assignments and spectra of the clustered Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassTensors.rank_reveal" href="#SpinGlassTensors.rank_reveal"><code>SpinGlassTensors.rank_reveal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rank_reveal(energy) -&gt; Tuple{Any, Any}
rank_reveal(energy, order) -&gt; Tuple{Any, Any}
</code></pre><p>Reveal ranks and energies in a specified order.</p><p>This function calculates and reveals the ranks and energies of a set of states in either the &#39;PE&#39; (Projector Energy) or &#39;EP&#39; (Energy Projector) order.</p><p><strong>Arguments:</strong></p><ul><li><code>energy</code>: The energy values of states.</li><li><code>order::Symbol</code>: The order in which to reveal the ranks and energies. </li></ul><p>It can be either <code>:PE</code> for &#39;Projector Energy)&#39; order (default) or <code>:EP</code> for &#39;Energy Projector&#39; order.</p><p><strong>Returns:</strong></p><ul><li>If <code>order</code> is <code>:PE</code>, the function returns a tuple <code>(P, E)</code> where:<ul><li><code>P</code>: A permutation matrix representing projectors.</li><li><code>E</code>: An array of energy values.</li></ul></li><li>If <code>order</code> is <code>:EP</code>, the function returns a tuple <code>(E, P)</code> where:<ul><li><code>E</code>: An array of energy values.</li><li><code>P</code>: A permutation matrix representing projectors.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassTensors.jl/blob/v1.1.1/src/utils/utils.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.energy" href="#SpinGlassNetworks.energy"><code>SpinGlassNetworks.energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energy(σ::Vector, ig::IsingGraph)</code></pre><p>Calculates the energy of a state in an Ising graph.</p><p>This function calculates the energy of a given state in the context of an Ising graph.  The energy is computed based on the interactions between spins and their associated biases.</p><p><strong>Arguments:</strong></p><ul><li><code>σ::AbstractArray{State}</code>: An array representing the state of spins in the Ising graph.</li><li><code>ig::IsingGraph</code>: The Ising graph defining the interactions and biases.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Vector{Float64}</code>: An array of energy values for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/spectrum.jl#L76-L90">source</a></section><section><div><pre><code class="language-julia hljs">energy(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},
    ig_state::Dict{Int64, Int64}
) -&gt; Any
</code></pre><p>Calculates the energy of a state in an Ising graph.</p><p>This function computes the energy of a given state in the context of an Ising graph.  The energy is calculated based on the interactions between spins and their associated biases.</p><p><strong>Arguments:</strong></p><ul><li><code>ig::IsingGraph{T}</code>: The Ising graph defining the interactions and biases.</li><li><code>ig_state::Dict{Int, Int}</code>: A dictionary mapping spin indices to their corresponding states.</li></ul><p><strong>Returns:</strong></p><ul><li><code>T</code>: The energy of the state in the Ising graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/spectrum.jl#L96">source</a></section><section><div><pre><code class="language-julia hljs">energy(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    σ::Dict{T, Int64}
) -&gt; Any
</code></pre><p>Calculate the energy of a clustered Hamiltonian state.</p><p>This function calculates the energy of a given state in a clustered Hamiltonian.  The state is represented as a dictionary mapping each Ising graph vertex to its corresponding spin value.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>σ::Dict{T, Int}</code>: A dictionary mapping Ising graph vertices to their spin values.</li></ul><p><strong>Returns:</strong></p><ul><li><code>en_cl_h::Float64</code>: The energy of the state in the clustered Hamiltonian.</li></ul><p>This function computes the energy by summing the energies associated with individual  clusters and the interaction energies between clusters.  It takes into account the cluster spectra and projectors stored in the clustered Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.energy_2site" href="#SpinGlassNetworks.energy_2site"><code>SpinGlassNetworks.energy_2site</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energy_2site(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    i::Int64,
    j::Int64
) -&gt; Any
</code></pre><p>Calculate the interaction energy between two nodes in a clustered Hamiltonian.</p><p>This function computes the interaction energy between two specified nodes in a clustered Hamiltonian, represented as a labeled graph.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>i::Int</code>: The index of the first site.</li><li><code>j::Int</code>: The index of the second site.</li></ul><p><strong>Returns:</strong></p><ul><li><code>int_eng::AbstractMatrix{T}</code>: The interaction energy matrix between the specified sites.</li></ul><p>The function checks if there is an interaction edge between the two sites (i, j) in both directions (i -&gt; j and j -&gt; i).  If such edges exist, it retrieves the interaction energy matrix, projectors, and calculates the interaction energy.  If no interaction edge is found, it returns a zero matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.cluster_size" href="#SpinGlassNetworks.cluster_size"><code>SpinGlassNetworks.cluster_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cluster_size(net::AbstractGibbsNetwork{S, T}, v) -&gt; Any
</code></pre><p>Determine the cluster size associated with a specific vertex in the Gibbs network.</p><p><strong>Arguments</strong></p><ul><li><code>net::AbstractGibbsNetwork{S, T}</code>: Gibbs network containing the clustered Hamiltonian.</li><li><code>v::S</code>: Vertex for which the cluster size is to be determined.</li></ul><p><strong>Returns</strong></p><ul><li><code>size::Int</code>: Number of states in the local energy spectrum associated with the specified vertex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassEngine.jl/blob/v1.0.1/src/PEPS.jl#L239">source</a></section><section><div><pre><code class="language-julia hljs">cluster_size(
    clustered_hamiltonian::LabelledGraphs.LabelledGraph{S, T},
    vertex
) -&gt; Any
</code></pre><p>Get the size of a cluster in a clustered Hamiltonian.</p><p>This function returns the size (number of states) of a cluster in a clustered Hamiltonian, represented as a labeled graph.</p><p><strong>Arguments:</strong></p><ul><li><code>clustered_hamiltonian::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>vertex::T</code>: The vertex (cluster) for which the size is to be determined.</li></ul><p><strong>Returns:</strong></p><ul><li><code>size::Int</code>: The number of states in the specified cluster.</li></ul><p>The function retrieves the spectrum associated with the specified cluster and returns the length of the energy vector in that spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.bond_energy" href="#SpinGlassNetworks.bond_energy"><code>SpinGlassNetworks.bond_energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bond_energy(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    cl_h_u::Tuple{Vararg{Int64, N}},
    cl_h_v::Tuple{Vararg{Int64, N}},
    σ::Int64
) -&gt; Any
</code></pre><p>Calculate the bond energy between two clusters in a clustered Hamiltonian.</p><p>This function computes the bond energy between two specified clusters (cluster nodes) in a clustered Hamiltonian, represented as a labeled graph.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>cl_h_u::NTuple{N, Int64}</code>: The coordinates of the first cluster.</li><li><code>cl_h_v::NTuple{N, Int64}</code>: The coordinates of the second cluster.</li><li><code>σ::Int</code>: Index for which the bond energy is calculated.</li></ul><p><strong>Returns:</strong></p><ul><li><code>energies::AbstractVector{T}</code>: The bond energy vector between the two clusters for the specified index.</li></ul><p>The function checks if there is an edge between the two clusters (u -&gt; v and v -&gt; u).  If such edges exist, it retrieves the bond energy matrix and projectors and calculates the bond energy.  If no bond edge is found, it returns a zero vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.exact_cond_prob" href="#SpinGlassNetworks.exact_cond_prob"><code>SpinGlassNetworks.exact_cond_prob</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exact_cond_prob(
    clustered_hamiltonian::LabelledGraphs.LabelledGraph{S, T},
    beta,
    target_state::Dict
) -&gt; Any
</code></pre><p>Calculate the exact conditional probability of a target state in a clustered Hamiltonian.</p><p>This function computes the exact conditional probability of a specified target state in a clustered Hamiltonian, represented as a labelled graph.</p><p><strong>Arguments:</strong></p><ul><li><code>clustered_hamiltonian::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>beta</code>: The inverse temperature parameter.</li><li><code>target_state::Dict</code>: A dictionary specifying the target state as a mapping of cluster vertices to Ising spin values.</li></ul><p><strong>Returns:</strong></p><ul><li><code>prob::Float64</code>: The exact conditional probability of the target state.</li></ul><p>The function generates all possible states for the clusters in the clustered Hamiltonian,  calculates their energies, and computes the probability distribution based on the given inverse temperature parameter.  It then calculates the conditional probability of the specified target state by summing the probabilities of states that match the target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.truncate_clustered_hamiltonian" href="#SpinGlassNetworks.truncate_clustered_hamiltonian"><code>SpinGlassNetworks.truncate_clustered_hamiltonian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_clustered_hamiltonian(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    states::Dict
) -&gt; LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}
</code></pre><p>Truncate a clustered Hamiltonian based on specified states.</p><p>This function truncates a given clustered Hamiltonian by selecting a subset of states for each cluster based on the provided <code>states</code> dictionary.  The resulting truncated Hamiltonian contains only the selected states for each cluster.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>states::Dict</code>: A dictionary specifying the states to be retained for each cluster.</li></ul><p><strong>Returns:</strong></p><ul><li><code>new_cl_h::LabelledGraph{MetaDiGraph}</code>: The truncated clustered Hamiltonian with reduced states.</li></ul><p>The function creates a new clustered Hamiltonian <code>new_cl_h</code> with the same structure as the input <code>cl_h</code>.  It then updates the spectrum of each cluster in <code>new_cl_h</code> by selecting the specified states from the original spectrum.  Additionally, it updates the interactions and projectors between clusters based on the retained states.  The resulting <code>new_cl_h</code> represents a truncated version of the original Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/clustered_hamiltonian.jl#L418">source</a></section></article><h2 id="Belief-propagation"><a class="docs-heading-anchor" href="#Belief-propagation">Belief propagation</a><a id="Belief-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Belief-propagation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.local_energy" href="#SpinGlassNetworks.local_energy"><code>SpinGlassNetworks.local_energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_energy(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    v::Tuple{Int64, Int64, Int64}
) -&gt; Any
</code></pre><p>Get the local energy associated with a vertex in a clustered Hamiltonian.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>v::NTuple{3, Int64}</code>: The coordinates of the vertex for which the local energy is requested.</li></ul><p><strong>Returns:</strong></p><ul><li><code>local_energy::AbstractVector</code>: An abstract vector containing the local energy values associated with the specified vertex.</li></ul><p>This function retrieves the local energy values associated with a given vertex <code>v</code> in a clustered Hamiltonian graph <code>cl_h</code>.  If the vertex exists in the graph and has associated energy values, it returns those values; otherwise, it returns a vector of zeros.</p><p>The local energy values are typically obtained from the spectrum associated with the vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.interaction_energy" href="#SpinGlassNetworks.interaction_energy"><code>SpinGlassNetworks.interaction_energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interaction_energy(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    v::Tuple{Int64, Int64, Int64},
    w::Tuple{Int64, Int64, Int64}
) -&gt; Any
</code></pre><p>Get the interaction energy between two vertices in a clustered Hamiltonian.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>v::NTuple{3, Int64}</code>: The coordinates of the first vertex.</li><li><code>w::NTuple{3, Int64}</code>: The coordinates of the second vertex.</li></ul><p><strong>Returns:</strong></p><ul><li><code>interaction_energy::AbstractMatrix</code>: An abstract matrix containing the interaction energy values between the specified vertices.</li></ul><p>This function retrieves the interaction energy values between two vertices, <code>v</code> and <code>w</code>, in a clustered Hamiltonian graph <code>cl_h</code>.  If there is a directed edge from <code>w</code> to <code>v</code>, it returns the corresponding energy values;  if there is a directed edge from <code>v</code> to <code>w</code>, it returns the transpose of the energy values;  otherwise, it returns a matrix of zeros. The interaction energy values represent the energy associated with the interaction or connection between the two vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.get_neighbors" href="#SpinGlassNetworks.get_neighbors"><code>SpinGlassNetworks.get_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_neighbors(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    vertex::Tuple{Vararg{T, N}} where {N, T}
) -&gt; Vector{Any}
</code></pre><p>Returns the neighbors of a given vertex in a clustered Hamiltonian.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>vertex::NTuple</code>: The vertex for which neighbors are to be retrieved.</li></ul><p><strong>Returns:</strong></p><ul><li><code>neighbors::Vector{Tuple}</code>: A vector of tuples representing the neighbors of the specified vertex. </li></ul><p>Each tuple contains the following information:</p><ul><li><code>dst_node::T</code>: The neighboring vertex.</li><li><code>pv::Matrix</code>: The projector associated with the edge connecting the vertex and its neighbor.</li><li><code>en::Real</code>: The energy associated with the edge connecting the vertex and its neighbor.</li></ul><p>This function retrieves the neighbors of a given vertex in a clustered Hamiltonian graph. It iterates through the edges of the graph and identifies edges connected to the specified vertex.  For each neighboring edge, it extracts and returns the neighboring vertex, the associated projector, and the energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.MergedEnergy" href="#SpinGlassNetworks.MergedEnergy"><code>SpinGlassNetworks.MergedEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A custom Julia struct representing energy values in a merged format for use in specific calculations.</p><p><strong>Fields:</strong></p><ul><li><code>e11::AbstractMatrix{T}</code></li><li><code>e12::AbstractMatrix{T}</code></li><li><code>e21::AbstractMatrix{T}</code></li><li><code>e22::AbstractMatrix{T}</code></li></ul><p>The <code>MergedEnergy</code> struct is used to represent energy values that are organized in a merged format.  This format is often utilized in certain computational tasks, where energy values are categorized based on combinations of left and right factors.</p><p>Each field of the <code>MergedEnergy</code> struct stores energy values as an <code>AbstractMatrix{T}</code> of type <code>T</code>,  where <code>T</code> is a subtype of the <code>Real</code> abstract type.  The specific organization and interpretation of these energy values depend on the context in which this struct is used.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.update_message" href="#SpinGlassNetworks.update_message"><code>SpinGlassNetworks.update_message</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_message(
    E_bond::AbstractArray,
    message::Vector,
    beta::Real
) -&gt; Any
</code></pre><p>Update a message using energy values and temperature.</p><p><strong>Arguments:</strong></p><ul><li><code>E_bond::AbstractArray</code>: An array of energy values associated with a bond or interaction.</li><li><code>message::Vector</code>: The input message vector to be updated.</li><li><code>beta::Real</code>: The temperature parameter controlling the influence of energy values.</li></ul><p><strong>Returns:</strong></p><ul><li><code>updated_message::Vector</code>: The updated message vector after applying the energy-based update.</li></ul><p>This function takes energy values <code>E_bond</code> associated with a bond or interaction, an input message vector <code>message</code>,  and a temperature parameter <code>beta</code>. It updates the message by first adjusting the energy values relative to their minimum value,  exponentiating them with a negative sign and scaling by <code>beta</code>, and then multiplying them element-wise with the input message.</p><p>The result is an updated message that reflects the influence of energy values and temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L167">source</a></section><section><div><pre><code class="language-julia hljs">update_message(
    E_bond::MergedEnergy,
    message::Vector,
    beta::Real
) -&gt; Any
</code></pre><p>Update a message using energy values and temperature in a merged energy format.</p><p><strong>Arguments:</strong></p><ul><li><code>E_bond::MergedEnergy</code>: An instance of the <code>MergedEnergy</code> type representing energy values for the bond or interaction.</li><li><code>message::Vector</code>: The input message vector to be updated.</li><li><code>beta::Real</code>: The temperature parameter controlling the influence of energy values.</li></ul><p><strong>Returns:</strong></p><ul><li><code>updated_message::Vector</code>: The updated message vector after applying the energy-based update.</li></ul><p>This function takes energy values <code>E_bond</code> in a merged energy format, an input message vector <code>message</code>,  and a temperature parameter <code>beta</code>. It updates the message based on the energy values and temperature using a specified algorithm.</p><p>The <code>MergedEnergy</code> type represents energy values in a merged format, and the function processes these values  accordingly to update the message vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.merge_vertices_cl_h" href="#SpinGlassNetworks.merge_vertices_cl_h"><code>SpinGlassNetworks.merge_vertices_cl_h</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">merge_vertices_cl_h(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    β::Real,
    node1::Tuple{Int64, Int64, Int64},
    node2::Tuple{Int64, Int64, Int64}
) -&gt; Tuple{MergedEnergy, Any, Any}
</code></pre><p>Merge two vertices in a clustered Hamiltonian to create a single merged vertex.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>β::Real</code>: The temperature parameter controlling the influence of energy values.</li><li><code>node1::NTuple{3, Int64}</code>: The coordinates of the first vertex to merge.</li><li><code>node2::NTuple{3, Int64}</code>: The coordinates of the second vertex to merge.</li></ul><p><strong>Returns:</strong></p><ul><li><code>merged_energy::MergedEnergy</code>: An instance of the <code>MergedEnergy</code> type representing the merged energy values.</li><li><code>pl::AbstractVector</code>: The merged left projector.</li><li><code>pr::AbstractVector</code>: The merged right projector.</li></ul><p>This function merges two vertices in a clustered Hamiltonian graph <code>cl_h</code> to create a single merged vertex.  The merging process combines projectors and energy values associated with the original vertices based on  the provided temperature parameter <code>β</code>.</p><p>The merged energy values, left projector <code>pl</code>, and right projector <code>pr</code> are computed based on the interactions  between the original vertices and their respective projectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.projector" href="#SpinGlassNetworks.projector"><code>SpinGlassNetworks.projector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">projector(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    v::Tuple{Vararg{Int64, N}},
    w::Tuple{Vararg{Int64, N}}
) -&gt; Any
</code></pre><p>Get the projector associated with an edge between two vertices in a clustered Hamiltonian.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>v::NTuple{N, Int64}</code>: The coordinates of one of the two vertices connected by the edge.</li><li><code>w::NTuple{N, Int64}</code>: The coordinates of the other vertex connected by the edge.</li></ul><p><strong>Returns:</strong></p><ul><li><code>p::AbstractVector</code>: An abstract vector representing the projector associated with the specified edge.</li></ul><p>This function retrieves the projector associated with an edge between two vertices, <code>v</code> and <code>w</code>,  in a clustered Hamiltonian graph <code>cl_h</code>.  If there is a directed edge from <code>w</code> to <code>v</code>, it returns the index of right projector (<code>:ipr</code>);  if there is a directed edge from <code>v</code> to <code>w</code>, it returns the index of left projector (<code>:ipl</code>).  If no edge exists between the vertices, it returns a vector of ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.SparseCSC" href="#SpinGlassNetworks.SparseCSC"><code>SpinGlassNetworks.SparseCSC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SparseCSC(
    _::Type{R&lt;:Real},
    p::Vector{Int64}
) -&gt; SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv&lt;:Real
</code></pre><p>Create a sparse column-compressed (CSC) matrix with specified column indices and values.</p><p><strong>Arguments:</strong></p><ul><li><code>::Type{R}</code>: The element type of the sparse matrix (e.g., <code>Float64</code>, <code>Int64</code>).</li><li><code>p::Vector{Int64}</code>: A vector of column indices for the non-zero values.</li></ul><p><strong>Returns:</strong></p><ul><li><code>sparse_matrix::SparseMatrixCSC{R}</code>: A sparse column-compressed matrix with non-zero values at specified columns.</li></ul><p>This constructor function creates a sparse column-compressed (CSC) matrix of element type <code>R</code> based on the provided  column indices <code>p</code> and values. The resulting matrix has non-zero values at the specified column indices, while all other elements are zero. The <code>SparseCSC</code> constructor is useful for creating sparse matrices with specific column indices and values efficiently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/bp.jl#L485">source</a></section></article><h2 id="Projectors"><a class="docs-heading-anchor" href="#Projectors">Projectors</a><a id="Projectors-1"></a><a class="docs-heading-anchor-permalink" href="#Projectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassTensors.PoolOfProjectors" href="#SpinGlassTensors.PoolOfProjectors"><code>SpinGlassTensors.PoolOfProjectors</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PoolOfProjectors</code> is a data structure for managing projectors associated with Ising model sites.  It allows efficient storage and retrieval of projectors based on their indices and provides support for different computational devices.</p><p><strong>Fields:</strong></p><ul><li><code>data::Dict{Symbol, Dict{Int, Proj{T}}}</code>: A dictionary that stores projectors associated with different </li></ul><p>computational devices (<code>:CPU</code>, <code>:GPU</code>, etc.). The inner dictionary maps site indices to projectors.</p><ul><li><code>default_device::Symbol</code>: A symbol representing the default computational device for projectors in the pool.</li><li><code>sizes::Dict{Int, Int}</code>: A dictionary that maps site indices to the maximum projector size for each site.</li></ul><p><strong>Constructors:</strong></p><ul><li><code>PoolOfProjectors(data::Dict{Int, Dict{Int, Vector{T}}}) where T</code>: Create a <code>PoolOfProjectors</code> with initial data for projectors. </li></ul><p>The data is provided as a dictionary that maps site indices to projectors stored in different computational devices.  The <code>sizes</code> dictionary is automatically populated based on the maximum projector size for each site.</p><ul><li><code>PoolOfProjectors{T}() where T</code>: Create an empty <code>PoolOfProjectors</code> with no projectors initially stored.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassTensors.jl/blob/v1.1.1/src/projectors.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassTensors.get_projector!" href="#SpinGlassTensors.get_projector!"><code>SpinGlassTensors.get_projector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_projector!(
    lp::PoolOfProjectors{T&lt;:Integer},
    index::Int64,
    device::Symbol
) -&gt; Union{Vector{T}, CUDA.CuVector{T}, CUDA.DenseCuVector{T}} where T&lt;:Integer
</code></pre><p>TODO This is version for only one GPU</p><p>Retrieve or create a projector from the <code>PoolOfProjectors</code> associated with a specific device.</p><p>This function retrieves a projector from the <code>PoolOfProjectors</code> if it already exists.  If the projector does not exist in the pool, it creates a new one and stores it for future use on the specified computational device.</p><p><strong>Arguments:</strong></p><ul><li><code>lp::PoolOfProjectors{T}</code>: The <code>PoolOfProjectors</code> object containing projectors.</li><li><code>index::Int</code>: The index of the projector to retrieve or create.</li><li><code>device::Symbol</code>: The computational device on which the projector should be stored or retrieved (e.g., <code>:CPU</code>, <code>:GPU</code>).</li></ul><p><strong>Returns:</strong></p><ul><li><code>Proj{T}</code>: The projector of type <code>T</code> associated with the specified index and device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassTensors.jl/blob/v1.1.1/src/projectors.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassTensors.add_projector!" href="#SpinGlassTensors.add_projector!"><code>SpinGlassTensors.add_projector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_projector!(
    lp::PoolOfProjectors{T&lt;:Integer},
    p::Union{Vector{T}, CUDA.CuArray{T, 1}} where T
) -&gt; Int64
</code></pre><p>Add a projector to the <code>PoolOfProjectors</code> and associate it with an index.</p><p>This function adds a projector <code>p</code> to the <code>PoolOfProjectors</code>.  The <code>PoolOfProjectors</code> stores projectors based on their computational device (e.g., CPU or GPU) and assigns a unique index to each projector.  The index can be used to retrieve the projector later using <code>get_projector!</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>lp::PoolOfProjectors{T}</code>: The <code>PoolOfProjectors</code> object to which the projector should be added.</li><li><code>p::Proj</code>: The projector to be added to the pool. The type of the projector <code>Proj</code> should match the type <code>T</code> specified in the <code>PoolOfProjectors</code>.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Int</code>: The unique index associated with the added projector in the pool.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassTensors.jl/blob/v1.1.1/src/projectors.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!(
    lp::PoolOfProjectors,
    device::Symbol
) -&gt; Union{Nothing, Dict{Int64, Union{Vector{T}, CUDA.CuVector{T}, CUDA.DenseCuVector{T}}} where T&lt;:Integer}
</code></pre><p>Empty the pool of projectors associated with a specific computational device.</p><p>This function removes all projectors stored on the specified computational device, freeing up memory resources.</p><p><strong>Arguments:</strong></p><ul><li><code>lp::PoolOfProjectors</code>: The <code>PoolOfProjectors</code> object containing projectors.</li><li><code>device::Symbol</code>: The computational device for which projectors should be emptied (e.g., <code>:CPU</code>, <code>:GPU</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassTensors.jl/blob/v1.1.1/src/projectors.jl#L39">source</a></section></article><h2 id="Spectrum"><a class="docs-heading-anchor" href="#Spectrum">Spectrum</a><a id="Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.Spectrum" href="#SpinGlassNetworks.Spectrum"><code>SpinGlassNetworks.Spectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Spectrum</code> represents the energy spectrum of a system.</p><p>A <code>Spectrum</code> consists of energy levels, their corresponding states, and integer representations of the states.</p><p><strong>Fields:</strong></p><ul><li><code>energies::Vector{&lt;:Real}</code>: An array of energy levels.</li><li><code>states::AbstractArray{State}</code>: An array of states.</li><li><code>states_int::Vector{Int}</code>: An array of integer representations of states.</li></ul><p><strong>Constructors:</strong></p><ul><li><code>Spectrum(energies, states, states_int)</code>: Creates a <code>Spectrum</code> object with the specified energy levels, states, and integer representations.</li><li><code>Spectrum(energies, states)</code>: Creates a <code>Spectrum</code> object with the specified energy levels and states, automatically generating integer representations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/spectrum.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.matrix_to_integers" href="#SpinGlassNetworks.matrix_to_integers"><code>SpinGlassNetworks.matrix_to_integers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_to_integers(
    matrix::Vector{&lt;:Vector{&lt;:Integer}}
) -&gt; Any
</code></pre><p>Converts a matrix of binary vectors to their integer representations.</p><p>This function takes a matrix of binary vectors, where each row represents a binary vector, and converts them into their corresponding integer representations.</p><p><strong>Arguments:</strong></p><ul><li><code>matrix::Vector{Vector{T}}</code>: A matrix of binary vectors.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Vector{Int}</code>: An array of integer representations of the binary vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/spectrum.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.gibbs_tensor" href="#SpinGlassNetworks.gibbs_tensor"><code>SpinGlassNetworks.gibbs_tensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gibbs_tensor(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}}
) -&gt; Any
gibbs_tensor(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},
    β
) -&gt; Any
</code></pre><p>Computes the Gibbs tensor for an Ising graph at a given inverse temperature.</p><p>This function calculates the Gibbs tensor for an Ising graph at a specified inverse temperature (β).  The Gibbs tensor represents the conditional probabilities of states given the inverse temperature and the Ising graph.</p><p><strong>Arguments:</strong></p><ul><li><code>ig::IsingGraph{T}</code>: The Ising graph for which the Gibbs tensor is computed.</li><li><code>β::T (optional)</code>: The inverse temperature parameter. Default is 1.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Matrix{T}</code>: A matrix representing the Gibbs tensor with conditional probabilities.    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/spectrum.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.brute_force" href="#SpinGlassNetworks.brute_force"><code>SpinGlassNetworks.brute_force</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brute_force(
    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},
    ::Val{:CPU};
    num_states
) -&gt; Spectrum
</code></pre><p>TODO only one of brute<em>force and full</em>spectrum should remain</p><p>Performs brute-force calculation of the lowest-energy states and their energies for an Ising graph.</p><p>This function exhaustively computes the lowest-energy states and their corresponding energies for an Ising graph. The calculation is done using brute-force enumeration, making it feasible only for small Ising graphs.</p><p><strong>Arguments:</strong></p><ul><li><code>ig::IsingGraph{T}</code>: The Ising graph for which the lowest-energy states are computed.</li><li><code>::Val{:CPU}</code>: A value indicating that the computation is performed on the CPU.</li><li><code>num_states::Int (optional)</code>: The maximum number of lowest-energy states to calculate. Default is 1.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Spectrum</code>: A <code>Spectrum</code> object containing the lowest-energy states and their energies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/spectrum.jl#L180">source</a></section></article><h2 id="Truncate"><a class="docs-heading-anchor" href="#Truncate">Truncate</a><a id="Truncate-1"></a><a class="docs-heading-anchor-permalink" href="#Truncate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.truncate_clustered_hamiltonian_1site_BP" href="#SpinGlassNetworks.truncate_clustered_hamiltonian_1site_BP"><code>SpinGlassNetworks.truncate_clustered_hamiltonian_1site_BP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_clustered_hamiltonian_1site_BP(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    num_states::Int64;
    beta,
    tol,
    iter
) -&gt; LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}
</code></pre><p>Truncates a clustered Hamiltonian using belief propagation (BP) for a single site cluster.</p><p>This function employs belief propagation (BP) to approximate the most probable states and energies for a clustered Hamiltonian associated with a single-site cluster. It then truncates the clustered Hamiltonian based on the most probable states.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>num_states::Int</code>: The maximum number of most probable states to keep.</li><li><code>beta::Real (optional)</code>: The inverse temperature parameter for the BP algorithm. Default is 1.0.</li><li><code>tol::Real (optional)</code>: The tolerance value for convergence in BP. Default is 1e-10.</li><li><code>iter::Int (optional)</code>: The maximum number of BP iterations. Default is 1.</li></ul><p><strong>Returns:</strong></p><ul><li><code>LabelledGraph{S, T}</code>: A truncated clustered Hamiltonian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/truncate.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.truncate_clustered_hamiltonian_2site_energy" href="#SpinGlassNetworks.truncate_clustered_hamiltonian_2site_energy"><code>SpinGlassNetworks.truncate_clustered_hamiltonian_2site_energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_clustered_hamiltonian_2site_energy(
    cl_h::LabelledGraphs.LabelledGraph{S, T},
    num_states::Int64
) -&gt; LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}
</code></pre><p>Truncate a clustered Hamiltonian based on 2-site energy states.</p><p>This function truncates a clustered Hamiltonian by considering 2-site energy states and selecting the most probable states  to keep. It computes the energies for all 2-site combinations and selects the states that maximize the probability.</p><p><strong>Arguments:</strong></p><ul><li><code>cl_h::LabelledGraph{S, T}</code>: The clustered Hamiltonian represented as a labeled graph.</li><li><code>num_states::Int</code>: The maximum number of most probable states to keep.</li></ul><p><strong>Returns:</strong></p><ul><li><code>LabelledGraph{S, T}</code>: A truncated clustered Hamiltonian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/truncate.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.select_numstate_best" href="#SpinGlassNetworks.select_numstate_best"><code>SpinGlassNetworks.select_numstate_best</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_numstate_best(E, sx, num_states) -&gt; Tuple{Any, Any}
</code></pre><p>Select a specified number of best states based on energy.</p><p>This function selects a specified number of best states from a list of energies based on energy values in two nodes of clustered hamiltonian.  It fine-tunes the selection to ensure that the resulting states have the expected number.</p><p><strong>Arguments:</strong></p><ul><li><code>E::Vector{Real}</code>: A vector of energy values.</li><li><code>sx::Int</code>: The size of the clustered Hamiltonian for one of the nodes.</li><li><code>num_states::Int</code>: The desired number of states to select.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Tuple{Vector{Int}, Vector{Int}}</code>: A tuple containing two vectors of indices, <code>ind1</code> and <code>ind2</code>, </li></ul><p>which represent the selected states for two nodes of a clustered Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/truncate.jl#L136">source</a></section></article><h2 id="Auxiliary-Functions"><a class="docs-heading-anchor" href="#Auxiliary-Functions">Auxiliary Functions</a><a id="Auxiliary-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.zephyr_to_linear" href="#SpinGlassNetworks.zephyr_to_linear"><code>SpinGlassNetworks.zephyr_to_linear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zephyr_to_linear(
    m::Int64,
    t::Int64,
    q::NTuple{5, Int64}
) -&gt; Int64
</code></pre><p>Rewriten from Dwave-networkx m - Grid parameter for the Zephyr lattice. t - Tile parameter for the Zephyr lattice; must be even.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/utils.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.load_openGM" href="#SpinGlassNetworks.load_openGM"><code>SpinGlassNetworks.load_openGM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_openGM(fname::String) -&gt; Dict
load_openGM(
    fname::String,
    Nx::Union{Nothing, Integer}
) -&gt; Dict
load_openGM(
    fname::String,
    Nx::Union{Nothing, Integer},
    Ny::Union{Nothing, Integer}
) -&gt; Dict
</code></pre><p>Loads some factored graphs written in openGM format. Assumes rectangular lattice.</p><p>Args:     file<em>name (str): a path to file with factor graph in openGM format.     ints Nx, Ny: it is assumed that graph if forming an :math:N</em>x 	imes N_y lattice with         nearest-neighbour interactions only.</p><p>Returns:    dictionary with factors and funcitons defining the energy functional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/utils.jl#L92">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bp/">« Local dimensional reduction</a><a class="docs-footer-nextpage" href="../../sge/guide/">User Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 2 May 2024 19:16">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
