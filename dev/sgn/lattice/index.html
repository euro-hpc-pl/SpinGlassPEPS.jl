<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lattice geometries · SpinGlassPEPS.jl</title><meta name="title" content="Lattice geometries · SpinGlassPEPS.jl"/><meta property="og:title" content="Lattice geometries · SpinGlassPEPS.jl"/><meta property="twitter:title" content="Lattice geometries · SpinGlassPEPS.jl"/><meta name="description" content="Documentation for SpinGlassPEPS.jl."/><meta property="og:description" content="Documentation for SpinGlassPEPS.jl."/><meta property="twitter:description" content="Documentation for SpinGlassPEPS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpinGlassPEPS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Getting started</a></li><li><a class="tocitem" href="../../algorithm/">Brief description of the algorithm</a></li><li><span class="tocitem">SpinGlassNetworks</span><ul><li><a class="tocitem" href="../userguide/">User guide</a></li><li><a class="tocitem" href="../ising/">Ising graph</a></li><li class="is-active"><a class="tocitem" href>Lattice geometries</a><ul class="internal"><li><a class="tocitem" href="#Super-square-lattice"><span>Super square lattice</span></a></li><li><a class="tocitem" href="#Pegasus-graphs"><span>Pegasus graphs</span></a></li><li><a class="tocitem" href="#Zephyr-graphs"><span>Zephyr graphs</span></a></li></ul></li><li><a class="tocitem" href="../clh/">Clustered hamiltonian</a></li><li><a class="tocitem" href="../bp/">Local dimensional reduction</a></li><li><a class="tocitem" href="../api/">API Reference for auxiliary functions</a></li></ul></li><li><span class="tocitem">SpinGlassEngine</span><ul><li><a class="tocitem" href="../../sge/guide/">User Guide</a></li><li><a class="tocitem" href="../../sge/peps/">Tensor network</a></li><li><a class="tocitem" href="../../sge/params/">Search parameters</a></li><li><a class="tocitem" href="../../sge/search/">Low energy spectrum</a></li><li><a class="tocitem" href="../../sge/api/">API Reference for auxiliary functions</a></li></ul></li><li><span class="tocitem">SpinGlassTensors</span><ul><li><a class="tocitem" href="../../sgt/">User guide</a></li><li><a class="tocitem" href="../../sgt/mpo/">Matrix Product States and Matrix Product Operations</a></li><li><a class="tocitem" href="../../sgt/api/">API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SpinGlassNetworks</a></li><li class="is-active"><a href>Lattice geometries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lattice geometries</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl/blob/master/docs/src/sgn/lattice.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattice-geometries"><a class="docs-heading-anchor" href="#Lattice-geometries">Lattice geometries</a><a id="Lattice-geometries-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-geometries" title="Permalink"></a></h1><p>The Ising graph allowed for loading instances directly from a file and translating them into a graph. The next step towards constructing the tensor network is to build a lattice, based on which we will transform the Ising graph into a clustered Hamiltonian. Within the <code>SpinGlassNetworks.jl</code> package, users have the flexibility to construct three types of lattice geometries, each tailored to specific needs. </p><h2 id="Super-square-lattice"><a class="docs-heading-anchor" href="#Super-square-lattice">Super square lattice</a><a id="Super-square-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Super-square-lattice" title="Permalink"></a></h2><p>The <code>super_square_lattice</code> geometry represents a square lattice with nearest neighbors interactions (horizontal and vertical interactions between unit cells) and next nearest neighbor interactions (diagonal interactions). Unit cells depicted on the schematic picture below as red ellipses can consist of multiple spins. This geometry allows for an exploration of spin interactions beyond the traditional square lattice framework. </p><img src="../images/sd.png" width="200%" class="center"/><p>In <code>SpinGlassPEPS.jl</code> solver, a grid of this type can be loaded using the command <code>super_square_lattice</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.super_square_lattice" href="#SpinGlassNetworks.super_square_lattice"><code>SpinGlassNetworks.super_square_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">super_square_lattice(
    size::NTuple{5, Int64}
) -&gt; Dict{Int64, Tuple{Int64, Int64}}
</code></pre><p>Create a mapping from Ising graph coordinates to a super square lattice arrangement. Variable number of Ising graph -&gt; cluster hamiltonian coordinate system</p><p>This function generates a mapping that relates Ising graph coordinates to a super square lattice arrangement.  The super square lattice is defined by the size of five dimensions: <code>(m, um, n, un, t)</code>, where m is the number of columns, n is the number of rows and t denotes the number of spins stored in the cluster.</p><p><strong>Arguments:</strong></p><ul><li><code>size::NTuple{5, Int}</code>: A tuple specifying the size of the super square lattice in five dimensions: <code>(m, um, n, un, t)</code>.</li></ul><p><strong>Returns:</strong></p><ul><li><code>coord_map::Dict</code>: A dictionary that maps Ising graph coordinates to the corresponding lattice coordinates.</li></ul><p>The <code>size</code> tuple represents the dimensions of the super square lattice. The function creates a dictionary where  ising graph coordinates are associated with their corresponding lattice coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/lattice.jl#L11">source</a></section><section><div><pre><code class="language-julia hljs">super_square_lattice(
    size::Tuple{Int64, Int64, Int64}
) -&gt; Dict{Int64, Tuple{Int64, Int64}}
</code></pre><p>Create a mapping from Ising graph coordinates to a simplified super square lattice arrangement.</p><p>This function generates a mapping that relates Ising graph coordinates to a simplified super square lattice arrangement.  The simplified super square lattice is defined by the size of three dimensions: <code>(m, n, t)</code>, where m is the number of columns,  n is the number of rows and t denotes the number of spins stored in the cluster.</p><p><strong>Arguments:</strong></p><ul><li><code>size::NTuple{3, Int}</code>: A tuple specifying the size of the simplified super square lattice in three dimensions: <code>(m, n, t)</code>, where <code>m</code> is number of columns, <code>n</code> number of rows and <code>t</code> denotes numberr of spins in cluster.</li></ul><p><strong>Returns:</strong></p><ul><li><code>coord_map::Dict</code>: A dictionary that maps Ising graph coordinates to the corresponding lattice coordinates.</li></ul><p>The <code>size</code> tuple represents the dimensions of the simplified super square lattice.  The function internally adds the required dimensions <code>(1, 1)</code> to make it compatible with the <code>super_square_lattice</code> function, which deals with five dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/lattice.jl#L36">source</a></section></article><p>Below you find simple example of usage <code>super_square_latttice</code> function.</p><pre><code class="language-julia hljs">using SpinGlassEngine, SpinGlassNetworks, LabelledGraphs

instance = &quot;$(@__DIR__)/../../src/instances/square_diagonal/5x5/diagonal.txt&quot;
ig = ising_graph(instance)

m = 5
n = 5
t = 4

cl_h = clustered_hamiltonian(
    ig,
    cluster_assignment_rule = super_square_lattice((m, n, t))
)

println(&quot;Number of nodes in oryginal instance: &quot;, length(LabelledGraphs.vertices(ig)), &quot;\n&quot;, &quot; Number of nodes in clustered Hamiltonian: &quot;, length(LabelledGraphs.vertices(cl_h)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of nodes in oryginal instance: 100
 Number of nodes in clustered Hamiltonian: 25</code></pre><h2 id="Pegasus-graphs"><a class="docs-heading-anchor" href="#Pegasus-graphs">Pegasus graphs</a><a id="Pegasus-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Pegasus-graphs" title="Permalink"></a></h2><p>The Pegasus graph is a type of graph architecture used in quantum computing systems, particularly in the quantum annealing machines developed by D-Wave Systems. It is designed to provide a grid of qubits with specific connectivity patterns optimized for solving certain optimization problems. Futer details can be found <a href="https://docs.dwavesys.com/docs/latest/c_gs_4.html#pegasus-graph">here</a>.</p><img src="../images/peg.png" width="200%" class="center"/><p>In <code>SpinGlassPEPS.jl</code> solver, a grid of this type can be loaded using the command <code>pegasus_lattice</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.pegasus_lattice" href="#SpinGlassNetworks.pegasus_lattice"><code>SpinGlassNetworks.pegasus_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pegasus_lattice(
    size::Tuple{Int64, Int64, Int64}
) -&gt; Dict{Int64, Tuple{Int64, Int64, Int64}}
</code></pre><p>Create a mapping from Ising graph coordinates to Pegasus lattice coordinates.</p><p>This function generates a mapping that relates Ising graph coordinates to Pegasus lattice coordinates  based on the specified size of the Pegasus lattice in three dimensions: <code>(m, n, t)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>size::NTuple{3, Int}</code>: A tuple specifying the size of the Pegasus lattice in three dimensions: <code>(m, n, t)</code>, where <code>m</code> is number of columns, <code>n</code> number of rows and <code>t</code> denotes number of spins in cluster. Convention: <code>t</code> is already divided by 8, so <code>t</code>=3 for Pegasus lattice.</li></ul><p><strong>Returns:</strong></p><ul><li><code>coord_map::Dict</code>: A dictionary that maps Ising graph coordinates to the corresponding Pegasus lattice coordinates.</li></ul><p>The <code>pegasus_lattice</code> allows you to build the graph relevant for D-Wave Pegasus architecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/lattice.jl#L61">source</a></section></article><p>Below you find simple example of usage <code>pegasus_latttice</code> function.</p><pre><code class="language-julia hljs">using SpinGlassEngine, SpinGlassNetworks, LabelledGraphs

# load Chimera instance and create Ising graph
instance = &quot;$(@__DIR__)/../../src/instances/pegasus_random/P4/RAU/001_sg.txt&quot;
ig = ising_graph(instance)

# Loaded instance is pegasus graph
m = 3
n = 3
t = 3

cl_h = clustered_hamiltonian(
    ig,
    cluster_assignment_rule = pegasus_lattice((m, n, t))
)

println(&quot;Number of nodes in original instance: &quot;, length(LabelledGraphs.vertices(ig)), &quot;\n&quot;, &quot; Number of nodes in clustered Hamiltonian: &quot;, length(LabelledGraphs.vertices(cl_h))/2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of nodes in original instance: 216
 Number of nodes in clustered Hamiltonian: 9.0</code></pre><h2 id="Zephyr-graphs"><a class="docs-heading-anchor" href="#Zephyr-graphs">Zephyr graphs</a><a id="Zephyr-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Zephyr-graphs" title="Permalink"></a></h2><p>The Zephyr graph is a type of graph architecture used in quantum computing systems, particularly in the quantum annealing machines developed by D-Wave Systems. Futer details can be found <a href="https://docs.dwavesys.com/docs/latest/c_gs_4.html#zephyr-graph">here</a>.</p><img src="../images/zep.png" width="200%" class="center"/><p>In <code>SpinGlassPEPS.jl</code> solver, a grid of this type can be loaded using the command <code>zephyr_lattice</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinGlassNetworks.zephyr_lattice" href="#SpinGlassNetworks.zephyr_lattice"><code>SpinGlassNetworks.zephyr_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zephyr_lattice(
    size::Tuple{Int64, Int64, Int64}
) -&gt; Dict{Int64, Tuple{Int64, Int64, Int64}}
</code></pre><p>Create a mapping from Ising graph coordinates to Zephyr lattice coordinates.</p><p>This function generates a mapping that relates Ising graph coordinates to Zephyr lattice  coordinates based on the specified size of the Zephyr lattice in three dimensions: <code>(m, n, t)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>size::NTuple{3, Int}</code>: A tuple specifying the size of the Zephyr lattice in three dimensions: <code>(m, n, t)</code>, where <code>m</code> is double number of columns, <code>n</code> double number of rows and <code>t</code> denotes number of spins in cluster. Convention: <code>t</code> is already divided by 4, so <code>t</code>=4 for Zephyr lattice. E.g. to create 3x3x16 Zephyr lattice, you should use <code>m</code>=6, <code>n</code>=6, <code>t</code>=4.</li></ul><p><strong>Returns:</strong></p><ul><li><code>coord_map::Dict</code>: A dictionary that maps Ising graph coordinates to the corresponding Zephyr lattice coordinates.</li></ul><p>The <code>zephyr_lattice</code> allows you to build the graph relevant for D-Wave Zephyr architecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/euro-hpc-pl/SpinGlassNetworks.jl/blob/v1.1.2/src/lattice.jl#L154">source</a></section></article><p>Below you find simple example of usage <code>zephyr_latttice</code> function.</p><pre><code class="language-julia hljs">using SpinGlassEngine, SpinGlassNetworks, LabelledGraphs

# load Chimera instance and create Ising graph
instance = &quot;$(@__DIR__)/../../src/instances/zephyr_random/Z3/RAU/001_sg.txt&quot;
ig = ising_graph(instance)

# Loaded instance is zephyr graph
m = 6
n = 6
t = 4

cl_h = clustered_hamiltonian(
    ig,
    cluster_assignment_rule = zephyr_lattice((m, n, t))
)

println(&quot;Number of nodes in oryginal instance: &quot;, length(LabelledGraphs.vertices(ig)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of nodes in oryginal instance: 332</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ising/">« Ising graph</a><a class="docs-footer-nextpage" href="../clh/">Clustered hamiltonian »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 2 May 2024 19:13">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
