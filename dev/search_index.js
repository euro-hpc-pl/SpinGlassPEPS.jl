var documenterSearchIndex = {"docs":
[{"location":"sge/guide/#Introduction","page":"User Guide","title":"Introduction","text":"","category":"section"},{"location":"sge/guide/","page":"User Guide","title":"User Guide","text":"A Julia package for finding low energy spectrum of Ising spin systems. Part of SpinGlassPEPS package.","category":"page"},{"location":"sge/guide/","page":"User Guide","title":"User Guide","text":"This part of the documentation is dedicated to describing the SpinGlassEngine.jl package, which serves as the actual solver. First, we will demonstrate how to construct a tensor network using the Potts Hamiltonian obtained with the SpinGlassNetworks.jl package. Next, we discuss the parameters necessary for conducting calculations, which the user should provide. Finally, we present functions that enable the discovery of low-energy spectra.","category":"page"},{"location":"sgn/clh/#Introduction","page":"Potts hamiltonian","title":"Introduction","text":"","category":"section"},{"location":"sgn/clh/","page":"Potts hamiltonian","title":"Potts hamiltonian","text":"A Potts Hamiltonian is a graphical representation that allows for a convenient and intuitive way to describe the structure of a network.","category":"page"},{"location":"sgn/clh/","page":"Potts hamiltonian","title":"Potts hamiltonian","text":"The concept of a Potts Hamiltonian within SpinGlassNetworks.jl introduces a mechanism for organizing spins into desired clustered geometries, facilitating a structured approach to modeling complex spin systems. ","category":"page"},{"location":"sgn/clh/","page":"Potts hamiltonian","title":"Potts hamiltonian","text":"potts_hamiltonian","category":"page"},{"location":"sgn/clh/#SpinGlassNetworks.potts_hamiltonian","page":"Potts hamiltonian","title":"SpinGlassNetworks.potts_hamiltonian","text":"potts_hamiltonian(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}} where T,\n    num_states_cl::Int64;\n    spectrum,\n    cluster_assignment_rule\n)\n\n\nCreate a Potts Hamiltonian.\n\nThis function constructs a Potts Hamiltonian from an Ising graph by introducing a natural order in Potts Hamiltonian coordinates.\n\nArguments:\n\nig::IsingGraph: The Ising graph representing the spin system.\nnum_states_cl::Int: The number of states per cluster taken into account when calculating the spectrum. In every cluster the number of states is constant.\nspectrum::Function: A function for calculating the spectrum of the Potts Hamiltonian. It can be full_spectrum or brute_force.\ncluster_assignment_rule::Dict{Int, L}: A dictionary specifying the assignment rule that maps Ising graph vertices to clusters. It can be super_square_lattice, pegasus_lattice or zephyr_lattice.\n\nReturns:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labelled graph.\n\nThe potts_hamiltonian function takes an Ising graph (ig) as input and constructs a Potts Hamiltonian by  introducing a natural order in Potts Hamiltonian coordinates.  It allows you to specify the number of states per cluster, a spectrum calculation function,  and a cluster assignment rule, which maps Ising graph vertices to clusters.\n\n\n\n\n\npotts_hamiltonian(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}} where T,\n    num_states_cl::Dict{T, Int64};\n    spectrum,\n    cluster_assignment_rule\n)\n\n\nCreate a Potts Hamiltonian.\n\nThis function constructs a Potts Hamiltonian from an Ising graph by introducing a natural order in Potts Hamiltonian coordinates.\n\nArguments:\n\nig::IsingGraph: The Ising graph representing the spin system.\nnum_states_cl::Dict{T, Int}: A dictionary specifying the number of states per cluster for different clusters. Number of states are considered when calculating the spectrum.\nspectrum::Function: A function for calculating the spectrum of the Potts Hamiltonian. It can be full_spectrum or brute_force.\ncluster_assignment_rule::Dict{Int, T}: A dictionary specifying the assignment rule that maps Ising graph vertices to clusters. It can be super_square_lattice, pegasus_lattice or zephyr_lattice.\n\nReturns:\n\npotts_h::LabelledGraph{MetaDiGraph}: The Potts Hamiltonian represented as a labelled graph.\n\nThe potts_hamiltonian function takes an Ising graph (ig) as input and constructs a Potts Hamiltonian  by introducing a natural order in Potts Hamiltonian coordinates. It allows you to specify the number of  states per cluster which can vary for different clusters, a spectrum calculation function,  and a cluster assignment rule, which maps Ising graph vertices to clusters.\n\n\n\n\n\npotts_hamiltonian(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}} where T;\n    spectrum,\n    cluster_assignment_rule\n)\n\n\nCreate a Potts Hamiltonian with optional cluster sizes.\n\nThis function constructs a Potts Hamiltonian from an Ising graph by introducing a natural order in Potts Hamiltonian coordinates.\n\nArguments:\n\nig::IsingGraph: The Ising graph representing the spin system.\nspectrum::Function: A function for calculating the spectrum of the Potts Hamiltonian. It can be full_spectrum or brute_force. Default is full_spectrum.\ncluster_assignment_rule::Dict{Int, T}: A dictionary specifying the assignment rule that maps Ising graph vertices to clusters. It can be super_square_lattice, pegasus_lattice or zephyr_lattice.\n\nReturns:\n\npotts_h::LabelledGraph{MetaDiGraph}: The Potts Hamiltonian represented as a labelled graph.\n\nThe potts_hamiltonian function takes an Ising graph (ig) as input and constructs a Potts Hamiltonian  by introducing a natural order in Potts Hamiltonian coordinates.  You can optionally specify a spectrum calculation function and a cluster assignment rule, which maps Ising graph vertices to clusters. This version of potts_hamiltonian function does not truncate states in the cluster while calculating the spectrum. If you want to specify custom cluster sizes, use the alternative version of this function by  passing a Dict{T, Int} containing the number of states per cluster as num_states_cl.\n\n\n\n\n\n","category":"function"},{"location":"sgn/clh/#Simple-example","page":"Potts hamiltonian","title":"Simple example","text":"","category":"section"},{"location":"sgn/clh/","page":"Potts hamiltonian","title":"Potts hamiltonian","text":"using SpinGlassNetworks\n\n# Load instance\ninstance = \"$(@__DIR__)/../../src/instances/square_diagonal/5x5/diagonal.txt\"\nig = ising_graph(instance)\n\n# Create Potts Hamiltonian\npotts_h = potts_hamiltonian(\n    ig,\n    cluster_assignment_rule = super_square_lattice((5,5,4))\n)","category":"page"},{"location":"sge/#SpinGlassEngine","page":"SpinGlassEngine","title":"SpinGlassEngine","text":"","category":"section"},{"location":"sge/","page":"SpinGlassEngine","title":"SpinGlassEngine","text":"A Julia package for finding low energy spectrum of Ising spin systems. Part of SpinGlassPEPS package.","category":"page"},{"location":"sge/api/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"","category":"page"},{"location":"sge/api/#Search","page":"Library","title":"Search","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"empty_solution\ngibbs_sampling\nbound_solution\nno_merge\nbranch_energy","category":"page"},{"location":"sge/api/#SpinGlassEngine.empty_solution","page":"Library","title":"SpinGlassEngine.empty_solution","text":"empty_solution(::Type{T}) -> Solution\nempty_solution(::Type{T}, n::Int64) -> Solution\n\n\nCreate an empty Solution object with a specified number of states.\n\nThis function creates an empty Solution object with the given number of states, initializing its fields with default values.\n\nArguments\n\nn::Int: The number of states for which the Solution object is created.\n\nReturns\n\nAn empty Solution object with default field values, ready to store search results for a specified number of states.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.gibbs_sampling","page":"Library","title":"SpinGlassEngine.gibbs_sampling","text":"gibbs_sampling(\n    ctr::MpsContractor{T, R, S},\n    sparams::SearchParameters;\n    ...\n) -> Solution\ngibbs_sampling(\n    ctr::MpsContractor{T, R, S},\n    sparams::SearchParameters,\n    merge_strategy;\n    no_cache\n) -> Solution\n\n\nPerform Gibbs sampling on a spin glass PEPS network.\n\nThis function performs Gibbs sampling on a spin glass PEPS (Projected Entangled Pair State) network using a branch-and-bound search algorithm. It takes as input a ctr object representing the PEPS network, sparams specifying search parameters, and merge_strategy for merging branches. Optionally, you can disable caching using the no_cache flag.\n\nArguments\n\nctr::AbstractContractor: The contractor object representing the PEPS network, which should be a subtype of AbstractContractor.\nsparams::SearchParameters: Parameters for controlling the search, including the maximum number of states and a cutoff probability.\nmerge_strategy=no_merge: (Optional) Merge strategy for branches. Defaults to no_merge.\nno_cache=false: (Optional) If true, disables caching. Defaults to false.\n\nReturns\n\nA Solution object representing the result of the Gibbs sampling.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.bound_solution","page":"Library","title":"SpinGlassEngine.bound_solution","text":"bound_solution(\n    psol::Solution,\n    max_states::Int64,\n    δprob::Real\n) -> Solution\nbound_solution(\n    psol::Solution,\n    max_states::Int64,\n    δprob::Real,\n    merge_strategy\n) -> Solution\n\n\nBound the solution to a specified number of states while discarding low-probability states.\n\nThis function takes a Solution object psol, bounds it to a specified number of states max_states, and discards low-probability states based on the probability threshold δprob. You can specify a merge_strategy for merging branches in the psol object.\n\nArguments\n\npsol::Solution: A Solution object representing the solution to be bounded.\nmax_states::Int: The maximum number of states to retain in the bounded solution.\nδprob::Real: The probability threshold for discarding low-probability states.\nmerge_strategy=no_merge: (Optional) Merge strategy for branches. Defaults to no_merge.\n\nReturns\n\nA Solution object representing the bounded solution with a maximum of max_states states.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.no_merge","page":"Library","title":"SpinGlassEngine.no_merge","text":"no_merge(partial_sol::Solution) -> Solution\n\n\nNo-op merge function that returns the input partial_sol as is.\n\nThis function is a no-op merge function that takes a Solution object partial_sol as input and returns it unchanged. It is used as a merge strategy when you do not want to perform any merging of branches in a solution.\n\nArguments\n\npartial_sol::Solution: A Solution object representing partial solutions.\n\nReturns\n\nThe input partial_sol object, unchanged.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.branch_energy","page":"Library","title":"SpinGlassEngine.branch_energy","text":"branch_energy(\n    ctr::MpsContractor{T},\n    eσ::Tuple{Real, Vector{Int64}}\n) -> Any\n\n\nCalculates the energy contribution of a branch given a base energy and a spin configuration.\n\nThis function calculates the energy contribution of a branch in a SpinGlassPEPS calculation. It takes a MpsContractor object ctr and a tuple eσ containing a base energy as the first element and a spin configuration represented as a vector of integers as the second element. The function calculates the branch energy by adding the base energy to the energy contribution of the given spin configuration obtained from the update_energy function.\n\nArguments\n\nctr::MpsContractor{T}: An instance of the MpsContractor type parameterized by the strategy type T.\neσ::Tuple{<:Real, Vector{Int}}: A tuple containing the base energy as the first element (a real number)\n\nand the spin configuration as the second element (a vector of integers).\n\nReturns\n\nThe branch energy, which is the sum of the base energy and the energy contribution of the spin configuration.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#Core","page":"Library","title":"Core","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"error_measure\nconditional_probability\nupdate_energy\nboundary\nboundary_indices\nGauges\nGaugeInfo\nPEPSNode\nSuperPEPSNode","category":"page"},{"location":"sge/api/#SpinGlassEngine.error_measure","page":"Library","title":"SpinGlassEngine.error_measure","text":"error_measure(probs) -> Any\n\n\nCalculate an error measure based on the given probability distribution.\n\nArguments\n\nprobs: An array representing a probability distribution.\n\nDescription\n\nThe error_measure function calculates an error measure based on the provided probability distribution.  The error measure is designed to capture discrepancies or irregularities in the distribution. The function checks for extreme cases, such as when the maximum probability less or equal zero, and returns a predefined value (2.0).  If the minimum probability is negative, the error measure is calculated as the absolute value of the minimum  probability divided by the maximum absolute value of the probabilities.  If neither of these conditions is met, the error measure is set to 0.0. The error measure provides a quantitative assessment of the deviation from a well-behaved probability distribution,  helping to identify potential issues or anomalies.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.conditional_probability","page":"Library","title":"SpinGlassEngine.conditional_probability","text":"conditional_probability(\n    _::Type{T<:SquareSingleNode},\n    ctr::MpsContractor{S},\n    ∂v::Vector{Int64}\n) -> Any\n\n\nCalculates conditional probability for a SquareSingleNode Layout.\n\n\n\n\n\nconditional_probability(\n    _::Type{T<:SquareCrossDoubleNode},\n    ctr::MpsContractor{S},\n    ∂v::Vector{Int64}\n) -> Any\n\n\nCompute the conditional probability of states for a square cross double node tensor geometry.\n\nArguments\n\n::Type{T}: Type representing a square cross double node tensor network.\nctr::MpsContractor{S}: Tensor contractor for the tensor network.\n∂v::Vector{Int}: Vector of indices representing the contracted environment indices.\n\nReturns\n\nVector{Float64}: Conditional probabilities for different states.\n\nDescription\n\nThe conditional_probability function computes the conditional probabilities of different states for a specified square cross double node tensor geometry. It takes into account the geometry of the tensor network, interaction energies, and precomputed values. The function supports both left and right environments, and the resulting probabilities are normalized. The function is specialized for the SquareCrossDoubleNode tensor network type and is parametrized by the layout type S of the contractor.\n\n\n\n\n\nconditional_probability(\n    ctr::MpsContractor{S},\n    w::Vector{Int64}\n) -> Any\n\n\nCalculate the conditional probability of a given state within the context of an MPS (Matrix Product State) contractor.\n\nArguments\n\nctr::MpsContractor{S}: An MPS contractor representing the contracted state and associated parameters.\nw::Vector{Int}: A vector representing the encoded state.\n\nReturns\n\nVector{Float64}: The calculated conditional probabilities for each possible outcome.\n\nDescription\n\nThe conditional_probability function calculates the conditional probability distribution of a given state within the context of an MPS contractor.  It delegates the calculation to the conditional_probability function with a specified tensor layout using the layout function. This function is a convenience wrapper that allows users to calculate conditional probabilities without explicitly specifying the tensor layout.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.update_energy","page":"Library","title":"SpinGlassEngine.update_energy","text":"update_energy(\n    _::Type{T<:SquareCrossDoubleNode},\n    ctr::MpsContractor{S},\n    σ::Vector{Int64}\n) -> Any\n\n\nUpdate the energy of a specific tensor node in a matrix product states (MPS).\n\nArguments\n\nT::Type: Tensor network type, specialized for SquareCrossDoubleNode.\nctr::MpsContractor{S}: MPS tensor network contractor containing relevant information for contraction.\nσ::Vector{Int}: State vector representing the current configuration of the tensor network.\n\nReturns\n\nReal: Updated energy value for the specified tensor node.\n\nDescription\n\nThe update_energy function calculates the energy contribution of a specific tensor node in a matrix product states (MPS). The energy is computed based on the local energy at the node and the interaction energies with its neighboring nodes, considering the provided state vector σ. The function is specialized for the SquareCrossDoubleNode tensor network type and is parametrized by the layout type S.\n\n\n\n\n\nupdate_energy(\n    ctr::MpsContractor{S},\n    w::Vector{Int64}\n) -> Any\n\n\nUpdate the energy associated with the current state within the context of an MPS (Matrix Product State) contractor.\n\nArguments\n\nctr::MpsContractor{S}: An MPS contractor representing the contracted state and associated parameters.\nw::Vector{Int}: A vector representing the encoded state.\n\nDescription\n\nThe update_energy function updates the energy associated with the current state within the context of an MPS contractor.  It delegates the calculation to the update_energy function with a specified tensor layout using the layout function. This function is a convenience wrapper that allows users to update the energy without explicitly specifying the tensor layout.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.boundary","page":"Library","title":"SpinGlassEngine.boundary","text":"boundary(\n    _::Type{T<:SquareCrossDoubleNode},\n    ctr::MpsContractor{S},\n    node::NTuple{N, Int64} where N\n) -> Any\n\n\nCompute the boundary states for a specific node in a matrix product states (MPS).\n\nArguments\n\nT::Type: Tensor network type, specialized for SquareCrossDoubleNode.\nctr::MpsContractor{S}: MPS tensor network contractor containing relevant information.\nnode::Node: Tuple representing the coordinates of the node in the tensor network.\n\nReturns\n\nVector{Tuple{Tuple, Tuple}}: Vector of tuples representing the boundary states for the given node.\n\nEach tuple contains pairs of indices representing connected sites in the tensor network.\n\nDescription\n\nThe boundary function computes the boundary states for a specific node in a matrix product states (MPS). The boundary states are determined by analyzing the connections between the current node and its neighboring nodes, considering different physical indices. The function is specialized for the SquareCrossDoubleNode tensor network type and is parametrized by the layout type S.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.boundary_indices","page":"Library","title":"SpinGlassEngine.boundary_indices","text":"boundary_indices(\n    ctr::MpsContractor{T},\n    nodes::Union{NTuple{4, S}, Tuple{S, Tuple{S, S}, S, Tuple{S, S}}},\n    states::Vector{Vector{Int64}}\n) -> Any\n\n\nboundary index formed from outer product of two projectors\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.Gauges","page":"Library","title":"SpinGlassEngine.Gauges","text":"Stores gauges and corresponding information.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.GaugeInfo","page":"Library","title":"SpinGlassEngine.GaugeInfo","text":"Defines information how to create gauges.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.PEPSNode","page":"Library","title":"SpinGlassEngine.PEPSNode","text":"Node for the SquareSingleNode and KingSingleNode.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.SuperPEPSNode","page":"Library","title":"SpinGlassEngine.SuperPEPSNode","text":"Node for the Pegasus type.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#Contractor","page":"Library","title":"Contractor","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"MpoLayers\nlayout\nsparsity\nstrategy\nmpo\nmps_top\nmps\nmps_approx\ndressed_mps\nright_env\nleft_env\nclear_memoize_cache\nclear_memoize_cache_after_row","category":"page"},{"location":"sge/api/#SpinGlassEngine.MpoLayers","page":"Library","title":"SpinGlassEngine.MpoLayers","text":"A struct representing different layers of a Matrix Product Operator (MPO) used in contraction algorithms.\n\nFields\n\nmain::Dict{Site, Sites}: A dictionary mapping sites to the main layers of the MPO.\ndress::Dict{Site, Sites}: A dictionary mapping sites to the dress layers of the MPO.\nright::Dict{Site, Sites}: A dictionary mapping sites to the right layers of the MPO.\n\nThe MpoLayers struct distinguishes the various layers of an MPO, which is often used in tensor network contraction algorithms. MPOs are commonly employed in quantum many-body physics and condensed matter physics to represent operators acting on quantum states in a factorized form.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.layout","page":"Library","title":"SpinGlassEngine.layout","text":"layout(net::PEPSNetwork{T, S}) -> Any\n\n\nA function that provides the layout used to construct the PEPS (Projected Entangled Pair States) network.\n\nArguments\n\nnet::PEPSNetwork{T, S}: The PEPS network for which the layout is provided.\n\nReturns\n\nThe layout type T used to construct the PEPS network.\n\nThe layout function returns the layout type used in the construction of a PEPS network. This layout type specifies the geometric arrangement and sparsity pattern of the tensors in the PEPS network.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.sparsity","page":"Library","title":"SpinGlassEngine.sparsity","text":"sparsity(net::PEPSNetwork{T, S}) -> Any\n\n\nA function that provides the sparsity used to construct the PEPS (Projected Entangled Pair States) network.\n\nArguments\n\nnet::PEPSNetwork{T, S}: The PEPS network for which the sparsity is provided.\n\nReturns\n\nThe sparsity type S used to construct the PEPS network.\n\nThe sparsity function returns the sparsity type used in the construction of a PEPS network. This sparsity type specifies the pattern of zero elements in the tensors of the PEPS network, which can affect the computational efficiency and properties of the network.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.strategy","page":"Library","title":"SpinGlassEngine.strategy","text":"strategy(_::MpsContractor{T}) -> Any\n\n\nGet the strategy used to contract the PEPS network.\n\nArguments\n\n::MpsContractor{T}: The MpsContractor object representing the PEPS network contraction.\n\nReturns\n\nT: The strategy used for network contraction.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.mpo","page":"Library","title":"SpinGlassEngine.mpo","text":"mpo(\n    ctr::MpsContractor{T<:SpinGlassEngine.AbstractStrategy, R, S},\n    layers::Dict{Union{Rational{Int64}, Int64}, NTuple{N, Union{Rational{Int64}, Int64}} where N},\n    r::Int64\n) -> Any\n\n\nConstruct and memoize a Matrix Product Operator (MPO) for a given set of layers.\n\nArguments\n\nctr::MpsContractor{T}: The MpsContractor object representing the PEPS network contraction.\nlayers::Dict{Site, Sites}: A dictionary mapping sites to their corresponding layers.\nr::Int: The current row index.\n\nReturns\n\nQMpo: The constructed MPO for the specified layers.\n\nThis function constructs an MPO by iterating through the specified layers and assembling the corresponding tensors. The resulting MPO is memoized for efficient reuse.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.mps_top","page":"Library","title":"SpinGlassEngine.mps_top","text":"mps_top(\n    ctr::MpsContractor{SVDTruncate, R, S},\n    i::Int64\n) -> Any\n\n\nConstruct and memoize the top Matrix Product State (MPS) using Singular Value Decomposition (SVD) for a given row.\n\nArguments\n\nctr::MpsContractor{SVDTruncate}: The MpsContractor object representing the PEPS network contraction with SVD truncation.\ni::Int: The current row index.\n\nReturns\n\nQMps: The constructed top MPS for the specified row.\n\nThis function constructs the top MPS using SVD for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, truncation, and compression steps as needed based on the specified parameters in ctr.params. The resulting MPS is memoized for efficient reuse.\n\n\n\n\n\nmps_top(ctr::MpsContractor{Zipper, R, S}, i::Int64) -> Any\n\n\nConstruct and memoize the top Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row.\n\nArguments\n\nctr::MpsContractor{Zipper}: The MpsContractor object representing the PEPS network contraction with the Zipper method.\ni::Int: The current row index.\n\nReturns\n\nQMps: The constructed top MPS using the Zipper method for the specified row.\n\nThis function constructs the top Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, and truncation steps based on the specified parameters in ctr.params. The resulting MPS is memoized for efficient reuse.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.mps","page":"Library","title":"SpinGlassEngine.mps","text":"mps(ctr::MpsContractor{SVDTruncate, R, S}, i::Int64) -> Any\n\n\nConstruct and memoize the (bottom) Matrix Product State (MPS) using Singular Value Decomposition (SVD) for a given row.\n\nArguments\n\nctr::MpsContractor{SVDTruncate}: The MpsContractor object representing the PEPS network contraction with SVD truncation.\ni::Int: The current row index.\n\nReturns\n\nQMps: The constructed (bottom) MPS for the specified row.\n\nThis function constructs the (bottom) MPS using SVD for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, truncation, and compression steps as needed based on the specified parameters in ctr.params. The resulting MPS is memoized for efficient reuse.\n\n\n\n\n\nmps(ctr::MpsContractor{Zipper, R, S}, i::Int64) -> Any\n\n\nConstruct and memoize the (bottom) Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row.\n\nArguments\n\nctr::MpsContractor{Zipper}: The MpsContractor object representing the PEPS network contraction with the Zipper method.\ni::Int: The current row index.\n\nReturns\n\nQMps: The constructed (bottom) MPS using the Zipper method for the specified row.\n\nThis function constructs the (bottom) Matrix Product State (MPS) using the Zipper (truncated Singular Value Decomposition) method for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, and truncation steps based on the specified parameters in ctr.params. The resulting MPS is memoized for efficient reuse.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.mps_approx","page":"Library","title":"SpinGlassEngine.mps_approx","text":"mps_approx(\n    ctr::MpsContractor{SVDTruncate, R, S},\n    i::Int64\n) -> Any\n\n\nConstruct and memoize the (bottom) Matrix Product State (MPS) approximation using Singular Value Decomposition (SVD) for a given row.\n\nArguments\n\nctr::MpsContractor{SVDTruncate}: The MpsContractor object representing the PEPS network contraction with SVD truncation.\ni::Int: The current row index.\n\nReturns\n\nQMps: The constructed (bottom) MPS approximation for the specified row.\n\nThis function constructs the (bottom) MPS approximation using SVD for a given row in the PEPS network contraction. It recursively builds the MPS row by row, performing canonicalization, and truncation steps based on the specified parameters in ctr.params. The resulting MPS approximation is memoized for efficient reuse.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.dressed_mps","page":"Library","title":"SpinGlassEngine.dressed_mps","text":"dressed_mps(\n    ctr::MpsContractor{T<:SpinGlassEngine.AbstractStrategy},\n    i::Int64\n) -> Any\n\n\nConstruct (and memoize) dressed Matrix Product State (MPS) for a given row and strategy.\n\nArguments\n\nctr::MpsContractor{T}: The MpsContractor object representing the PEPS network contraction.\ni::Int: The current row index.\n\nReturns\n\nQMps: The constructed dressed MPS for the specified row and strategy.\n\nThis function constructs the dressed Matrix Product State (MPS) for a given row in the PEPS network contraction using the specified strategy and memoizes the result for future use. It internally calls other functions such as mps and mpo to construct the dressed MPS. Additionally, it normalizes the MPS tensors to ensure numerical stability.\n\nNote: The memoization ensures that the dressed MPS is only constructed once for each combination of arguments and is reused when needed.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.right_env","page":"Library","title":"SpinGlassEngine.right_env","text":"right_env(\n    ctr::MpsContractor{T<:SpinGlassEngine.AbstractStrategy, R, S},\n    i::Int64,\n    ∂v::Vector{Int64}\n) -> Any\n\n\nConstruct (and memoize) the right environment tensor for a given node in the PEPS network contraction.\n\nArguments\n\nctr::MpsContractor{T}: The MpsContractor object representing the PEPS network contraction.\ni::Int: The current row index.\n∂v::Vector{Int}: A vector representing the partial environment configuration.\n\nReturns\n\nArray{S,2}: The constructed right environment tensor for the specified node.\n\nThis function constructs the right environment tensor for a given node in the PEPS network contraction using the specified strategy and memoizes the result for future use. It internally calls other functions such as dressed_mps and mpo to construct the right environment tensor. Additionally, it normalizes the right environment tensor to ensure numerical stability.\n\nNote: The memoization ensures that the right environment tensor is only constructed once for each combination of arguments and is reused when needed.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.left_env","page":"Library","title":"SpinGlassEngine.left_env","text":"left_env(\n    ctr::MpsContractor{T, R, S},\n    i::Int64,\n    ∂v::Vector{Int64}\n) -> Any\n\n\nConstruct (and memoize) the left environment tensor for a given node in the PEPS network contraction.\n\nArguments\n\nctr::MpsContractor{T}: The MpsContractor object representing the PEPS network contraction.\ni::Int: The current row index.\n∂v::Vector{Int}: A vector representing the partial environment configuration.\n\nReturns\n\nArray{S,2}: The constructed left environment tensor for the specified node.\n\nThis function constructs the left environment tensor for a given node in the PEPS network contraction using the specified strategy and memoizes the result for future use. It internally calls other functions such as dressed_mps to construct the left environment tensor. Additionally, it normalizes the left environment tensor to ensure numerical stability.\n\nNote: The memoization ensures that the left environment tensor is only constructed once for each combination of arguments and is reused when needed.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.clear_memoize_cache","page":"Library","title":"SpinGlassEngine.clear_memoize_cache","text":"clear_memoize_cache() -> Vector\n\n\nClear all memoization caches used by the PEPS network contraction.\n\nThis function clears all memoization caches that store previously computed results for various operations and environments in the PEPS network contraction. Memoization is used to optimize the contraction process by avoiding redundant computations. Calling this function removes all cached results, which can be useful when you want to free up memory or ensure that the caches are refreshed with updated data.\n\n\n\n\n\nclear_memoize_cache(\n    ctr::MpsContractor{T, S},\n    row::Union{Rational{Int64}, Int64}\n)\n\n\nClear memoization cache for specific operations for a given row and index beta.\n\nThis function clears the memoization cache for specific operations used in the PEPS network contraction for a given row. The cleared operations include mps_top, mps, mpo, dressed_mps, and related operations. Memoization is used to optimize the contraction process by avoiding redundant computations. Calling this function allows you to clear the cache for these specific operations for a particular row and index beta, which can be useful when you want to free up memory or ensure that the cache is refreshed with updated data for a specific computation.\n\nArguments\n\nctr::MpsContractor{T, S}: The PEPS network contractor object.\nrow::Site: The row for which the cache should be cleared.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.clear_memoize_cache_after_row","page":"Library","title":"SpinGlassEngine.clear_memoize_cache_after_row","text":"clear_memoize_cache_after_row() -> NTuple{4, Vector}\n\n\nClear memoization caches for specific operations after processing a row. This function clears the memoization caches for specific operations used in the PEPS network contraction after processing a row. The cleared operations include left_env, right_env, mpo, and dressed_mps. Memoization is used to optimize the contraction process by avoiding redundant computations. Calling this function allows you to clear the caches for these specific operations, which can be useful when you want to free up memory or ensure that the caches are refreshed with updated data after processing a row in the contraction.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#Operations","page":"Library","title":"Operations","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"vertex_map\ncheck_bounds\nLatticeTransformation","category":"page"},{"location":"sge/api/#SpinGlassEngine.vertex_map","page":"Library","title":"SpinGlassEngine.vertex_map","text":"vertex_map(\n    vert_permutation::NTuple{4, Int64},\n    nrows,\n    ncols\n) -> SpinGlassEngine.var\"#vmap#18\"\n\n\nCreate a vertex mapping function for a lattice transformation.\n\nArguments\n\nvert_permutation::NTuple{4, Int}: A permutation of vertex labels, defining a specific lattice transformation.\nnrows::Int: The number of rows in the lattice.\nncols::Int: The number of columns in the lattice.\n\nReturns\n\nA vertex mapping function vmap that takes a tuple of vertex coordinates and returns their new coordinates after applying the specified lattice transformation.    \n\n\n\n\n\nvertex_map(\n    trans::LatticeTransformation,\n    m::Int64,\n    n::Int64\n) -> SpinGlassEngine.var\"#vmap#18\"\n\n\nCreate a vertex map function based on a given lattice transformation.\n\nThis function generates a vertex map function that can be used to transform lattice vertex coordinates according to a specified lattice transformation. The trans argument should be a LatticeTransformation object, and m and n specify the dimensions of the lattice.\n\nArguments\n\ntrans::LatticeTransformation: The lattice transformation to apply.\nm::Int: The number of rows in the lattice.\nn::Int: The number of columns in the lattice.\n\nReturns\n\nA vertex map function that takes vertex coordinates and returns the transformed coordinates.    \n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.check_bounds","page":"Library","title":"SpinGlassEngine.check_bounds","text":"check_bounds(m, n) -> SpinGlassEngine.var\"#_check#1\"\n\n\nCreate a bounds-checking function for a lattice of size (m, n).\n\nArguments\n\nm::Int: The number of rows in the lattice.\nn::Int: The number of columns in the lattice.\n\nReturns\n\nA bounds-checking function that can be used to ensure that lattice points are within the specified bounds.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.LatticeTransformation","page":"Library","title":"SpinGlassEngine.LatticeTransformation","text":"A struct representing a lattice transformation.\n\nFields\n\npermutation::NTuple{4, Int}: A tuple defining a permutation of the vertex labels.\nflips_dimensions::Bool: A boolean indicating whether dimension flips are applied.\n\nThe LatticeTransformation struct defines a transformation that can be applied to the vertices of a lattice.  It specifies a permutation of vertex labels, allowing for rotations and reflections, as well as an option to flip dimensions. \n\n\n\n\n\n","category":"type"},{"location":"sge/api/#Droplets","page":"Library","title":"Droplets","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"Flip\nDroplet\nNoDroplets\nhamming_distance\nunpack_droplets\nperm_droplet\nfilter_droplets\nmy_push!\ndiversity_metric\nmerge_droplets\nflip_state\n","category":"page"},{"location":"sge/api/#SpinGlassEngine.Flip","page":"Library","title":"SpinGlassEngine.Flip","text":"A data structure representing a set of flips or changes in states for nodes in the SpinGlassPEPS package.\n\nA Flip object contains information about the support, state changes, and spinxor values for a set of node flips in the SpinGlassPEPS system.\n\nFields\n\nsupport::Vector{Int}: An array of integers representing the indices of nodes where flips occur.\nstate::Vector{Int}: An array of integers representing the new states for the nodes in the support.\nspinxor::Vector{Int}: An array of integers representing the spin-xor values for the nodes in the support.\n\nConstructors\n\nFlip(support::Vector{Int}, state::Vector{Int}, spinxor::Vector{Int}):\n\nCreates a new Flip object with the specified support, state changes, and spinxor values.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.Droplet","page":"Library","title":"SpinGlassEngine.Droplet","text":"A data structure representing a droplet in the context of the SpinGlassPEPS package. A Droplet represents an excitation in the SpinGlassPEPS system. It contains information about the excitation energy, the site where the droplet starts, the site where it ends, the states of nodes flipped by the droplet, and any sub-droplets on top of the current droplet.\n\nFields\n\ndenergy::Real: The excitation energy of the droplet, typically a real number.\nfirst::Int: The site index where the droplet starts.\nlast::Int: The site index where the droplet ends.\nflip::Flip: The states of nodes flipped by the droplet, often represented using a Flip type.\ndroplets::Union{NoDroplets, Vector{Droplet}}: A field that can be either NoDroplets() if there are no sub-droplets\n\non top of the current droplet or a vector of Droplet objects representing sub-droplets. This field may be used to build a hierarchy of droplets in more complex excitations.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.NoDroplets","page":"Library","title":"SpinGlassEngine.NoDroplets","text":"This is a method used to calculate excitation information for the NoDroplets strategy in the context of a SpinGlassPEPS contractor. The NoDroplets strategy represents a scenario in which no droplets are present in the system, and therefore, no excitation information is calculated.\n\nArguments\n\nmethod::NoDroplets: An instance of the NoDroplets strategy.\nctr::MpsContractor{T}: A SpinGlassPEPS contractor of type T representing the system.\nbest_idx::Int: The index of the best state.\nenergies::Vector{<:Real}: A vector of energies associated with different states.\nstates::Vector{Vector{Int}}: A vector of states represented as arrays of integers.\ndroplets::Vector{Droplets}: A vector of droplets in the system.\nspins::Vector{Vector{Int}}: A vector of spin configurations associated with states.\n\nReturns\n\nNoDroplets(): An instance of the NoDroplets strategy indicating that no excitation information is calculated in this scenario.\n\n\n\n\n\n","category":"type"},{"location":"sge/api/#SpinGlassEngine.hamming_distance","page":"Library","title":"SpinGlassEngine.hamming_distance","text":"hamming_distance(flip::Flip, s::Symbol) -> Int64\n\n\nCalculate the Hamming distance for a 'Flip' object.\n\nArguments\n\nflip::Flip: The 'Flip' object for which the Hamming distance will be calculated.\n\nReturns\n\nd::Int: The computed Hamming distance.\n\n\n\n\n\nhamming_distance(state1, state2, s::Symbol) -> Int64\n\n\nCalculate the Hamming distance between two vectors of states.\n\nArguments\n\nstate1::Vector{Int}: The first vector.\nstate2::Vector{Int}: The second vector.\n\nReturns\n\nd::Int: The computed Hamming distance.\n\n\n\n\n\nhamming_distance(\n    flip1::Flip,\n    flip2::Flip,\n    s::Symbol\n) -> Int64\n\n\nCalculate the Hamming distance between two Flip objects representing states with support and flip information.\n\nArguments\n\nflip1::Flip: The first Flip object, containing support, state, and spinxor information.\nflip2::Flip: The second Flip object, with support, state, and spinxor information.\n\nReturns\n\nhd::Int: The computed Hamming distance between the two Flip objects.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.unpack_droplets","page":"Library","title":"SpinGlassEngine.unpack_droplets","text":"unpack_droplets(sol, β) -> Solution\n\n\nUnpack droplets in a solution structure to create a new solution with individual excitations.\n\nArguments\n\nsol: The input solution containing droplets to be unpacked.\nβ::Real: The inverse temperature parameter used for probability adjustments.\n\nReturns\n\nnew_sol: A new solution where droplets are unpacked into individual excitations.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.perm_droplet","page":"Library","title":"SpinGlassEngine.perm_droplet","text":"perm_droplet(\n    drop::NoDroplets,\n    perm::Vector{Int64}\n) -> NoDroplets\n\n\nApply a permutation to a 'NoDroplets' object, resulting in an unchanged 'NoDroplets'.\n\nArguments\n\ndrop::NoDroplets: The 'NoDroplets' object that remains unchanged.\nperm::Vector{Int}: A permutation vector that is applied to indices.\n\nReturns\n\nresult::NoDroplets: The 'NoDroplets' object, which remains the same.\n\n\n\n\n\nperm_droplet(\n    drops::Vector{Droplet},\n    perm::Vector{Int64}\n) -> Vector{Droplet}\n\n\nApply a permutation to a collection of 'Droplet' objects.\n\nArguments\n\ndrops::Vector{Droplet}: A vector of 'Droplet' objects to which the permutation is applied.\nperm::Vector{Int}: A permutation vector that is applied to indices.\n\nReturns\n\nresult::Vector{Droplet}: A vector of 'Droplet' objects after applying the permutation.\n\n\n\n\n\nperm_droplet(drop::Droplet, perm::Vector{Int64}) -> Droplet\n\n\nApply a permutation to a 'Droplet' object.\n\nArguments\n\ndrop::Droplet: A 'Droplet' object to which the permutation is applied.\nperm::Vector{Int}: A permutation vector that is applied to indices.\n\nReturns\n\nresult::Droplet: A 'Droplet' object after applying the permutation.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.filter_droplets","page":"Library","title":"SpinGlassEngine.filter_droplets","text":"filter_droplets(\n    all_droplets::Vector{Droplet},\n    method::SingleLayerDroplets\n) -> Vector{Droplet}\n\n\nFilter a vector of droplets based on specified criteria and strategy parameters.\n\nArguments\n\nall_droplets::Vector{Droplet}: A vector of Droplet objects representing the droplets to be filtered.\nmethod::SingleLayerDroplets: An instance of the SingleLayerDroplets strategy used to determine filtering criteria.\n\nReturns\n\nfiltered_droplets::Vector{Droplet}: A filtered vector of Droplet objects based on the specified criteria and strategy parameters.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.my_push!","page":"Library","title":"SpinGlassEngine.my_push!","text":"my_push!(\n    ndroplets::Union{NoDroplets, Vector{Droplet}},\n    droplet::Droplet,\n    method\n) -> Union{NoDroplets, Vector{Droplet}}\n\n\nPush a 'Droplet' object into a vector of droplets ('Droplets') while considering the strategy parameters.\n\nArguments\n\nndroplets::Droplets: A vector of 'Droplet' objects to which the new 'Droplet' object will be added.\ndroplet::Droplet: The 'Droplet' object to be added to the vector.\nmethod: The strategy parameter that determines whether or not the 'Droplet' object is added based on the defined criteria.\n\nReturns\n\nndroplets::Droplets: The updated vector of 'Droplet' objects after the addition of the new 'Droplet' object.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.diversity_metric","page":"Library","title":"SpinGlassEngine.diversity_metric","text":"diversity_metric(\n    drop1::Droplet,\n    drop2::Droplet,\n    metric::Symbol,\n    mode::Symbol\n) -> Union{Float64, Int64}\n\n\nCalculate the diversity metric between two 'Droplet' objects based on the specified metric.\n\nArguments\n\ndrop1::Droplet: The first 'Droplet' object for comparison.\ndrop2::Droplet: The second 'Droplet' object for comparison.\nmetric::Symbol: A symbol specifying the metric to be used for the diversity calculation. Currently, only the \"hamming\" metric is supported.\n\nReturns\n\nd::Real: The calculated diversity metric value between the two 'Droplet' objects.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.merge_droplets","page":"Library","title":"SpinGlassEngine.merge_droplets","text":"merge_droplets(\n    method::SingleLayerDroplets,\n    droplet::Droplet,\n    subdroplet::Droplet\n) -> Droplet\n\n\nMerge two Droplets according to the specified SingleLayerDroplets method.\n\nArguments\n\nmethod::SingleLayerDroplets: The method used to determine whether and how to merge the droplets.\ndroplet::Droplet: The main droplet to be merged.\nsubdroplet::Droplet: The subdroplet to be merged with the main droplet.\n\nReturns\n\nmerged_droplet::Droplet: The merged droplet created based on the merging method.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.flip_state","page":"Library","title":"SpinGlassEngine.flip_state","text":"flip_state(\n    state::Vector{Int64},\n    flip::Flip\n) -> Vector{Int64}\n\n\nApply a flip operation to a state.\n\nArguments\n\nstate::Vector{Int}: The original state vector.\nflip::Flip: The flip operation to be applied to the state.\n\nReturns\n\nnew_state::Vector{Int}: The modified state after applying the flip operation.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#PEPS","page":"Library","title":"PEPS","text":"","category":"section"},{"location":"sge/api/","page":"Library","title":"Library","text":"SpinGlassEngine.local_energy\nSpinGlassEngine.interaction_energy\nnormalize_probability\ninitialize_gauges!\ndecode_state\nSpinGlassEngine.bond_energy\nSpinGlassEngine.projector\nspectrum\nis_compatible\nones_like\ntensor_map\nsize\nexact_spectrum\ndiscard_probabilities!\nmod_wo_zero\nexact_marginal_probability\n_normalize\nprojectors_site_tensor\nbranch_probability\nexact_conditional_probability\nbranch_solution\ngauges_list\nbranch_energies\n_equalize\nnodes_search_order_Mps\nsampling\nVirtualDoubleNode\nfuse_projectors\nlocal_spins\ntensor\nbranch_states\nprecompute_conditional","category":"page"},{"location":"sge/api/#SpinGlassEngine.local_energy","page":"Library","title":"SpinGlassEngine.local_energy","text":"local_energy(\n    network::AbstractGibbsNetwork{S, T, R},\n    vertex\n) -> Any\n\n\nRetrieve the local energy spectrum associated with a specific vertex in the Gibbs network.\n\nArguments\n\nnetwork::AbstractGibbsNetwork{S, T}: Gibbs network containing the Potts Hamiltonian.\nvertex::S: Vertex for which the local energy spectrum is to be retrieved.\n\nReturns\n\nLocal energy spectrum associated with the specified vertex.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.interaction_energy","page":"Library","title":"SpinGlassEngine.interaction_energy","text":"interaction_energy(\n    network::AbstractGibbsNetwork{S, T, R},\n    v,\n    w\n) -> Any\n\n\nCompute the interaction energy between two vertices in a Gibbs network.\n\nArguments\n\nnetwork::AbstractGibbsNetwork{S, T}: Gibbs network containing the Potts Hamiltonian.\nv::S: First vertex.\nw::S: Second vertex.\n\nReturns\n\nenergy::Matrix{T}: Interaction energy matrix between vertices v and w.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.normalize_probability","page":"Library","title":"SpinGlassEngine.normalize_probability","text":"normalize_probability(probs::Vector{<:Real}) -> Any\n\n\nNormalize a probability distribution.\n\nArguments\n\nprobs::Vector{<:Real}: A vector representing a probability distribution.\n\nReturns\n\nVector{Float64}: Normalized probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.initialize_gauges!","page":"Library","title":"SpinGlassEngine.initialize_gauges!","text":"initialize_gauges!(net::AbstractGibbsNetwork{S, T, R})\ninitialize_gauges!(\n    net::AbstractGibbsNetwork{S, T, R},\n    type::Symbol\n)\n\n\nInitialize gauge tensors in a Gibbs network.\n\nArguments\n\nnet::AbstractGibbsNetwork{S, T}: Gibbs network to initialize.\ntype::Symbol=:id: Type of initialization, either :id for identity or :rand for random values.\n\nDescription\n\nThis function initializes gauge tensors in a Gibbs network according to the specified type.  Each gauge tensor is associated with two positions in the network and a type.  The positions are determined by the gauge's positions field, and the type is specified by the gauge's type field.  The initialization type can be either :id for identity tensors or :rand for random tensors.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.decode_state","page":"Library","title":"SpinGlassEngine.decode_state","text":"decode_state(\n    peps::AbstractGibbsNetwork{S, T},\n    σ::Vector{Int64}\n) -> Any\ndecode_state(\n    peps::AbstractGibbsNetwork{S, T},\n    σ::Vector{Int64},\n    potts_h_order::Bool\n) -> Any\n\n\nDecode a state vector into a dictionary representation.\n\nArguments\n\npeps::AbstractGibbsNetwork{S, T}: The Gibbs network.\nσ::Vector{Int}: State vector to be decoded.\npotts_h_order::Bool=false: If true, use the order of nodes in the Potts Hamiltonian.\n\nReturns\n\nDict{Symbol, Int}: A dictionary mapping node symbols to corresponding values in the state vector.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.bond_energy","page":"Library","title":"SpinGlassEngine.bond_energy","text":"bond_energy(\n    net::AbstractGibbsNetwork{T, S, R},\n    u::NTuple{N, Int64} where N,\n    v::NTuple{N, Int64} where N,\n    σ::Int64\n) -> Any\n\n\nCalculate the bond energy between nodes u and v for a given index σ in the Gibbs network net.\n\nArguments\n\nnet::AbstractGibbsNetwork{T, S}: The Gibbs network.\nu::Node: One of the nodes connected by the bond.\nv::Node: The other node connected by the bond.\nσ::Int: The index for which the bond energy is calculated.\n\nReturns\n\nenergies::Vector{T}: Vector containing the bond energies between nodes u and v for index σ.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.projector","page":"Library","title":"SpinGlassEngine.projector","text":"projector(network::AbstractGibbsNetwork{S, T}, v, w) -> Any\n\n\nCompute the projector between two nodes v and w in the Gibbs network network.\n\nArguments\n\nnetwork::AbstractGibbsNetwork{S, T}: The Gibbs network.\nv::S: Source node.\nw::S: Target node.\n\nReturns\n\nprojector::Matrix{T}: Projector matrix between nodes v and w.\n\n\n\n\n\nprojector(\n    net::AbstractGibbsNetwork{S, T},\n    v,\n    vertices::NTuple{N, S}\n) -> Any\n\n\nCompute the projector matrix for the given node v onto a tuple of target nodes vertices in the Gibbs network net.\n\nArguments\n\nnet::AbstractGibbsNetwork{S, T}: The Gibbs network.\nv::S: Source node.\nvertices::NTuple{N, S}: Tuple of target nodes onto which the projector is computed.\n\nReturns\n\nfirst fused projector matrix for node v onto the specified target nodes.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.spectrum","page":"Library","title":"SpinGlassEngine.spectrum","text":"spectrum(network::AbstractGibbsNetwork{S, T}, vertex) -> Any\n\n\nRetrieve the spectrum associated with a specific vertex in the Gibbs network.\n\nArguments\n\nnetwork::AbstractGibbsNetwork{S, T}: Gibbs network containing the Potts Hamiltonian.\nvertex::S: Vertex for which the spectrum is to be retrieved.\n\nReturns\n\nSpectrum associated with the specified vertex.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.is_compatible","page":"Library","title":"SpinGlassEngine.is_compatible","text":"is_compatible(\n    potts_hamiltonian::LabelledGraphs.LabelledGraph,\n    network_graph::LabelledGraphs.LabelledGraph\n) -> Union{Missing, Bool}\n\n\nCheck if a Potts Hamiltonian is compatible with a given network graph.\n\nArguments\n\npotts_hamiltonian::LabelledGraph: Graph representing the Potts Hamiltonian.\nnetwork_graph::LabelledGraph: Graph representing the network.\n\nReturns\n\ncompatibility::Bool: true if the Potts Hamiltonian is compatible with the network graph, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.ones_like","page":"Library","title":"SpinGlassEngine.ones_like","text":"ones_like(x::Number) -> Any\n\n\nCreate an identity with the same type as the input number x.\n\nArguments\n\nx: A numeric value.\n\nReturns\n\na multiplicative identity with the same type as x.\n\n\n\n\n\nones_like(x::AbstractArray) -> Any\n\n\nCreate an array of ones with the same element type and size as the input array x.\n\nArguments\n\nx::AbstractArray: An array serving as a template.\n\nReturns\n\nresult::Array: An array of ones with the same element type and size as x.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.tensor_map","page":"Library","title":"SpinGlassEngine.tensor_map","text":"tensor_map(\n    _::Type{SquareSingleNode{T<:Union{EnergyGauges, GaugesEnergy}}},\n    _::Type{S<:AbstractSparsity},\n    nrows::Int64,\n    ncols::Int64\n) -> Dict{PEPSNode, Symbol}\n\n\nAssigns type of tensor to a PEPS node coordinates for a given Layout and Sparsity.\n\n\n\n\n\ntensor_map(\n    _::Type{SquareSingleNode{T<:EngGaugesEng}},\n    _::Type{S<:AbstractSparsity},\n    nrows::Int64,\n    ncols::Int64\n) -> Dict{PEPSNode, Symbol}\n\n\nAssigns type of tensor to a PEPS node coordinates for a given Layout and Sparsity.\n\n\n\n\n\ntensor_map(\n    _::Type{SquareCrossDoubleNode{T<:Union{EnergyGauges, GaugesEnergy}}},\n    _::Type{S<:AbstractSparsity},\n    nrows::Int64,\n    ncols::Int64\n) -> Dict{PEPSNode, Symbol}\n\n\nCreate a mapping of tensor network nodes for a square cross double node geometry.\n\nArguments\n\n::Type{SquareCrossDoubleNode{T}}: Type representing a square cross double node geometry.\n::Type{S}: Type representing sparsity in the tensor network.\nnrows::Int: Number of rows in the tensor network.\nncols::Int: Number of columns in the tensor network.\n\nReturns\n\nDict{PEPSNode, Symbol}: A dictionary mapping PEPS nodes to symbols representing their corresponding tensor network nodes.\n\nDescription\n\nThe tensor_map function generates a mapping of tensor network nodes for a square cross double node geometry. The mapping includes different types of nodes, such as site double nodes, virtual double nodes, central vertical double nodes, and central diagonal double nodes.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#Base.size","page":"Library","title":"Base.size","text":"size(\n    net::PEPSNetwork{SquareCrossDoubleNode{T<:AbstractTensorsLayout}, S<:AbstractSparsity},\n    node::PEPSNode,\n    _::Val{:central_d_double_node}\n) -> Tuple{Any, Any}\n\n\nDetermine the size of the tensor corresponding to a central double node in a projected entangled pair states (PEPS) tensor network.\n\nArguments\n\nnet::PEPSNetwork{SquareCrossDoubleNode{T}, S}: PEPS tensor network with square cross double nodes.\nnode::PEPSNode: Node representing the position of the central double node.\n::Val{:central_d_double_node}: symbol to indicate the central double node.\n\nReturns\n\nTuple{Int, Int}: Tuple representing the size of the tensor for the central double node.\n\nDescription\n\nThe Base.size function is used to determine the size of the tensor corresponding to a central double node in a PEPS tensor network. It calculates the size by considering the sizes of the two central tensors associated with neighboring positions. The function is parametrized by the abstract tensors layout type T and the abstract sparsity type S.\n\n\n\n\n\nsize(\n    net::AbstractGibbsNetwork{NTuple{N, Int64} where N, PEPSNode},\n    node::PEPSNode,\n    _::Union{Val{:virtual_double_node}, Val{:sparse_virtual_double_node}}\n) -> NTuple{4, Any}\n\n\nDetermine the size of the virtual tensor associated with a virtual double node in a tensor network.\n\nArguments\n\nnet::AbstractGibbsNetwork{Node, PEPSNode}: Abstract Gibbs PEPS tensor network with nodes and virtual tensors.\nnode::PEPSNode: PEPS node representing the position of the virtual double node.\n::Union{Val{:virtual_double_node}, Val{:sparse_virtual_double_node}}: Tag indicating whether the virtual tensor is dense or sparse.\n\nReturns\n\nTuple (s1, s2, s3, s4): Size information for the virtual tensor.\n\nDescription\n\nThe size function determines the size of the virtual tensor associated with a virtual double node in an Abstract Gibbs PEPS tensor network. The size is specified by the dimensions along the left, top, right, and bottom directions. The function is parametrized by the types of nodes (Node and PEPSNode) and the tag indicating whether the virtual tensor is dense or sparse.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.exact_spectrum","page":"Library","title":"SpinGlassEngine.exact_spectrum","text":"exact_spectrum(\n    potts_hamiltonian::LabelledGraphs.LabelledGraph{S, T}\n) -> Any\n\n\nCalculate the exact spectrum and corresponding eigenstates for a Potts Hamiltonian using memoization.\n\nArguments\n\npotts_hamiltonian::LabelledGraph{S, T}: A Potts Hamiltonian represented as a labelled graph.\n\nReturns\n\nTuple (energies, states): A tuple containing the calculated energies and corresponding eigenstates.\n\nDescription\n\nThe exact_spectrum function calculates the exact spectrum and corresponding eigenstates for a Potts Hamiltonian using memoization.  The function utilizes memoization to efficiently store and retrieve previously computed results for different inputs, reducing redundant calculations. The Hamiltonian is represented as a labelled graph (LabelledGraph) with vertices corresponding to clusters and edges  representing interactions between clusters.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.discard_probabilities!","page":"Library","title":"SpinGlassEngine.discard_probabilities!","text":"discard_probabilities!(\n    psol::Solution,\n    cutoff_prob::Real\n) -> Solution\n\n\nDiscards low-probability states from the given solution.\n\nArguments\n\npsol::Solution: The input solution containing states and their probabilities.\ncutoff_prob::Real: The cutoff probability below which states will be discarded.\n\nReturns\n\nSolution: A new solution with low-probability states discarded.\n\nDescription\n\nThis function removes states from the solution psol whose probabilities are below the specified cutoff_prob. It calculates a cutoff probability (pcut) based on the maximum probability in psol and the provided cutoff_prob. States with probabilities lower than pcut are considered discarded. The largest discarded probability (ldp) in the resulting solution is updated based on the maximum discarded probability among the removed states and the existing ldp in psol.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.mod_wo_zero","page":"Library","title":"SpinGlassEngine.mod_wo_zero","text":"mod_wo_zero(k, m) -> Any\n\n\nCalculate the modulo operation of k with respect to m, ensuring the result is not zero.\n\nArguments\n\nk: The dividend.\nm: The divisor.\n\nReturns\n\nresult::Int: The result of k % m, ensuring it is not zero.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.exact_marginal_probability","page":"Library","title":"SpinGlassEngine.exact_marginal_probability","text":"exact_marginal_probability(\n    ctr::MpsContractor{T},\n    σ::Vector{Int64}\n) -> Any\n\n\nCalculate the exact marginal probability of a target state within the context of an MPS (Matrix Product State) contractor.\n\nArguments\n\nctr::MpsContractor{T}: An MPS contractor representing the contracted state and associated parameters.\nσ::Vector{Int}: A vector representing the encoded state.\n\nReturns\n\nFloat64: The calculated exact marginal probability of the target state.\n\nDescription\n\nThe exact_marginal_probability function calculates the exact marginal probability of a target state within the context of an MPS contractor.  It decodes the provided state vector σ using the decode_state function, obtains the exact spectrum and states  from the Potts Hamiltonian of the associated PEPS, and computes the marginal probability of the target state using the Boltzmann distribution. The function utilizes the exact_spectrum function to obtain the energies and states of the Potts Hamiltonian,  exponentiates the negative energies multiplied by the inverse temperature (ctr.beta), normalizes the probabilities,  and calculates the marginal probability of the target state.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine._normalize","page":"Library","title":"SpinGlassEngine._normalize","text":"_normalize(probs::Vector{<:Real}) -> Any\n\n\nNormalize a probability distribution.\n\nArguments\n\nprobs::Vector{<:Real}: A vector representing a probability distribution.\n\nReturns\n\nVector{Float64}: Normalized probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.projectors_site_tensor","page":"Library","title":"SpinGlassEngine.projectors_site_tensor","text":"projectors_site_tensor(\n    net::PEPSNetwork{T<:SquareCrossDoubleNode, S},\n    vertex::NTuple{N, Int64} where N\n) -> NTuple{4, Any}\n\n\nConstruct the set of projectors associated with a site tensor in a projected entangled pair states (PEPS) tensor network.\n\nArguments\n\nnet::PEPSNetwork{T, S}: PEPS tensor network with nodes of type T and tensors of sparsity type S.\nvertex::Node: Node representing the position of the site tensor.\n\nReturns\n\n(plf, pt, prf, pb): Tuple of projectors associated with the site tensor, corresponding to the left (plf), top (pt), right (prf), and bottom (pb) directions.\n\nDescription\n\nThe projectors_site_tensor function constructs the set of projectors associated with a site tensor at the specified position in a PEPS tensor network. The projectors are created based on the neighboring tensors and directions in the network. The function is parametrized by the abstract node type T and the abstract sparsity type S.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.branch_probability","page":"Library","title":"SpinGlassEngine.branch_probability","text":"branch_probability(\n    ctr::MpsContractor{T},\n    pσ::Tuple{Real, Vector{Int64}}\n) -> Any\n\n\nCalculates the branch probability for a given state.\n\nArguments\n\nctr::MpsContractor{T}: The MPS contractor object.\npσ::Tuple{<:Real, Vector{Int}}: Tuple containing the energy and state configuration.\n\nReturns\n\nReal: The calculated branch probability.\n\nDescription\n\nThis function calculates the branch probability for a specific state configuration using the conditional probability provided by the MPS contractor. The branch probability is computed as the logarithm of the conditional probability of the given state. The conditional probability is obtained from the MPS contractor.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.exact_conditional_probability","page":"Library","title":"SpinGlassEngine.exact_conditional_probability","text":"exact_conditional_probability(\n    ctr::MpsContractor{T},\n    σ::Vector{Int64}\n) -> Any\n\n\nCalculate the exact conditional probability of a target state within the context of an MPS (Matrix Product State) contractor.\n\nArguments\n\nctr::MpsContractor{T}: An MPS contractor representing the contracted state and associated parameters.\nσ::Vector{Int}: A vector representing the encoded state.\n\nReturns\n\nVector{Float64}: The calculated exact conditional probabilities for each possible outcome.\n\nDescription\n\nThe exact_conditional_probability function calculates the exact conditional probability distribution of a target state within the context of an MPS contractor.  It uses the exact_marginal_probability function for different branch states generated by branch_state and normalizes the probabilities.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.branch_solution","page":"Library","title":"SpinGlassEngine.branch_solution","text":"branch_solution(\n    psol::Solution,\n    ctr::SpinGlassEngine.AbstractContractor\n) -> Solution\n\n\nGenerate a new solution by branching the given partial solution in a contracting Gibbs network.\n\nArguments\n\npsol::Solution: The partial solution.\nctr::T: The contractor representing the contracting Gibbs network.\n\nReturns\n\nSolution: A new solution obtained by branching the partial solution in the contracting network.\n\nDescription\n\nThis function generates a new solution by branching the given partial solution in a contracting Gibbs network. It computes the energies, states, probabilities, degeneracies, discarded probabilities, droplets, and spins for the resulting solution. The branching process involves considering the current node in the contractor and updating the solution accordingly.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.gauges_list","page":"Library","title":"SpinGlassEngine.gauges_list","text":"gauges_list(\n    _::Type{SquareSingleNode{T<:GaugesEnergy}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nAssigns gauges and corresponding information to GaugeInfo structure for a given Layout.\n\n\n\n\n\ngauges_list(\n    _::Type{SquareSingleNode{T<:EnergyGauges}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nAssigns gauges and corresponding information to GaugeInfo structure for a given Layout.\n\n\n\n\n\ngauges_list(\n    _::Type{SquareSingleNode{T<:EngGaugesEng}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nAssigns gauges and corresponding information to GaugeInfo structure for a given Layout.\n\n\n\n\n\ngauges_list(\n    _::Type{SquareDoubleNode{T<:GaugesEnergy}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nAssigns gauges and corresponding information to GaugeInfo structure for a given Layout.\n\n\n\n\n\ngauges_list(\n    _::Type{SquareDoubleNode{T<:EnergyGauges}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nAssigns gauges and corresponding information to GaugeInfo structure for a given Layout.\n\n\n\n\n\ngauges_list(\n    _::Type{SquareCrossDoubleNode{T<:GaugesEnergy}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nCreate a list of gauge information for a square cross double node geometry and GaugesEnergy Layout.\n\nArguments\n\n::Type{SquareCrossDoubleNode{T}}: Type representing a square cross double node geometry.\nnrows::Int: Number of rows in the tensor network.\nncols::Int: Number of columns in the tensor network.\n\nReturns\n\nVector{GaugeInfo}: A vector of GaugeInfo objects representing gauge information for the specified geometry.\n\nDescription\n\nThe gauges_list function generates a list of GaugeInfo objects for a square cross double node geometry. Each GaugeInfo object contains information about the positions of gauge links, the position of the attached tensor, the leg index, and the type of gauge.\n\n\n\n\n\ngauges_list(\n    _::Type{SquareCrossDoubleNode{T<:EnergyGauges}},\n    nrows::Int64,\n    ncols::Int64\n) -> Vector{GaugeInfo}\n\n\nCreate a list of gauge information for a square cross double node geometry and EnergyGauges Layout.\n\nArguments\n\n::Type{SquareCrossDoubleNode{T}}: Type representing a square cross double node geometry.\nnrows::Int: Number of rows in the tensor network.\nncols::Int: Number of columns in the tensor network.\n\nReturns\n\nVector{GaugeInfo}: A vector of GaugeInfo objects representing gauge information for the specified geometry.\n\nDescription\n\nThe gauges_list function generates a list of GaugeInfo objects for a square cross double node geometry. Each GaugeInfo object contains information about the positions of gauge links, the position of the attached tensor, the leg index, and the type of gauge.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.branch_energies","page":"Library","title":"SpinGlassEngine.branch_energies","text":"branch_energies(\n    ctr::MpsContractor{T},\n    psol::Solution\n) -> Any\n\n\nCompute and branch the energies from different branches in a solution.\n\nArguments\n\nctr::MpsContractor{T}: The MPS contractor.\npsol::Solution: The partial solution.\n\nReturns\n\nVector{<:Real}: A vector containing the energies of individual branches.\n\nDescription\n\nThis function computes the energies of branches in a solution by applying the branch_energy function to each pair of energy and state in the given partial solution. The result is a vector of energies corresponding to the branches.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine._equalize","page":"Library","title":"SpinGlassEngine._equalize","text":"_equalize(probs::Vector{<:Real}) -> Any\n\n\nEqualize a probability distribution.\n\nArguments\n\nprobs::Vector{<:Real}: A vector representing a probability distribution.\n\nReturns\n\nVector{Float64}: Equalized probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.nodes_search_order_Mps","page":"Library","title":"SpinGlassEngine.nodes_search_order_Mps","text":"nodes_search_order_Mps(\n    peps::PEPSNetwork{T<:SquareCrossDoubleNode, S}\n) -> Tuple{Vector, Tuple{Int64, Int64, Int64}}\n\n\nGenerate the search order of nodes for a matrix product states (MPS).\n\nArguments\n\npeps::PEPSNetwork{T, S}: PEPS tensor network with a specific tensor layout.\n\nReturns\n\nTuple{Vector{Tuple{Int, Int, Int}}, Tuple{Int, Int, Int}}: Tuple containing the list of node coordinates and the size of the tensor network.\n\nDescription\n\nThe nodes_search_order_Mps function generates the search order of nodes for a matrix product states (MPS). It creates a list of node coordinates (i, j, k) representing rows, columns, and index of group of spins, respectively. The resulting order is suitable for traversing the nodes in the tensor network during contraction. The function is specialized for the SquareCrossDoubleNode tensor network type and is parametrized by the layout type S.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.sampling","page":"Library","title":"SpinGlassEngine.sampling","text":"sampling(\n    psol::Solution,\n    max_states::Int64,\n    δprob::Real\n) -> Solution\nsampling(\n    psol::Solution,\n    max_states::Int64,\n    δprob::Real,\n    merge_strategy\n) -> Solution\n\n\nGenerate a new solution by sampling states based on their probabilities.\n\nArguments\n\npsol::Solution: The partial solution from which to sample states.\nmax_states::Int: The maximum number of states to sample.\nδprob::Real: The probability threshold for discarding states.\nmerge_strategy=no_merge: The merging strategy, defaults to no_merge.\n\nReturns\n\nSolution: A new solution obtained by sampling states.\n\nDescription\n\nThis function generates a new solution by sampling states from the given partial solution. The sampling is performed based on the probabilities associated with each state. The number of sampled states is determined by the max_states argument. Additionally, states with probabilities below the threshold δprob are discarded. The optional argument merge_strategy specifies the merging strategy to be used during the sampling process. It defaults to no_merge, indicating no merging.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.VirtualDoubleNode","page":"Library","title":"SpinGlassEngine.VirtualDoubleNode","text":"VirtualDoubleNode(_::Type{Dense}) -> Symbol\n\n\nCreate a symbol representing a virtual double node for a dense tensor layout.\n\nArguments\n\n::Type{Dense}: The Dense tensor layout type.\n\nReturns\n\nSymbol: A symbol representing the virtual double node.\n\nDescription\n\nThe VirtualDoubleNode function generates a symbol (:virtual_double_node) that represents a virtual double node in the context of a dense tensor layout. This symbol is often used to indicate the presence of a virtual double node when working with certain tensors.\n\n\n\n\n\nVirtualDoubleNode(_::Type{Sparse}) -> Symbol\n\n\nCreate a symbol representing a virtual double node for a sparse tensor layout.\n\nArguments\n\n::Type{Sparse}: The Sparse tensor layout type.\n\nReturns\n\nSymbol: A symbol representing the virtual double node.\n\nDescription\n\nThe VirtualDoubleNode function generates a symbol (:virtual_double_node) that represents a virtual double node in the context of a sparse tensor layout. This symbol is often used to indicate the presence of a virtual double node when working with certain tensors.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.fuse_projectors","page":"Library","title":"SpinGlassEngine.fuse_projectors","text":"fuse_projectors(\n    projectors::NTuple{N, K}\n) -> Tuple{Any, Tuple}\n\n\nFuse a tuple of projector matrices into a single projector matrix using rank-revealing techniques.\n\nArguments\n\nprojectors::NTuple{N, K}: Tuple of projector matrices to be fused.\n\nReturns\n\nfused::Matrix{Float64}: Fused projector matrix.\ntransitions::NTuple{N, Vector{Int}}: Tuple of transition vectors indicating the indices of the non-zero rows in each original projector.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.local_spins","page":"Library","title":"SpinGlassEngine.local_spins","text":"local_spins(\n    network::AbstractGibbsNetwork{S, T},\n    vertex\n) -> Any\n\n\nRetrieve the local spin configurations associated with a vertex in the Gibbs network.\n\nArguments\n\nnetwork::AbstractGibbsNetwork{S, T}: The Gibbs network.\nvertex::S: The vertex for which local spins are requested.\n\nReturns\n\nVector{Int}: An array representing the local spin configurations.\n\nDescription\n\nThis function retrieves the local spin configurations associated with a given vertex in the Gibbs network. The local spins are extracted from the spectrum of the Potts Hamiltonian associated with the vertex.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.tensor","page":"Library","title":"SpinGlassEngine.tensor","text":"tensor(\n    net::PEPSNetwork{T<:AbstractGeometry, Sparse},\n    node::PEPSNode,\n    β::Real,\n    _::Val{:central_d_double_node}\n) -> DiagonalTensor{_A, 2} where _A<:Real\n\n\nGenerate the tensor for a central double node in a projected entangled pair states (PEPS) tensor network.\n\nArguments\n\nnet::PEPSNetwork{T, Sparse}: PEPS tensor network.\nnode::PEPSNode: Node representing the position of the central double node.\nβ::Real: Inverse temperature parameter.\n::Val{:central_d_double_node}: symbol to indicate the central double node.\n\nReturns\n\nDiagonalTensor: Tensor representing the central double node.\n\nDescription\n\nThe tensor function generates the tensor for a central double node in a PEPS tensor network. It uses the inverse temperature parameter β to construct the central tensor based on the geometry of the tensor network. The function is specialized for PEPS tensor networks with sparse tensors (Sparse) and is parametrized by the abstract geometry type T.\n\n\n\n\n\ntensor(\n    net::PEPSNetwork{SquareCrossDoubleNode{T<:AbstractTensorsLayout}, S<:Union{Dense, Sparse}},\n    node::PEPSNode,\n    β::Real,\n    _::Val{:sparse_virtual_double_node}\n) -> VirtualTensor{_A, 4} where _A<:Real\n\n\nCreate a sparse virtual double node tensor in a projected entangled pair states (PEPS) tensor network.\n\nArguments\n\nnet::PEPSNetwork{SquareCrossDoubleNode{T}, S}: PEPS tensor network with square cross double nodes.\nnode::PEPSNode: Node representing the position of the virtual double node.\nβ::Real: Inverse temperature parameter.\n::Val{:sparse_virtual_double_node}: symbol to indicate the creation of a sparse virtual double node tensor.\n\nReturns\n\nVirtualTensor{T, S}: Sparse virtual double node tensor.\n\nDescription\n\nThe tensor function is used to create a sparse virtual double node tensor in a PEPS tensor network. It constructs the tensor by incorporating information about the central tensor and surrounding projectors associated with the specified position. The function is parametrized by the abstract tensors layout type T, and the abstract sparsity type S, which can be either Sparse or Dense.\n\n\n\n\n\ntensor(\n    net::PEPSNetwork{T<:AbstractGeometry, Dense},\n    node::PEPSNode,\n    β::Real,\n    _::Val{:virtual_double_node}\n) -> Any\n\n\nCreate a dense virtual double node tensor in a projected entangled pair states (PEPS) tensor network.\n\nArguments\n\nnet::PEPSNetwork{T, Dense}: PEPS tensor network with nodes of type T and dense tensors.\nnode::PEPSNode: Node representing the position of the virtual double node.\nβ::Real: Inverse temperature parameter.\n::Val{:virtual_double_node}: symbol to indicate the creation of a dense virtual double node tensor.\n\nReturns\n\nTensor{T}: Dense virtual double node tensor.\n\nDescription\n\nThe tensor function is used to create a dense virtual double node tensor in a PEPS tensor network. It constructs the tensor by combining information from the sparse virtual double node tensor, including projectors and the dense central tensor associated with the specified position. The function is parametrized by the abstract geometry type T.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.branch_states","page":"Library","title":"SpinGlassEngine.branch_states","text":"branch_states(\n    local_basis::Vector{Int64},\n    vec_states::Vector{Vector{Int64}}\n) -> Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}\n\n\nConstructs branch states based on a local basis and vectorized states.\n\nArguments\n\nlocal_basis::Vector{Int}: The local basis states.\nvec_states::Vector{Vector{Int}}: Vectorized states for each branch.\n\nReturns\n\nVector{Vector{Int}}: A vector containing the constructed branch states.\n\nDescription\n\nThis function constructs branch states by combining a local basis with vectorized states. The local basis provides the unique states for each branch, and the vectorized states represent the state configuration for each branch. The resulting vector contains the constructed branch states.\n\n\n\n\n\n","category":"function"},{"location":"sge/api/#SpinGlassEngine.precompute_conditional","page":"Library","title":"SpinGlassEngine.precompute_conditional","text":"precompute_conditional(\n    266::Type{T<:SquareCrossDoubleNode},\n    ctr::MpsContractor{S},\n    current_node\n) -> Any\n\n\nPrecompute conditional probabilities and energies for a square cross double node tensor contraction.\n\nArguments\n\n::Type{T}: Type representing a square cross double node tensor network.\nctr::MpsContractor{S}: Tensor contractor for the tensor network.\ncurrent_node: Current node position in the tensor network.\n\nReturns\n\nTuple: A tuple containing precomputed conditional probabilities and energies.\n\nDescription\n\nThe precompute_conditional function computes and returns precomputed conditional probabilities and energies for the specified square cross double node tensor contraction. It takes into account the geometry of the tensor network, interaction energies, and projectors. The precomputed values are used during the tensor contraction process to speed up the computation. The function is specialized for the SquareCrossDoubleNode tensor network type and is parametrized by the layout type S of the contractor.\n\n\n\n\n\n","category":"function"},{"location":"sgt/mpo/#Matrix-Product-States-and-Matrix-Product-Operations","page":"Matrix Product States and Matrix Product Operations","title":"Matrix Product States and Matrix Product Operations","text":"","category":"section"},{"location":"sgt/mpo/","page":"Matrix Product States and Matrix Product Operations","title":"Matrix Product States and Matrix Product Operations","text":"MpoTensor","category":"page"},{"location":"sgt/mpo/#SpinGlassTensors.MpoTensor","page":"Matrix Product States and Matrix Product Operations","title":"SpinGlassTensors.MpoTensor","text":"A mutable struct representing a Matrix Product Operator (MPO) tensor in a tensor network.\n\nFields\n\ntop::Vector{Tensor{T, 2}}: Vector of tensors representing the top tensor of the MPO. Empty if N == 2.\nctr::Union{Tensor{T, N}, Nothing}: Central tensor of the MPO. Nothing if not present.\nbot::Vector{Tensor{T, 2}}: Vector of tensors representing the bottom tensor of the MPO. Empty if N == 2.\ndims::Dims{N}: Dimensions of the MPO tensor.\n\nDescription\n\nMpoTensor{T, N} is a mutable struct that represents a Matrix Product Operator tensor in a tensor network.      The MPO tensor is characterized by its top and bottom tensors, a central tensor (ctr), and dimensions (dims).  The top and bottom legs are vectors of two-dimensional tensors (Tensor{T, 2}).  The central tensor is of type Tensor{T, N} or Nothing if not present.  The dimensions of the MPO tensor are specified by dims. \n\n\n\n\n\n","category":"type"},{"location":"intro/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Before diving into the documentation for the provided functionalities, let's demonstrate the core capabilities of this package through a practical example.","category":"page"},{"location":"intro/#Basic-example","page":"Getting started","title":"Basic example","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"In this example, we demonstrate how to use the SpinGlassPEPS.jl package to calculate a low-energy spectrum for a spin glass Hamiltonian defined on a square lattice with diagonal interactions. ","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"using SpinGlassPEPS\n\nfunction get_instance(topology::NTuple{3, Int})\n    m, n, t = topology\n    \"$(@__DIR__)/instances/$(m)x$(n)x$(t).txt\"\nend\n\n\nfunction run_square_diag_bench(::Type{T}; topology::NTuple{3, Int}) where {T}\n    m, n, _ = topology\n    instance = get_instance(topology)\n    lattice = super_square_lattice(topology)\n\n    best_energies = T[]\n\n    potts_h = potts_hamiltonian(\n        ising_graph(instance),\n        spectrum = full_spectrum,\n        cluster_assignment_rule = lattice,\n    )\n\n    params = MpsParameters{T}(; bond_dim = 16, num_sweeps = 1)\n    search_params = SearchParameters(; max_states = 2^8, cutoff_prob = 1E-4)\n\n    for transform ∈ all_lattice_transformations\n        net = PEPSNetwork{KingSingleNode{GaugesEnergy}, Dense, T}(\n            m, n, potts_h, transform,\n        )\n\n        ctr = MpsContractor(SVDTruncate, net, params; \n            onGPU = false, beta = T(2), graduate_truncation = true,\n        )\n\n        droplets = SingleLayerDroplets(; max_energy = 10, min_size = 5, metric = :hamming)\n        merge_strategy = merge_branches(\n            ctr; merge_prob = :none , droplets_encoding = droplets,\n        )\n\n        sol, schmidts = low_energy_spectrum(ctr, search_params, merge_strategy)\n        droplets = unpack_droplets(sol, T(2))\n        ig_states = decode_potts_hamiltonian_state.(Ref(potts_h), droplets.states)\n        ldrop = length(droplets.states)\n\n        println(\"Number of droplets for transform $(transform) is $(ldrop)\")\n\n        push!(best_energies, sol.energies[1])\n        clear_memoize_cache()\n    end\n\n    ground = best_energies[1]\n    @assert all(ground .≈ best_energies)\n\n    println(\"Best energy found: $(ground)\")\nend\n\n\nT = Float64\n@time run_square_diag_bench(T; topology = (3, 3, 2))","category":"page"},{"location":"intro/#Main-steps","page":"Getting started","title":"Main steps","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Let’s walk through the key steps of the code.","category":"page"},{"location":"intro/#Defining-the-lattice","page":"Getting started","title":"Defining the lattice","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The first line of the code above loads the problem instance using the get_instance function:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"instance = get_instance(topology)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Here, topology is a tuple (m, n, t) representing the dimensions of the lattice m, n and the cluster size t. The get_instance function constructs the file path to the corresponding problem instance, based on the provided topology.","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The topology of the lattice is specified: ","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"topology = (3, 3, 2)\nm, n, _ = topology","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"This defines a 3x3 grid with clusters of size 2.","category":"page"},{"location":"intro/#Defining-the-Hamiltonian","page":"Getting started","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Then we map the Ising problem to an effective Potts Hamiltonian defined on a king’s graph (super_square_lattice):","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"potts_h = potts_hamiltonian(\nising_graph(instance),\nspectrum = full_spectrum,\ncluster_assignment_rule = super_square_lattice(topology),\n)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Here, ising_graph(instance) reads the Ising graph from the provided file and the spins are grouped into clusters based on the super_square_lattice rule, which performs transformation of linear Ising spin indices to clustered hamiltonian coordinate system.","category":"page"},{"location":"intro/#Setting-parameters","page":"Getting started","title":"Setting parameters","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"To control the complexity and accuracy of the simulation, we define several parameters:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"params = MpsParameters{T}(; bond_dim = 16, num_sweeps = 1)\nsearch_params = SearchParameters(; max_states = 2^8, cutoff_prob = 1E-4)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"bond_dim = 16: The bond dimension for the tensor network.\nnum_sweeps = 1: Number of sweeps during variational compression.\nmax_states = 2^8: Maximum number of states considered during the search.\ncutoff_prob = 1E-4: The cutoff probability specifies the probability below which states are discarded from further consideration.","category":"page"},{"location":"intro/#Tensor-network-construction-and-contraction","page":"Getting started","title":"Tensor network construction and contraction","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The tensor network representation of the system is created using the PEPSNetwork structure:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"net = PEPSNetwork{KingSingleNode{GaugesEnergy}, Dense, T}(m, n, potts_h, transform)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"This constructs a PEPS network based on the KingSingleNode, which specifies the type of the node used within the tensor networks. The layout GaugesEnergy defines how the tensor network is divided into Matrix Product Operators (MPO).  Other control parameter includes Sparsity which determines whether dense or sparse tensors should be used. In this example, as we apply small clusters containing two spins, we can use Dense mode. The parameter T represents the data type used for numerical calculations. In this example, we set: ","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"T = Float64","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Here, Float64 specifies that the computations will be performed using 64-bit floating-point numbers, which is a common choice in scientific computing for balancing precision and performance. One can also use Float32. The contraction of the tensor network is handled by the MpsContractor:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"ctr = MpsContractor(SVDTruncate, net, params; \n    onGPU = false, beta = T(2), graduate_truncation = true,\n)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The parameters for the MpsContractor include:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Strategy refers to the method used for approximating boundary Matrix Product States. Here Strategy is set to SVDTruncate.\nonGPU = false: Here computations are done on the CPU. If you want to switch on GPU mode, then type","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"onGPU = true","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"beta = T(2): Inverse temperature, here set to 2. Higher value (lower temperature) allows us to focus on low-energy states.\ngraduate_truncation = true: Enabling gradual truncation of the MPS.","category":"page"},{"location":"intro/#Searching-for-excitations","page":"Getting started","title":"Searching for excitations","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The branch-and-bound search algorithm is used to find low-energy excitations:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"droplets = SingleLayerDroplets(; max_energy = 10, min_size = 5, metric = :hamming)\nmerge_strategy = merge_branches(ctr; merge_prob = :none , droplets_encoding = droplets)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Here, the parameter max_energy sets the energy range within which we look for excitations above the ground state. The min_size parameter enforces a minimum Hamming distance between excitations, ensuring that the algorithm searches for distinct, independent excitations. The optional merge_branches function allows us to identify spin glass droplets.","category":"page"},{"location":"intro/#Multiple-lattice-transformations","page":"Getting started","title":"Multiple lattice transformations","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"We apply different lattice transformations to the problem, iterating over all possible transformations:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"for transform ∈ all_lattice_transformations\n    ...\nend","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"This loop applies all possible transformations (rotations and reflections) to the 2D lattice. By exploring all eight transformations, the algorithm can start the contraction process from different points on the lattice, improving stability and increasing the chances of finding the global minimum energy state.","category":"page"},{"location":"intro/#Low-energy-spectrum-calculation","page":"Getting started","title":"Low-energy spectrum calculation","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"Finally, the low-energy spectrum is calculated with:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"sol, schmidts = low_energy_spectrum(ctr, search_params, merge_strategy)\ndroplets = unpack_droplets(sol, T(2))\nig_states = decode_potts_hamiltonian_state.(Ref(potts_h), droplets.states)","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"This function returns the Solution structure sol along with the schmidts - smallest retained singular value of boundary MPSs. In the Solution structure one can find not only states with the lowest energy, their probabilities and largest probability discarded during the search, but also spin-glass droplets build on the top of the low energy state. To reconstruct the low-energy spectrum from identified localized excitation one can use unpack_droplets function. In the Solution structure, we store the states build from Potts variables of higher dimensions. To return to binary Ising spins, the Potts states are decoded using the decode_potts_hamiltonian_state function.","category":"page"},{"location":"intro/#Expected-output","page":"Getting started","title":"Expected output","text":"","category":"section"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The output of this example should print number of droplets found during each transformation and the best energy found during the optimization:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"println(\"Best energy found: $(ground)\")","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"This output confirms that the ground state energies found under different lattice transformations are consistent.","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"The full function is executed as:","category":"page"},{"location":"intro/","page":"Getting started","title":"Getting started","text":"T = Float64\n@time run_square_diag_bench(T; topology = (3, 3, 2))","category":"page"},{"location":"sgn/userguide/#Introduction","page":"User guide","title":"Introduction","text":"","category":"section"},{"location":"sgn/userguide/","page":"User guide","title":"User guide","text":"A Julia package for building and interacting with Ising spin glass models in context of tensor networks. Part of SpinGlassPEPS package.","category":"page"},{"location":"sgn/userguide/","page":"User guide","title":"User guide","text":"The contents of our package are illustrated through comprehensive examples, showcasing the practical utilization of key functions. Specifically, the ising_graph function is highlighted, demonstrating its capacity to generate Ising model graphs — a fundamental step in modeling spin systems. Additionally, the potts_hamiltonian function is presented as a tool for converting Ising graphs into Potts Hamiltonians. The package delves into various lattice geometries, providing insights into constructing diverse structures such as the super_square_lattice, pegasus_lattice, and zephyr_lattice. Moreover, the documentation outlines methods for local dimensional reduction, shedding light on techniques to streamline computations and enhance the efficiency of spin system simulations.","category":"page"},{"location":"sge/params/#Contracting-PEPS-tensor-network","page":"Search parameters","title":"Contracting PEPS tensor network","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Once we construct the tensor network, we can proceed with its contraction. The first step involves preparing structures to store information about the approximate contraction using the MPS-MPO method and the exploration of states through the branch-and-bound algorithm.","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"MpsContractor","category":"page"},{"location":"sge/params/#SpinGlassEngine.MpsContractor","page":"Search parameters","title":"SpinGlassEngine.MpsContractor","text":"MpsContractor is a mutable struct that represents the contractor responsible for contracting a PEPS (Projected Entangled Pair States) network using the MPO-MPS (Matrix Product Operator - Matrix Product State) scheme.\n\nType Parameters\n\nT<:AbstractStrategy: Specifies the contraction strategy to be employed.\nR<:AbstractGauge: Specifies the gauge-fixing method used for optimizing the contraction.\nS<:Real: Represents the numeric precision type for real values (e.g., Float64).\n\nConstructor\n\nThis constructor initializes an instance of MpsContractor with the following arguments: Positional arguments:\n\nnet: The PEPS network to be contracted.\nparams: Contains the control parameters for the MPO-MPS contraction, such as bond dimension and the number of sweeps.\n\nKeyword arguments:\n\nbeta::S: The inverse temperature, β, which is crucial for focusing on low-energy states. A larger β sharpens the focus on these states but may reduce the numerical stability of the tensor contraction. The optimal value of β often depends on the problem instance.\ngraduate_truncation::Bool: A flag indicating whether bond dimensions in the MPS are truncated progressively. When set to true, this truncation method adjusts the bond dimensions gradually during contraction.\nonGPU::Bool: A flag indicating whether the computation should be performed on a GPU (default is true).\ndepth::Int: Specifies the depth of variational sweeps during the Zipper algorithm. A value of 0 implies a full variational sweep across all lattice sites.\n\nThe constructor sets up the internal structure of the contractor, including the MPO layers, search order for nodes, and storage for contraction statistics.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/#Structures-to-store-parameters-used-in-branch-and-bound-search","page":"Search parameters","title":"Structures to store parameters used in branch and bound search","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"MpsParameters\nSearchParameters","category":"page"},{"location":"sge/params/#SpinGlassEngine.MpsParameters","page":"Search parameters","title":"SpinGlassEngine.MpsParameters","text":"A struct representing control parameters for the MPO-MPS (Matrix Product Operator - Matrix Product State) scheme used to contract a PEPS (Projected Entangled Pair States) network.\n\nFields\n\nbond_dimension::Int: The maximum bond dimension to be used during contraction.\nvariational_tol::Real: The tolerance for the variational solver used in MPS optimization. It gives the condition for overlap convergence during one sweep in boundary MPS. Default is 1E-8.\nmax_num_sweeps::Int: The maximum number of sweeps to perform during variational compression. Default is 4.\ntol_SVD::Real: The tolerance used in singular value decomposition (SVD) operations. It means that smaller singular values are truncated. Default is 1E-16.\niters_svd::Int: The number of iterations to perform in SVD computations. Default is 1.\niters_var::Int: The number of iterations for variational optimization. Default is 1.\nDtemp_multiplier::Int: A multiplier for the bond dimension when temporary bond dimensions are computed. Default is 2.\nmethod::Symbol: The type of SVD method to use (e.g., :psvd_sparse). Default is :psvd_sparse.\n\nKeyword Arguments:\n\nbond_dim: Specifies the maximum bond dimension (default is typemax(Int)).\nvar_tol: Tolerance for the variational solver (default is 1E-8).\nnum_sweeps: Maximum number of sweeps for variational compression (default is 4).\ntol_SVD: Tolerance for SVD operations (default is 1E-16).\niters_svd: Number of SVD iterations (default is 1).\niters_var: Number of iterations for variational optimization (default is 1).\nDtemp_multiplier: Multiplier for temporary bond dimensions (default is 2).\nmethod: SVD method to use, such as :psvdsparse (default is :psvdsparse).\n\nDescription: The MpsParameters struct encapsulates various control parameters that influence the behavior and accuracy of the MPO-MPS contraction scheme used in PEPS network calculations. This allows fine-tuning of tolerances, iteration limits, and methods for efficient and accurate tensor network contractions.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/#SpinGlassEngine.SearchParameters","page":"Search parameters","title":"SpinGlassEngine.SearchParameters","text":"A struct representing search parameters for low-energy spectrum search.\n\nConstructor\n\nKeyword arguments:\n\nmax_states::Int: The maximum number of states to be considered during the search. Default is 1, indicating a single state search.\ncutoff_prob::Real: The cutoff probability for terminating the search. Default is 0.0, meaning no cutoff based on probability.\n\nSearchParameters encapsulates parameters that control the behavior of low-energy spectrum search algorithms in the SpinGlassPEPS package.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/#Strategy","page":"Search parameters","title":"Strategy","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"In the boundary MPS-MPO approach we apply Matrix Product Operator (MPO) to appropriate sites of Matrix Product State (MPS). In this context, the absorption of a MPO into a MPS leads to an exponential growth of the bond dimension. Hence, a truncation scheme is necessary to mitigate this issue and to keep the bond dimension in a reasonable size.  Our package offers users the flexibility to choose between three distinct methods for optimizing the boundary MPS used in contracting the tensor network: ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Zipper\nSVDTruncate.","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Zipper method combines a zipper scheme of Ref.. with the standard variational optimization of the resulting MPS (see Ref.)","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/zipper_final.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"With the SVDTruncate method, the Matrix Product State (MPS) is systematically constructed row by row, contracted with the Matrix Product Operator (MPO) from the preceding row. The resulting MPS undergoes a Singular Value Decomposition (SVD) to truncate its bond dimension, followed by variational compression. ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/svd_truncate.png\" width=\"50%\" class=\"center\"/>","category":"page"},{"location":"sge/params/#Sparsity","page":"Search parameters","title":"Sparsity","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"The Sparsity parameter controls whether ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Dense ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"or ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Sparse ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"tensor representations are used during calculations. Sparse tensors are particularly useful for handling large clusters containing around 10 to 20 spins. When bond dimensions increase, constructing PEPS tensors explicitly (triggered by Sparsity=Dense) becomes computationally expensive and quickly infeasible. In contrast, setting Sparsity=Sparse avoids the direct construction of full tensors. Instead, it performs optimal contractions on smaller tensor structures, which are then combined to contract the entire network efficiently. This approach leverages the internal structure of the individual tensors to reduce computational overhead and memory usage.","category":"page"},{"location":"sge/params/#Geometry","page":"Search parameters","title":"Geometry","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"One can specify the type of the node used within the tensor networks: ","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SquareSingleNode","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/square_single.png\" width=\"50%\" class=\"center\"/>","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SquareSingleNode","category":"page"},{"location":"sge/params/#SpinGlassEngine.SquareSingleNode","page":"Search parameters","title":"SpinGlassEngine.SquareSingleNode","text":"A geometric structure representing a 1-layer grid with nodes arranged in a grid of rows and columns. \n\nType Parameters\n\nT <: AbstractTensorsLayout: The layout of decomposition of tensors into MPS. Can be GaugesEnergy, EnergyGauges or EngGaugesEng.\n\nConstructors\n\nSquareDoubleNode(layout::T): Create a SquareDoubleNode with the specified tensor layout.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SquareDoubleNode","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/square_double.png\" width=\"50%\" class=\"center\"/>","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SquareDoubleNode","category":"page"},{"location":"sge/params/#SpinGlassEngine.SquareDoubleNode","page":"Search parameters","title":"SpinGlassEngine.SquareDoubleNode","text":"A geometric structure representing a 2-layer grid with nodes arranged in rows and columns.  Each node is labeled with a tuple (i, j, k), where i is the row index, j is the column index, and k is the layer index (1 or 2).\n\nType Parameters\n\nT <: AbstractTensorsLayout: The layout of decomposition of tensors into MPS. Can be GaugesEnergy, EnergyGauges or EngGaugesEng.\n\nConstructors\n\nSquareDoubleNode(layout::T): Create a SquareDoubleNode with the specified tensor layout.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"KingSingleNode","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/square_cross_single.png\" width=\"50%\" class=\"center\"/>","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"KingSingleNode","category":"page"},{"location":"sge/params/#SpinGlassEngine.KingSingleNode","page":"Search parameters","title":"SpinGlassEngine.KingSingleNode","text":"A geometric structure representing a 1-layer grid with nodes arranged in a grid of rows and columns, and additional diagonal edges forming a cross pattern between neighboring nodes.\n\nType Parameters\n\nT <: AbstractTensorsLayout: The layout of decomposition of tensors into MPS. Can be GaugesEnergy, EnergyGauges or EngGaugesEng.\n\nConstructors\n\nKingSingleNode(layout::T): Create a KingSingleNode with the specified tensor layout.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SquareCrossDoubleNode","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/square_cross_double.png\" width=\"50%\" class=\"center\"/>","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SquareCrossDoubleNode","category":"page"},{"location":"sge/params/#SpinGlassEngine.SquareCrossDoubleNode","page":"Search parameters","title":"SpinGlassEngine.SquareCrossDoubleNode","text":"A geometric structure representing a 2-layer grid with nodes arranged in rows and columns, and additional diagonal edges forming a cross pattern between neighboring nodes. Each node is labeled with a tuple (i, j, k), where i is the row index, j is the column index, and k is the layer index (1 or 2).\n\nType Parameters\n\nT <: AbstractTensorsLayout: The layout of decomposition of tensors into MPS. Can be GaugesEnergy, EnergyGauges or EngGaugesEng.\n\nConstructors\n\nKingSingleNode(layout::T): Create a SquareCrossDoubleNode with the specified tensor layout.\n\nDescription\n\nSquareCrossDoubleNode is a geometry type that models a double unit cell square lattice with diagonal interaction. This geometry is suitable for systems with tensors laid out according to the specified AbstractTensorsLayout. It can be used in Pegasus and Zephyr graphs.\n\n\n\n\n\n","category":"type"},{"location":"sge/params/#Layout","page":"Search parameters","title":"Layout","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"SpinGlassPEPS.jl allows for different decompositions of the PEPS network into MPOs:","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"GaugesEnergy\nEnergyGauges\nEngGaugesEng","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"For complex problems, the solution may depend on the choice of decomposition.","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/layout.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"sge/params/#Lattice-transformations","page":"Search parameters","title":"Lattice transformations","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Our package provides users with the ability to apply various transformations to the PEPS network, allowing for flexibility in tensor network manipulation. The available transformations include rotations by multiples of fracpi2 radians and reflections along different axes. Specifically, users can apply rotations and reflections around the horizontal (x), vertical (y), diagonal, and antidiagonal axes.","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"These transformations are useful when contracting PEPS or performing searches from different lattice sites. For instance, the transform parameter allows the user to rotate the quasi-2D graph, which influences the order of sweeping through local variables during branch-and-bound search. By rotating the tensor network, the search and contraction process can start from different positions on the 2D grid, improving the stability and robustness of the results.","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"In practice, searches can be performed across all eight possible transformations (four rotations and four reflections, all_lattice_transformations) of the 2D grid, comparing the energies obtained for each configuration to identify the most optimal outcome.","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"<img src=\"../images/trans.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"all_lattice_transformations\nrotation\nreflection","category":"page"},{"location":"sge/params/#SpinGlassEngine.all_lattice_transformations","page":"Search parameters","title":"SpinGlassEngine.all_lattice_transformations","text":"A tuple containing all possible lattice transformations.\n\nThis constant includes rotations at angles 0, 90, 180, and 270 degrees, as well as reflections across the x-axis, y-axis, diagonal, and antidiagonal axes.  These lattice transformations can be applied to the PEPS lattice to achieve various orientations and reflections in order to start the search on a different sites of lattice.\n\n\n\n\n\n","category":"constant"},{"location":"sge/params/#SpinGlassEngine.rotation","page":"Search parameters","title":"SpinGlassEngine.rotation","text":"rotation(θ::Int64) -> LatticeTransformation\n\n\nCreate a rotation transformation by a specified angle.\n\nArguments\n\nθ::Int: The angle of rotation, expressed in degrees. Only integral multiples of 90° can be passed as θ.\n\nReturns\n\nA LatticeTransformation object representing the specified rotation transformation.\n\n\n\n\n\n","category":"function"},{"location":"sge/params/#SpinGlassEngine.reflection","page":"Search parameters","title":"SpinGlassEngine.reflection","text":"reflection(axis::Symbol) -> LatticeTransformation\n\n\nCreate a reflection transformation along the specified axis.\n\nArguments\n\naxis::Symbol: The axis of reflection, which can be one of the following:\n:x for reflection along the x-axis.\n:y for reflection along the y-axis.\n:diag for reflection along the main diagonal.\n:antydiag for reflection along the anti-diagonal.\n\nReturns\n\nA LatticeTransformation object representing the specified reflection transformation.\n\n\n\n\n\n","category":"function"},{"location":"sge/params/#Gauge","page":"Search parameters","title":"Gauge","text":"","category":"section"},{"location":"sge/params/","page":"Search parameters","title":"Search parameters","text":"Currently only NoUpdate mode is supported.","category":"page"},{"location":"sge/search/#Branch-and-bound-search","page":"Low energy spectrum","title":"Branch and bound search","text":"","category":"section"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"Here you find the main function of the package, which is an actual solver.","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"low_energy_spectrum\nmerge_branches\nmerge_branches_blur","category":"page"},{"location":"sge/search/#SpinGlassEngine.low_energy_spectrum","page":"Low energy spectrum","title":"SpinGlassEngine.low_energy_spectrum","text":"low_energy_spectrum(\n    ctr::MpsContractor{T, R, S},\n    sparams::SearchParameters;\n    ...\n) -> Tuple{Solution, Dict{Any, Any}}\nlow_energy_spectrum(\n    ctr::MpsContractor{T, R, S},\n    sparams::SearchParameters,\n    merge_strategy;\n    ...\n) -> Tuple{Solution, Dict{Any, Any}}\nlow_energy_spectrum(\n    ctr::MpsContractor{T, R, S},\n    sparams::SearchParameters,\n    merge_strategy,\n    symmetry::Symbol;\n    no_cache\n) -> Tuple{Solution, Dict{Any, Any}}\n\n\nCompute the low-energy spectrum on a quasi-2D graph using branch-and-bound search.\n\nMerge matching configurations during branch-and-bound search going line by line. Information about excited states (droplets) is collected during merging, which allows reconstructing the low-energy spectrum. It takes as input a ctr object representing the PEPS network and the parameters for controlling its contraction, sparams specifying search parameters, merge_strategy for merging branches, and symmetry indicating any symmetry constraints. Optionally, you can disable caching using the no_cache flag. Probabilities are kept as log. Results are stored in Solution structure.\n\nArguments\n\nctr::AbstractContractor: The contractor object representing the PEPS network, which should be a subtype of AbstractContractor.\nsparams::SearchParameters: Parameters for controlling the search, including the maximum number of states and a cutoff probability.\nmerge_strategy=no_merge: (Optional) Merge strategy for branches. Defaults to no_merge.\nsymmetry::Symbol=:noZ2: (Optional) Symmetry constraint. Defaults to :noZ2. If Z2 symmetry is present in your system, use :Z2.\nno_cache=false: (Optional) If true, disables caching. Defaults to false.\n\nReturns\n\nA tuple (sol, s) containing:\n\nsol::Solution: A Solution object representing the computed low-energy spectrum.\ns::Dict: A dictionary containing Schmidt spectra for each row of the PEPS network.\n\n\n\n\n\n","category":"function"},{"location":"sge/search/#SpinGlassEngine.merge_branches","page":"Low energy spectrum","title":"SpinGlassEngine.merge_branches","text":"merge_branches(\n    ctr::MpsContractor{T};\n    merge_prob,\n    droplets_encoding\n) -> SpinGlassEngine.var\"#_merge#383\"{Symbol, NoDroplets, MpsContractor{T, R, S}} where {T, R<:SpinGlassEngine.AbstractGauge, S<:Real}\n\n\nMerge branches of a contractor based on specified merge type and droplet update strategy.\n\nThis function merges branches of a contractor (ctr) based on a specified merge type (merge_prob) and an optional droplet update strategy (droplets_encoding). It returns a function _merge that can be used to merge branches in a solution.\n\nArguments\n\nctr::MpsContractor{T}: A contractor for which branches will be merged.\nmerge_prob::Symbol=:none: (Optional) The merge type to use. Defaults to :none. Possible values are :none, :median, and :tnac4o.\ndroplets_encoding=NoDroplets(): (Optional) The droplet update strategy. Defaults to NoDroplets(). You can provide a custom droplet update strategy if needed.\n\nReturns\n\nA function _merge that can be used to merge branches in a solution.\n\nDetails\n\nThe _merge function can be applied to a Solution object to merge its branches based on the specified merge type and droplet update strategy.\n\n\n\n\n\n","category":"function"},{"location":"sge/search/#SpinGlassEngine.merge_branches_blur","page":"Low energy spectrum","title":"SpinGlassEngine.merge_branches_blur","text":"merge_branches_blur(\n    ctr::MpsContractor{T},\n    hamming_cutoff::Int64\n) -> SpinGlassEngine.var\"#_merge_blur#385\"{MpsContractor{T, R, S}, Int64, Symbol, NoDroplets} where {T, R<:SpinGlassEngine.AbstractGauge, S<:Real}\nmerge_branches_blur(\n    ctr::MpsContractor{T},\n    hamming_cutoff::Int64,\n    merge_prob::Symbol\n) -> SpinGlassEngine.var\"#_merge_blur#385\"{MpsContractor{T, R, S}, Int64, Symbol, NoDroplets} where {T, R<:SpinGlassEngine.AbstractGauge, S<:Real}\nmerge_branches_blur(\n    ctr::MpsContractor{T},\n    hamming_cutoff::Int64,\n    merge_prob::Symbol,\n    droplets_encoding\n) -> SpinGlassEngine.var\"#_merge_blur#385\"{MpsContractor{T, R, S}, Int64, Symbol} where {T, R<:SpinGlassEngine.AbstractGauge, S<:Real}\n\n\nGenerate a function for merging branches in a Gibbs network with a Hamming distance blur.\n\nArguments\n\nctr::MpsContractor{T}: The contractor representing the contracted Gibbs network.\nhamming_cutoff::Int: The Hamming distance cutoff for blur.\nmerge_prob::Symbol=:none: The merging strategy, defaults to :none.\ndroplets_encoding=NoDroplets(): Droplet update method, defaults to NoDroplets().\n\nReturns\n\nA function _merge_blur that can be used to merge branches with Hamming distance blur in a solution.\n\nDescription\n\nThis function generates a function for merging branches in a Gibbs network with Hamming distance blur. The resulting function takes a partial solution as an input and performs the merging process, considering Hamming distance constraints. It returns a new solution with the merged branches. The Hamming distance blur helps in selecting diverse states during the merging process. States with Hamming distances greater than or equal to the specified cutoff are considered distinct.\n\n\n\n\n\n","category":"function"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"Results of the branch and bound search are stored in a Solution structure.","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"Solution","category":"page"},{"location":"sge/search/#SpinGlassEngine.Solution","page":"Low energy spectrum","title":"SpinGlassEngine.Solution","text":"A struct representing a solution obtained from a low-energy spectrum search.\n\nFields\n\nenergies::Vector{<:Real}: A vector containing the energies of the discovered states.\nstates::Vector{Vector{Int}}: A vector of state configurations corresponding to the energies.\nprobabilities::Vector{<:Real}: The probabilities associated with each discovered state.\ndegeneracy::Vector{Int}: The degeneracy of each energy level.\nlargest_discarded_probability::Real: The largest probability of the largest discarded state.\ndroplets::Vector{Droplets}: A vector of droplets associated with each state.\nspins::Vector{Vector{Int}}: The spin configurations corresponding to each state.\n\nThe Solution struct holds information about the results of a low-energy spectrum search, including the energy levels, state configurations, probabilities, degeneracy, and additional details such as droplets and spin configurations. Users can access this information to analyze and interpret the search results.\n\n\n\n\n\n","category":"type"},{"location":"sge/search/#Droplet-search","page":"Low energy spectrum","title":"Droplet search","text":"","category":"section"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"SpinGlassPEPS.jl provides the capability to find not only low-energy states but also droplet excitations. To search for droplets, the SingleLayerDroplets option must be selected in the merge_branches function.","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"Droplets are identified during the optional merge_branches step, which can be invoked within the low_energy_spectrum function that runs the branch-and-bound algorithm. This search focuses on finding diverse excitations within a specific energy range above the ground state. An excitation is accepted only if its Hamming distance from any previously identified excitation exceeds a predefined threshold.","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"This behavior is controlled by two key parameters:","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"energy_cutoff: Defines the maximum allowed energy above the ground state for considering an excitation.\nhamming_cutoff: Sets the minimum Hamming distance required between excitations for them to be classified as distinct.","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"By adjusting these parameters, users can search for different excitations while ensuring that only sufficiently distinct ones are included.","category":"page"},{"location":"sge/search/","page":"Low energy spectrum","title":"Low energy spectrum","text":"SingleLayerDroplets","category":"page"},{"location":"sge/search/#SpinGlassEngine.SingleLayerDroplets","page":"Low energy spectrum","title":"SpinGlassEngine.SingleLayerDroplets","text":"A data structure representing the properties and criteria for identifying single-layer droplets in the context of the SpinGlassPEPS package.\n\nA SingleLayerDroplets object is used to specify the maximum energy, minimum size, and metric for single-layer droplets in the SpinGlassPEPS.\n\nFields\n\nmax_energy::Real: The maximum allowed excitation energy above the ground state. It is typically a real number.\nmin_size::Int: The minimum Hamming distance required between excitations for them to be considered distinct. \nmetric::Symbol: The metric used to evaluate the significance of a single-layer droplet. Default is :no_metric. :hamming treats Hamming distances as a metric.\nmode::Symbol: :Ising assumes Ising-type representation of the problem. :RMF assumes a Random Markov Field type model. Default is :Ising.\n\nConstructors\n\nSingleLayerDroplets(max_energy::Real = 1.0, min_size::Int = 1, metric::Symbol = :no_metric, mode = :Ising): Creates a new SingleLayerDroplets object with the specified maximum energy, minimum size, metric and mode.\n\n\n\n\n\n","category":"type"},{"location":"sgn/api/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"CurrentModule = SpinGlassNetworks","category":"page"},{"location":"sgn/api/#Ising-Graphs","page":"Library","title":"Ising Graphs","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"inter_cluster_edges\nprune\ncouplings","category":"page"},{"location":"sgn/api/#SpinGlassNetworks.inter_cluster_edges","page":"Library","title":"SpinGlassNetworks.inter_cluster_edges","text":"inter_cluster_edges(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},\n    cl1::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},\n    cl2::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}}\n) -> Tuple{Vector, Union{Array{Float64, 3}, Matrix}}\n\n\nReturn the dense adjacency matrix between clusters of vertices in an Ising graph.\n\nThis function computes and returns the dense adjacency matrix J between clusters of vertices represented by two Ising graphs, cl1 and cl2, within the context of the larger Ising graph ig. The adjacency matrix represents the interaction strengths between clusters of vertices, where each element (i, j) corresponds to the interaction strength between cluster i in cl1 and cluster j in cl2.\n\nArguments:\n\nig::IsingGraph{T}: The Ising graph representing a system of spins with associated interaction strengths.\ncl1::IsingGraph{T}: The first Ising graph representing one cluster of vertices.\ncl2::IsingGraph{T}: The second Ising graph representing another cluster of vertices.\n\nReturns:\n\nouter_edges::Vector{LabelledEdge}: A vector of labeled edges representing the interactions between clusters.\nJ::Matrix{T}: A dense adjacency matrix representing interaction strengths between clusters.\n\nThe function first identifies the outer edges that connect vertices between the two clusters in the context of the larger Ising graph ig. It then computes the interaction strengths associated with these outer edges and populates the dense adjacency matrix J accordingly.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.prune","page":"Library","title":"SpinGlassNetworks.prune","text":"prune(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}} where T;\n    atol\n) -> LabelledGraphs.LabelledGraph\n\n\nUsed only in MPSsearch, would be obsolete if MPSsearch uses QMps. Remove non-existing spins from an Ising graph.\n\nThis function removes non-existing spins from the given Ising graph ig. Non-existing spins are those that have zero degree (no connections to other spins) and also have an external magnetic field (h) that is not approximately equal to zero within the specified tolerance atol.\n\nArguments:\n\nig::IsingGraph: The Ising graph to be pruned.\natol::Real: The tolerance for considering the external magnetic field as zero. The default value is 1e-14.\n\nReturns:\n\npruned_graph::IsingGraph: A new Ising graph with non-existing spins removed.\n\nThe function returns a pruned version of the input Ising graph, where non-existing spins and their associated properties are removed.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.couplings","page":"Library","title":"SpinGlassNetworks.couplings","text":"couplings(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}}\n) -> Union{Array{Float64, 3}, Matrix}\n\n\nReturn the coupling strengths between vertices of an Ising graph.\n\nThis function computes and returns the coupling strengths (interaction energies) between pairs of vertices in an Ising graph ig. The coupling strengths are represented as a matrix, where each element (i, j) corresponds to the interaction energy between vertex i and vertex j.\n\nArguments:\n\nig::IsingGraph{T}: The Ising graph representing a system of spins with associated interaction strengths.\n\nReturns:\n\nJ::Matrix{T}: A matrix of coupling strengths between vertices of the Ising graph.\n\nThe function iterates over the edges of the Ising graph and extracts the interaction strengths associated with each edge, populating the J matrix accordingly.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Potts-Hamiltonian","page":"Library","title":"Potts Hamiltonian","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"split_into_clusters\ndecode_potts_hamiltonian_state\nrank_reveal\nenergy\nenergy_2site\ncluster_size\nbond_energy\nexact_cond_prob\ntruncate_potts_hamiltonian","category":"page"},{"location":"sgn/api/#SpinGlassNetworks.split_into_clusters","page":"Library","title":"SpinGlassNetworks.split_into_clusters","text":"split_into_clusters(\n    ig::LabelledGraphs.LabelledGraph{G, L},\n    assignment_rule\n) -> Dict\n\n\nGroup spins into clusters based on an assignment rule, mapping Potts Hamiltonian coordinates to groups of spins in the Ising graph. Dict(Potts Hamiltonian coordinates -> group of spins in Ising graph)\n\nArguments:\n\nig::LabelledGraph{G, L}: The Ising graph represented as a labeled graph.\nassignment_rule: A mapping that assigns Ising graph vertices to clusters based on Potts Hamiltonian coordinates.\n\nReturns:\n\nclusters::Dict{L, Vertex}: A dictionary mapping cluster identifiers to representative vertices in the Ising graph.\n\nThis function groups spins in the Ising graph into clusters based on an assignment rule.  The assignment rule defines how Potts Hamiltonian coordinates correspond to clusters of spins in the Ising graph.  Each cluster is represented by a vertex from the Ising graph.\n\nThe split_into_clusters function is useful for organizing and analyzing spins in complex spin systems, particularly in the context of Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.decode_potts_hamiltonian_state","page":"Library","title":"SpinGlassNetworks.decode_potts_hamiltonian_state","text":"decode_potts_hamiltonian_state(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    state::Vector{Int64}\n) -> Dict{Int64, Int64}\n\n\nTODO: check the order consistency over external packages.\n\nDecode a Potts Hamiltonian state into Ising graph spin values.\n\nThis function decodes a state from a Potts Hamiltonian into Ising graph spin values and  returns a dictionary mapping each Ising graph vertex to its corresponding spin value.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nstate::Vector{Int}: The state to be decoded, represented as an array of state indices for each vertex in the Potts Hamiltonian.\n\nReturns:\n\nspin_values::Dict{Int, Int}: A dictionary mapping each Ising graph vertex to its corresponding spin value.\n\nThis function assumes that the state has the same order as the vertices in the Potts Hamiltonian.  It decodes the state consistently based on the cluster assignments and spectra of the Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassTensors.rank_reveal","page":"Library","title":"SpinGlassTensors.rank_reveal","text":"rank_reveal(energy) -> Tuple{Any, Any}\nrank_reveal(energy, order) -> Tuple{Any, Any}\n\n\nReveal ranks and energies in a specified order.\n\nThis function calculates and reveals the ranks and energies of a set of states in either the 'PE' (Projector Energy) or 'EP' (Energy Projector) order.\n\nArguments:\n\nenergy: The energy values of states.\norder::Symbol: The order in which to reveal the ranks and energies. \n\nIt can be either :PE for 'Projector Energy)' order (default) or :EP for 'Energy Projector' order.\n\nReturns:\n\nIf order is :PE, the function returns a tuple (P, E) where:\nP: A permutation matrix representing projectors.\nE: An array of energy values.\nIf order is :EP, the function returns a tuple (E, P) where:\nE: An array of energy values.\nP: A permutation matrix representing projectors.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.energy","page":"Library","title":"SpinGlassNetworks.energy","text":"energy(σ::Vector, ig::IsingGraph)\n\nCalculates the energy of a state in an Ising graph.\n\nThis function calculates the energy of a given state in the context of an Ising graph.  The energy is computed based on the interactions between spins and their associated biases.\n\nArguments:\n\nσ::AbstractArray{State}: An array representing the state of spins in the Ising graph.\nig::IsingGraph: The Ising graph defining the interactions and biases.\n\nReturns:\n\nVector{Float64}: An array of energy values for each state.\n\n\n\n\n\nenergy(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},\n    ig_state::Dict{Int64, Int64}\n) -> Any\n\n\nCalculates the energy of a state in an Ising graph.\n\nThis function computes the energy of a given state in the context of an Ising graph.  The energy is calculated based on the interactions between spins and their associated biases.\n\nArguments:\n\nig::IsingGraph{T}: The Ising graph defining the interactions and biases.\nig_state::Dict{Int, Int}: A dictionary mapping spin indices to their corresponding states.\n\nReturns:\n\nT: The energy of the state in the Ising graph.\n\n\n\n\n\nenergy(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    σ::Dict{T, Int64}\n) -> Any\n\n\nCalculate the energy of a Potts Hamiltonian state.\n\nThis function calculates the energy of a given state in a Potts Hamiltonian.  The state is represented as a dictionary mapping each Ising graph vertex to its corresponding spin value.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nσ::Dict{T, Int}: A dictionary mapping Ising graph vertices to their spin values.\n\nReturns:\n\nen_potts_h::Float64: The energy of the state in the Potts Hamiltonian.\n\nThis function computes the energy by summing the energies associated with individual  clusters and the interaction energies between clusters.  It takes into account the cluster spectra and projectors stored in the Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.energy_2site","page":"Library","title":"SpinGlassNetworks.energy_2site","text":"energy_2site(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    i::Int64,\n    j::Int64\n) -> Any\n\n\nCalculate the interaction energy between two nodes in a Potts Hamiltonian.\n\nThis function computes the interaction energy between two specified nodes in a Potts Hamiltonian, represented as a labeled graph.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\ni::Int: The index of the first site.\nj::Int: The index of the second site.\n\nReturns:\n\nint_eng::AbstractMatrix{T}: The interaction energy matrix between the specified sites.\n\nThe function checks if there is an interaction edge between the two sites (i, j) in both directions (i -> j and j -> i).  If such edges exist, it retrieves the interaction energy matrix, projectors, and calculates the interaction energy.  If no interaction edge is found, it returns a zero matrix.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.cluster_size","page":"Library","title":"SpinGlassNetworks.cluster_size","text":"cluster_size(net::AbstractGibbsNetwork{S, T}, v) -> Any\n\n\nDetermine the cluster size associated with a specific vertex in the Gibbs network.\n\nArguments\n\nnet::AbstractGibbsNetwork{S, T}: Gibbs network containing the Potts Hamiltonian.\nv::S: Vertex for which the cluster size is to be determined.\n\nReturns\n\nsize::Int: Number of states in the local energy spectrum associated with the specified vertex.\n\n\n\n\n\ncluster_size(\n    potts_hamiltonian::LabelledGraphs.LabelledGraph{S, T},\n    vertex\n) -> Any\n\n\nGet the size of a cluster in a Potts Hamiltonian.\n\nThis function returns the size (number of states) of a cluster in a Potts Hamiltonian, represented as a labeled graph.\n\nArguments:\n\npotts_hamiltonian::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nvertex::T: The vertex (cluster) for which the size is to be determined.\n\nReturns:\n\nsize::Int: The number of states in the specified cluster.\n\nThe function retrieves the spectrum associated with the specified cluster and returns the length of the energy vector in that spectrum.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.bond_energy","page":"Library","title":"SpinGlassNetworks.bond_energy","text":"bond_energy(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    potts_h_u::NTuple{N, Int64},\n    potts_h_v::NTuple{N, Int64},\n    σ::Int64\n) -> Any\n\n\nCalculate the bond energy between two clusters in a Potts Hamiltonian.\n\nThis function computes the bond energy between two specified clusters (cluster nodes) in a Potts Hamiltonian, represented as a labeled graph.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\npotts_h_u::NTuple{N, Int64}: The coordinates of the first cluster.\npotts_h_v::NTuple{N, Int64}: The coordinates of the second cluster.\nσ::Int: Index for which the bond energy is calculated.\n\nReturns:\n\nenergies::AbstractVector{T}: The bond energy vector between the two clusters for the specified index.\n\nThe function checks if there is an edge between the two clusters (u -> v and v -> u).  If such edges exist, it retrieves the bond energy matrix and projectors and calculates the bond energy.  If no bond edge is found, it returns a zero vector.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.exact_cond_prob","page":"Library","title":"SpinGlassNetworks.exact_cond_prob","text":"exact_cond_prob(\n    potts_hamiltonian::LabelledGraphs.LabelledGraph{S, T},\n    beta,\n    target_state::Dict\n) -> Any\n\n\nCalculate the exact conditional probability of a target state in a Potts Hamiltonian.\n\nThis function computes the exact conditional probability of a specified target state in a Potts Hamiltonian, represented as a labelled graph.\n\nArguments:\n\npotts_hamiltonian::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nbeta: The inverse temperature parameter.\ntarget_state::Dict: A dictionary specifying the target state as a mapping of cluster vertices to Ising spin values.\n\nReturns:\n\nprob::Float64: The exact conditional probability of the target state.\n\nThe function generates all possible states for the clusters in the Potts Hamiltonian,  calculates their energies, and computes the probability distribution based on the given inverse temperature parameter.  It then calculates the conditional probability of the specified target state by summing the probabilities of states that match the target state.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.truncate_potts_hamiltonian","page":"Library","title":"SpinGlassNetworks.truncate_potts_hamiltonian","text":"truncate_potts_hamiltonian(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    states::Dict\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\n\n\nTruncate a Potts Hamiltonian based on specified states.\n\nThis function truncates a given Potts Hamiltonian by selecting a subset of states for each cluster based on the provided states dictionary.  The resulting truncated Hamiltonian contains only the selected states for each cluster.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nstates::Dict: A dictionary specifying the states to be retained for each cluster.\n\nReturns:\n\nnew_potts_h::LabelledGraph{MetaDiGraph}: The truncated Potts Hamiltonian with reduced states.\n\nThe function creates a new Potts Hamiltonian new_potts_h with the same structure as the input potts_h.  It then updates the spectrum of each cluster in new_potts_h by selecting the specified states from the original spectrum.  Additionally, it updates the interactions and projectors between clusters based on the retained states.  The resulting new_potts_h represents a truncated version of the original Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Belief-propagation","page":"Library","title":"Belief propagation","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"local_energy\ninteraction_energy\nget_neighbors\nMergedEnergy\nupdate_message\nmerge_vertices_potts_h\nprojector\nSparseCSC","category":"page"},{"location":"sgn/api/#SpinGlassNetworks.local_energy","page":"Library","title":"SpinGlassNetworks.local_energy","text":"local_energy(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    v::Tuple{Int64, Int64, Int64}\n) -> Any\n\n\nGet the local energy associated with a vertex in a Potts Hamiltonian.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nv::NTuple{3, Int64}: The coordinates of the vertex for which the local energy is requested.\n\nReturns:\n\nlocal_energy::AbstractVector: An abstract vector containing the local energy values associated with the specified vertex.\n\nThis function retrieves the local energy values associated with a given vertex v in a Potts Hamiltonian graph potts_h.  If the vertex exists in the graph and has associated energy values, it returns those values; otherwise, it returns a vector of zeros.\n\nThe local energy values are typically obtained from the spectrum associated with the vertex.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.interaction_energy","page":"Library","title":"SpinGlassNetworks.interaction_energy","text":"interaction_energy(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    v::Tuple{Int64, Int64, Int64},\n    w::Tuple{Int64, Int64, Int64}\n) -> Any\n\n\nGet the interaction energy between two vertices in a Potts Hamiltonian.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nv::NTuple{3, Int64}: The coordinates of the first vertex.\nw::NTuple{3, Int64}: The coordinates of the second vertex.\n\nReturns:\n\ninteraction_energy::AbstractMatrix: An abstract matrix containing the interaction energy values between the specified vertices.\n\nThis function retrieves the interaction energy values between two vertices, v and w, in a Potts Hamiltonian graph potts_h.  If there is a directed edge from w to v, it returns the corresponding energy values;  if there is a directed edge from v to w, it returns the transpose of the energy values;  otherwise, it returns a matrix of zeros. The interaction energy values represent the energy associated with the interaction or connection between the two vertices.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.get_neighbors","page":"Library","title":"SpinGlassNetworks.get_neighbors","text":"get_neighbors(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    vertex::NTuple{N, T} where {N, T}\n) -> Vector{Any}\n\n\nReturns the neighbors of a given vertex in a Potts Hamiltonian.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nvertex::NTuple: The vertex for which neighbors are to be retrieved.\n\nReturns:\n\nneighbors::Vector{Tuple}: A vector of tuples representing the neighbors of the specified vertex. \n\nEach tuple contains the following information:\n\ndst_node::T: The neighboring vertex.\npv::Matrix: The projector associated with the edge connecting the vertex and its neighbor.\nen::Real: The energy associated with the edge connecting the vertex and its neighbor.\n\nThis function retrieves the neighbors of a given vertex in a Potts Hamiltonian graph. It iterates through the edges of the graph and identifies edges connected to the specified vertex.  For each neighboring edge, it extracts and returns the neighboring vertex, the associated projector, and the energy.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.MergedEnergy","page":"Library","title":"SpinGlassNetworks.MergedEnergy","text":"A custom Julia struct representing energy values in a merged format for use in specific calculations.\n\nFields:\n\ne11::AbstractMatrix{T}\ne12::AbstractMatrix{T}\ne21::AbstractMatrix{T}\ne22::AbstractMatrix{T}\n\nThe MergedEnergy struct is used to represent energy values that are organized in a merged format.  This format is often utilized in certain computational tasks, where energy values are categorized based on combinations of left and right factors.\n\nEach field of the MergedEnergy struct stores energy values as an AbstractMatrix{T} of type T,  where T is a subtype of the Real abstract type.  The specific organization and interpretation of these energy values depend on the context in which this struct is used.    \n\n\n\n\n\n","category":"type"},{"location":"sgn/api/#SpinGlassNetworks.update_message","page":"Library","title":"SpinGlassNetworks.update_message","text":"update_message(\n    E_bond::AbstractArray,\n    message::Vector,\n    beta::Real\n) -> Any\n\n\nUpdate a message using energy values and temperature.\n\nArguments:\n\nE_bond::AbstractArray: An array of energy values associated with a bond or interaction.\nmessage::Vector: The input message vector to be updated.\nbeta::Real: The temperature parameter controlling the influence of energy values.\n\nReturns:\n\nupdated_message::Vector: The updated message vector after applying the energy-based update.\n\nThis function takes energy values E_bond associated with a bond or interaction, an input message vector message,  and a temperature parameter beta. It updates the message by first adjusting the energy values relative to their minimum value,  exponentiating them with a negative sign and scaling by beta, and then multiplying them element-wise with the input message.\n\nThe result is an updated message that reflects the influence of energy values and temperature.\n\n\n\n\n\nupdate_message(\n    E_bond::MergedEnergy,\n    message::Vector,\n    beta::Real\n) -> Any\n\n\nUpdate a message using energy values and temperature in a merged energy format.\n\nArguments:\n\nE_bond::MergedEnergy: An instance of the MergedEnergy type representing energy values for the bond or interaction.\nmessage::Vector: The input message vector to be updated.\nbeta::Real: The temperature parameter controlling the influence of energy values.\n\nReturns:\n\nupdated_message::Vector: The updated message vector after applying the energy-based update.\n\nThis function takes energy values E_bond in a merged energy format, an input message vector message,  and a temperature parameter beta. It updates the message based on the energy values and temperature using a specified algorithm.\n\nThe MergedEnergy type represents energy values in a merged format, and the function processes these values  accordingly to update the message vector.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.merge_vertices_potts_h","page":"Library","title":"SpinGlassNetworks.merge_vertices_potts_h","text":"merge_vertices_potts_h(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    β::Real,\n    node1::Tuple{Int64, Int64, Int64},\n    node2::Tuple{Int64, Int64, Int64}\n) -> Tuple{MergedEnergy, Any, Any}\n\n\nMerge two vertices in a Potts Hamiltonian to create a single merged vertex.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nβ::Real: The temperature parameter controlling the influence of energy values.\nnode1::NTuple{3, Int64}: The coordinates of the first vertex to merge.\nnode2::NTuple{3, Int64}: The coordinates of the second vertex to merge.\n\nReturns:\n\nmerged_energy::MergedEnergy: An instance of the MergedEnergy type representing the merged energy values.\npl::AbstractVector: The merged left projector.\npr::AbstractVector: The merged right projector.\n\nThis function merges two vertices in a Potts Hamiltonian graph potts_h to create a single merged vertex.  The merging process combines projectors and energy values associated with the original vertices based on  the provided temperature parameter β.\n\nThe merged energy values, left projector pl, and right projector pr are computed based on the interactions  between the original vertices and their respective projectors.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.projector","page":"Library","title":"SpinGlassNetworks.projector","text":"projector(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    v::NTuple{N, Int64},\n    w::NTuple{N, Int64}\n) -> Any\n\n\nGet the projector associated with an edge between two vertices in a Potts Hamiltonian.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nv::NTuple{N, Int64}: The coordinates of one of the two vertices connected by the edge.\nw::NTuple{N, Int64}: The coordinates of the other vertex connected by the edge.\n\nReturns:\n\np::AbstractVector: An abstract vector representing the projector associated with the specified edge.\n\nThis function retrieves the projector associated with an edge between two vertices, v and w,  in a Potts Hamiltonian graph potts_h.  If there is a directed edge from w to v, it returns the index of right projector (:ipr);  if there is a directed edge from v to w, it returns the index of left projector (:ipl).  If no edge exists between the vertices, it returns a vector of ones.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.SparseCSC","page":"Library","title":"SpinGlassNetworks.SparseCSC","text":"SparseCSC(\n    _::Type{R<:Real},\n    p::Vector{Int64}\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv<:Real\n\n\nCreate a sparse column-compressed (CSC) matrix with specified column indices and values.\n\nArguments:\n\n::Type{R}: The element type of the sparse matrix (e.g., Float64, Int64).\np::Vector{Int64}: A vector of column indices for the non-zero values.\n\nReturns:\n\nsparse_matrix::SparseMatrixCSC{R}: A sparse column-compressed matrix with non-zero values at specified columns.\n\nThis constructor function creates a sparse column-compressed (CSC) matrix of element type R based on the provided  column indices p and values. The resulting matrix has non-zero values at the specified column indices, while all other elements are zero. The SparseCSC constructor is useful for creating sparse matrices with specific column indices and values efficiently.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Projectors","page":"Library","title":"Projectors","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"PoolOfProjectors\nget_projector!\nadd_projector!\nempty!","category":"page"},{"location":"sgn/api/#SpinGlassTensors.PoolOfProjectors","page":"Library","title":"SpinGlassTensors.PoolOfProjectors","text":"PoolOfProjectors is a data structure for managing projectors associated with Ising model sites. It allows efficient storage and retrieval of projectors based on their indices and provides support for different computational devices.\n\nFields:\n\ndata::Dict{Symbol, Dict{Int, Proj{T}}}: A dictionary that stores projectors associated with different\n\ncomputational devices (:CPU, :GPU, etc.). The inner dictionary maps site indices to projectors.\n\ndefault_device::Symbol: A symbol representing the default computational device for projectors in the pool.\nsizes::Dict{Int, Int}: A dictionary that maps site indices to the maximum projector size for each site.\n\nConstructors:\n\nPoolOfProjectors(data::Dict{Int, Dict{Int, Vector{T}}}) where T: Create a PoolOfProjectors with initial data for projectors.\n\nThe data is provided as a dictionary that maps site indices to projectors stored in different computational devices. The sizes dictionary is automatically populated based on the maximum projector size for each site.\n\nPoolOfProjectors{T}() where T: Create an empty PoolOfProjectors with no projectors initially stored.\n\n\n\n\n\n","category":"type"},{"location":"sgn/api/#SpinGlassTensors.get_projector!","page":"Library","title":"SpinGlassTensors.get_projector!","text":"get_projector!(\n    lp::PoolOfProjectors{T<:Integer},\n    index::Int64,\n    device::Symbol\n) -> Union{Vector{T}, CUDA.CuVector{T}, CUDA.DenseCuVector{T}} where T<:Integer\n\n\nTODO This is version for only one GPU\n\nRetrieve or create a projector from the PoolOfProjectors associated with a specific device.\n\nThis function retrieves a projector from the PoolOfProjectors if it already exists. If the projector does not exist in the pool, it creates a new one and stores it for future use on the specified computational device.\n\nArguments:\n\nlp::PoolOfProjectors{T}: The PoolOfProjectors object containing projectors.\nindex::Int: The index of the projector to retrieve or create.\ndevice::Symbol: The computational device on which the projector should be stored or retrieved (e.g., :CPU, :GPU).\n\nReturns:\n\nProj{T}: The projector of type T associated with the specified index and device.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassTensors.add_projector!","page":"Library","title":"SpinGlassTensors.add_projector!","text":"add_projector!(\n    lp::PoolOfProjectors{T<:Integer},\n    p::Union{Vector{T}, CUDA.CuArray{T, 1}} where T\n) -> Int64\n\n\nAdd a projector to the PoolOfProjectors and associate it with an index.\n\nThis function adds a projector p to the PoolOfProjectors. The PoolOfProjectors stores projectors based on their computational device (e.g., CPU or GPU) and assigns a unique index to each projector. The index can be used to retrieve the projector later using get_projector!.\n\nArguments:\n\nlp::PoolOfProjectors{T}: The PoolOfProjectors object to which the projector should be added.\np::Proj: The projector to be added to the pool. The type of the projector Proj should match the type T specified in the PoolOfProjectors.\n\nReturns:\n\nInt: The unique index associated with the added projector in the pool.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Base.empty!","page":"Library","title":"Base.empty!","text":"empty!(\n    lp::PoolOfProjectors,\n    device::Symbol\n) -> Union{Nothing, Dict{Int64, Union{Vector{T}, CUDA.CuVector{T}, CUDA.DenseCuVector{T}}} where T<:Integer}\n\n\nEmpty the pool of projectors associated with a specific computational device.\n\nThis function removes all projectors stored on the specified computational device, freeing up memory resources.\n\nArguments:\n\nlp::PoolOfProjectors: The PoolOfProjectors object containing projectors.\ndevice::Symbol: The computational device for which projectors should be emptied (e.g., :CPU, :GPU).\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Spectrum","page":"Library","title":"Spectrum","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"Spectrum\nmatrix_to_integers\ngibbs_tensor\nbrute_force","category":"page"},{"location":"sgn/api/#SpinGlassNetworks.Spectrum","page":"Library","title":"SpinGlassNetworks.Spectrum","text":"A Spectrum represents the energy spectrum of a system.\n\nA Spectrum consists of energy levels, their corresponding states, and integer representations of the states.\n\nFields:\n\nenergies::Vector{<:Real}: An array of energy levels.\nstates::AbstractArray{State}: An array of states.\nstates_int::Vector{Int}: An array of integer representations of states.\n\nConstructors:\n\nSpectrum(energies, states, states_int): Creates a Spectrum object with the specified energy levels, states, and integer representations.\nSpectrum(energies, states): Creates a Spectrum object with the specified energy levels and states, automatically generating integer representations.\n\n\n\n\n\n","category":"type"},{"location":"sgn/api/#SpinGlassNetworks.matrix_to_integers","page":"Library","title":"SpinGlassNetworks.matrix_to_integers","text":"matrix_to_integers(\n    matrix::Vector{<:Vector{<:Integer}}\n) -> Any\n\n\nConverts a matrix of binary vectors to their integer representations.\n\nThis function takes a matrix of binary vectors, where each row represents a binary vector, and converts them into their corresponding integer representations.\n\nArguments:\n\nmatrix::Vector{Vector{T}}: A matrix of binary vectors.\n\nReturns:\n\nVector{Int}: An array of integer representations of the binary vectors.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.gibbs_tensor","page":"Library","title":"SpinGlassNetworks.gibbs_tensor","text":"gibbs_tensor(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}}\n) -> Any\ngibbs_tensor(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},\n    β\n) -> Any\n\n\nComputes the Gibbs tensor for an Ising graph at a given inverse temperature.\n\nThis function calculates the Gibbs tensor for an Ising graph at a specified inverse temperature (β).  The Gibbs tensor represents the conditional probabilities of states given the inverse temperature and the Ising graph.\n\nArguments:\n\nig::IsingGraph{T}: The Ising graph for which the Gibbs tensor is computed.\nβ::T (optional): The inverse temperature parameter. Default is 1.\n\nReturns:\n\nMatrix{T}: A matrix representing the Gibbs tensor with conditional probabilities.    \n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.brute_force","page":"Library","title":"SpinGlassNetworks.brute_force","text":"brute_force(\n    ig::LabelledGraphs.LabelledGraph{MetaGraphs.MetaGraph{Int64, T}},\n    ::Val{:CPU};\n    num_states\n) -> Spectrum\n\n\nTODO only one of bruteforce and fullspectrum should remain\n\nPerforms brute-force calculation of the lowest-energy states and their energies for an Ising graph.\n\nThis function exhaustively computes the lowest-energy states and their corresponding energies for an Ising graph. The calculation is done using brute-force enumeration, making it feasible only for small Ising graphs.\n\nArguments:\n\nig::IsingGraph{T}: The Ising graph for which the lowest-energy states are computed.\n::Val{:CPU}: A value indicating that the computation is performed on the CPU.\nnum_states::Int (optional): The maximum number of lowest-energy states to calculate. Default is 1.\n\nReturns:\n\nSpectrum: A Spectrum object containing the lowest-energy states and their energies.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Truncate","page":"Library","title":"Truncate","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"truncate_potts_hamiltonian_1site_BP\ntruncate_potts_hamiltonian_2site_energy\nselect_numstate_best","category":"page"},{"location":"sgn/api/#SpinGlassNetworks.truncate_potts_hamiltonian_1site_BP","page":"Library","title":"SpinGlassNetworks.truncate_potts_hamiltonian_1site_BP","text":"truncate_potts_hamiltonian_1site_BP(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    num_states::Int64;\n    beta,\n    tol,\n    iter\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\n\n\nTruncates a Potts Hamiltonian using belief propagation (BP) for a single site cluster.\n\nThis function employs belief propagation (BP) to approximate the most probable states and energies for a Potts Hamiltonian associated with a single-site cluster. It then truncates the Potts Hamiltonian based on the most probable states.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nnum_states::Int: The maximum number of most probable states to keep.\nbeta::Real (optional): The inverse temperature parameter for the BP algorithm. Default is 1.0.\ntol::Real (optional): The tolerance value for convergence in BP. Default is 1e-10.\niter::Int (optional): The maximum number of BP iterations. Default is 1.\n\nReturns:\n\nLabelledGraph{S, T}: A truncated Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.truncate_potts_hamiltonian_2site_energy","page":"Library","title":"SpinGlassNetworks.truncate_potts_hamiltonian_2site_energy","text":"truncate_potts_hamiltonian_2site_energy(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    num_states::Int64\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\n\n\nTruncate a Potts Hamiltonian based on 2-site energy states.\n\nThis function truncates a Potts Hamiltonian by considering 2-site energy states and selecting the most probable states  to keep. It computes the energies for all 2-site combinations and selects the states that maximize the probability.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labeled graph.\nnum_states::Int: The maximum number of most probable states to keep.\n\nReturns:\n\nLabelledGraph{S, T}: A truncated Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.select_numstate_best","page":"Library","title":"SpinGlassNetworks.select_numstate_best","text":"select_numstate_best(E, sx, num_states) -> Tuple{Any, Any}\n\n\nSelect a specified number of best states based on energy.\n\nThis function selects a specified number of best states from a list of energies based on energy values in two nodes of Potts Hamiltonian.  It fine-tunes the selection to ensure that the resulting states have the expected number.\n\nArguments:\n\nE::Vector{Real}: A vector of energy values.\nsx::Int: The size of the Potts Hamiltonian for one of the nodes.\nnum_states::Int: The desired number of states to select.\n\nReturns:\n\nTuple{Vector{Int}, Vector{Int}}: A tuple containing two vectors of indices, ind1 and ind2, \n\nwhich represent the selected states for two nodes of a Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#Auxiliary-Functions","page":"Library","title":"Auxiliary Functions","text":"","category":"section"},{"location":"sgn/api/","page":"Library","title":"Library","text":"zephyr_to_linear\nload_openGM","category":"page"},{"location":"sgn/api/#SpinGlassNetworks.zephyr_to_linear","page":"Library","title":"SpinGlassNetworks.zephyr_to_linear","text":"zephyr_to_linear(\n    m::Int64,\n    t::Int64,\n    q::NTuple{5, Int64}\n) -> Int64\n\n\nRewriten from Dwave-networkx m - Grid parameter for the Zephyr lattice. t - Tile parameter for the Zephyr lattice; must be even.\n\n\n\n\n\n","category":"function"},{"location":"sgn/api/#SpinGlassNetworks.load_openGM","page":"Library","title":"SpinGlassNetworks.load_openGM","text":"load_openGM(fname::String) -> Dict\nload_openGM(\n    fname::String,\n    Nx::Union{Nothing, Integer}\n) -> Dict\nload_openGM(\n    fname::String,\n    Nx::Union{Nothing, Integer},\n    Ny::Union{Nothing, Integer}\n) -> Dict\n\n\nLoads some factored graphs written in openGM format. Assumes rectangular lattice.\n\nArgs:     filename (str): a path to file with factor graph in openGM format.     ints Nx, Ny: it is assumed that graph if forming an :math:Nx \times N_y lattice with         nearest-neighbour interactions only.\n\nReturns:    dictionary with factors and funcitons defining the energy functional.\n\n\n\n\n\n","category":"function"},{"location":"sgn/#SpinGlassNetworks","page":"SpinGlassNetworks","title":"SpinGlassNetworks","text":"","category":"section"},{"location":"sgn/","page":"SpinGlassNetworks","title":"SpinGlassNetworks","text":"A Julia package for building and interacting with Ising spin glass models in context of tensor networks. Part of SpinGlassPEPS package.","category":"page"},{"location":"sgn/bp/#Belief-propagation","page":"Local dimensional reduction","title":"Belief propagation","text":"","category":"section"},{"location":"sgn/bp/","page":"Local dimensional reduction","title":"Local dimensional reduction","text":"The SpinGlassPEPS.jl package is capable of handling clusters with up to 24 spins, which results in a total of 2^24 degrees of freedom per cluster. This makes the contraction of the tensor network generated from such a Hamiltonian computationally expensive. To address this, SpinGlassPEPS.jl offers an optional feature for local dimensional reduction of cluster degrees of freedom by selectively choosing the most probable states within each cluster. This method reduces the dimensionality of the problem by focusing on the most relevant and energetically favorable states. The marginal probabilities of each Potts variable are approximated using the Loopy Belief Propagation (LBP) algorithm.","category":"page"},{"location":"sgn/bp/","page":"Local dimensional reduction","title":"Local dimensional reduction","text":"potts_hamiltonian_2site\nbelief_propagation\ntruncate_potts_hamiltonian_2site_BP","category":"page"},{"location":"sgn/bp/#SpinGlassNetworks.potts_hamiltonian_2site","page":"Local dimensional reduction","title":"SpinGlassNetworks.potts_hamiltonian_2site","text":"potts_hamiltonian_2site(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    beta::Real\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\n\n\nConstructs a Potts Hamiltonian for a given Potts Hamiltonian with a 2-site cluster approximation used in Pegasus graph.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labelled graph.\nbeta::Real: The inverse temperature parameter for the 2-site cluster Hamiltonian construction.\n\nReturns:\n\nnew_potts_h::LabelledGraph{MetaDiGraph}: A new labelled graph representing the 2-site cluster Hamiltonian.\n\nThis function constructs a Potts Hamiltonian potts_h by applying a 2-site cluster approximation.  It combines and merges vertices and edges of the original graph to create a simplified representation of the Hamiltonian.\n\nThe resulting new_potts_h graph represents the 2-site cluster Hamiltonian with simplified interactions between clusters.  The energy values, projectors, and spectra associated with the new vertices and edges are computed based on  the provided temperature parameter beta.\n\n\n\n\n\n","category":"function"},{"location":"sgn/bp/#SpinGlassNetworks.belief_propagation","page":"Local dimensional reduction","title":"SpinGlassNetworks.belief_propagation","text":"belief_propagation(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    beta::Real;\n    tol,\n    iter\n) -> Dict{Any, Any}\n\n\nPerform loopy belief propagation on a given Potts Hamiltonian.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labelled graph.\nbeta::Real: The inverse temperature parameter for the belief propagation algorithm.\ntol::Real (optional, default=1e-6): The convergence tolerance. The algorithm stops when the message updates between iterations are smaller than this value.\niter::Int (optional, default=1): The maximum number of iterations to perform.\n\nReturns:\n\nbeliefs::Dict: A dictionary where keys are vertices of Potts Hamiltonian, and values are the \n\nresulting beliefs after belief propagation.\n\nThe function implements loopy belief propagation on the given Potts Hamiltonian potts_h to calculate beliefs for each vertex. Belief propagation is an iterative algorithm that computes beliefs by passing messages between vertices and edges of the Potts Hamiltonian.  The algorithm continues until convergence or until the specified maximum number of iterations is reached. The beliefs are computed based on the inverse temperature parameter beta, which controls the influence of energy values on the beliefs.\n\n\n\n\n\n","category":"function"},{"location":"sgn/bp/#SpinGlassNetworks.truncate_potts_hamiltonian_2site_BP","page":"Local dimensional reduction","title":"SpinGlassNetworks.truncate_potts_hamiltonian_2site_BP","text":"truncate_potts_hamiltonian_2site_BP(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    beliefs::Dict,\n    num_states::Int64;\n    ...\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\ntruncate_potts_hamiltonian_2site_BP(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    beliefs::Dict,\n    num_states::Int64,\n    result_folder::String;\n    ...\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\ntruncate_potts_hamiltonian_2site_BP(\n    potts_h::LabelledGraphs.LabelledGraph{S, T},\n    beliefs::Dict,\n    num_states::Int64,\n    result_folder::String,\n    inst::String;\n    beta\n) -> LabelledGraphs.LabelledGraph{MetaGraphs.MetaDiGraph{Int64, Float64}}\n\n\nTruncate a Potts Hamiltonian based on 2-site belief propagation states.\n\nThis function truncates a Potts Hamiltonian by considering 2-site belief propagation states and selecting the most probable states  to keep. It computes the beliefs for all 2-site combinations and selects the states that maximize the probability.\n\nArguments:\n\npotts_h::LabelledGraph{S, T}: The Potts Hamiltonian represented as a labelled graph.\nbeliefs::Dict: A dictionary containing belief values for 2-site interactions.\nnum_states::Int: The maximum number of most probable states to keep.\nbeta::Real (optional): The inverse temperature parameter (default is 1.0).\n\nReturns:\n\nLabelledGraph{S, T}: A truncated Potts Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"sgt/#SpinGlassTensor","page":"User guide","title":"SpinGlassTensor","text":"","category":"section"},{"location":"sgt/","page":"User guide","title":"User guide","text":"Part of SpinGlassPEPS package. It constitutes the basis for the preparation of tensors and operations on them.","category":"page"},{"location":"sgt/","page":"User guide","title":"User guide","text":"info: Info\nWe don't expect the user to interact with this package, as it is more of a \"back-end\" type. Nevertheless, we provide API references should the need arise.","category":"page"},{"location":"sgt/","page":"User guide","title":"User guide","text":"This section of the package encompasses supplementary functionalities that serve as support for the main solver. It includes the creation and manipulation of tensors, with a particular emphasis on implementing Matrix Product States (MPS) and Matrix Product Operators (MPO). ","category":"page"},{"location":"sgt/api/#Library","page":"API Reference","title":"Library","text":"","category":"section"},{"location":"sgt/api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"sgt/api/","page":"API Reference","title":"API Reference","text":"CurrentModule = SpinGlassTensors","category":"page"},{"location":"sgt/api/#Additional-methods-for-Base-and-LinearAlgebra","page":"API Reference","title":"Additional methods for Base and LinearAlgebra","text":"","category":"section"},{"location":"sgt/api/","page":"API Reference","title":"API Reference","text":"left_nbrs_site\nright_nbrs_site\nproject_ket_on_bra","category":"page"},{"location":"sgt/api/#SpinGlassTensors.left_nbrs_site","page":"API Reference","title":"SpinGlassTensors.left_nbrs_site","text":"Largest x in sites: x < site\n\n\n\n\n\n","category":"function"},{"location":"sgt/api/#SpinGlassTensors.right_nbrs_site","page":"API Reference","title":"SpinGlassTensors.right_nbrs_site","text":"Smallest x in sites: x > site\n\n\n\n\n\n","category":"function"},{"location":"sgt/api/#SpinGlassTensors.project_ket_on_bra","page":"API Reference","title":"SpinGlassTensors.project_ket_on_bra","text":"|    |    |   LE – M – RE    |    |    |      – B –\n\n\n\n\n\n|    |    |   LE – M – RE    |    |    |      – B –\n\n\n\n\n\nLE -     - RE    |    |    |      – B –\n\n\n\n\n\n|      |   LE –– RE –\n\n\n\n\n\n","category":"function"},{"location":"sgt/api/#MPS","page":"API Reference","title":"MPS","text":"","category":"section"},{"location":"sgt/api/#Compresions-and-Contractions","page":"API Reference","title":"Compresions and Contractions","text":"","category":"section"},{"location":"sgt/api/","page":"API Reference","title":"API Reference","text":"update_env_left\nupdate_env_right\nupdate_reduced_env_right","category":"page"},{"location":"sgt/api/#SpinGlassTensors.update_env_left","page":"API Reference","title":"SpinGlassTensors.update_env_left","text":"    -- A --\n  |    |\n\nL = LE – M –       |    |         – B –\n\n\n\n\n\n    -- A --\n  |    |\n\nL = LE – M –       |    |         – B –\n\n\n\n\n\n    -- A --\n  |    |\n\nL = LE    |       |    |         – B –\n\n\n\n\n\n    -- A --\n  |    |\n\nL = LE       |\n\n\n\n\n\n","category":"function"},{"location":"sgt/api/#SpinGlassTensors.update_env_right","page":"API Reference","title":"SpinGlassTensors.update_env_right","text":"  -- A --\n     |    |\n\nR =  – M – RE          |    |       – B –\n\n\n\n\n\n  -- A --\n     |    |\n\nR =  – M – RE          |    |       – B –\n\n\n\n\n\n  -- A --\n     |    |\n\nR =     |    RE          |    |       – B –\n\n\n\n\n\n  -- A --\n     |    |\n\nR =      –- RE               |\n\n\n\n\n\n","category":"function"},{"location":"sgt/api/#SpinGlassTensors.update_reduced_env_right","page":"API Reference","title":"SpinGlassTensors.update_reduced_env_right","text":"  K\n  |\n\n– M – RE       |    |    – B –-\n\n\n\n\n\n","category":"function"},{"location":"sge/peps/#Constructing-PEPS-tensor-network","page":"Tensor network","title":"Constructing PEPS tensor network","text":"","category":"section"},{"location":"sge/peps/","page":"Tensor network","title":"Tensor network","text":"After creating the Potts Hamiltonian, we can turn it into a PEPS tensor network as shown in the Section Brief description of the algorithm. ","category":"page"},{"location":"sge/peps/","page":"Tensor network","title":"Tensor network","text":"PEPSNetwork","category":"page"},{"location":"sge/peps/#SpinGlassEngine.PEPSNetwork","page":"Tensor network","title":"SpinGlassEngine.PEPSNetwork","text":"Construct a Projected Entangled Pair States (PEPS) network.\n\nArguments\n\nm::Int: Number of rows in the PEPS lattice.\nn::Int: Number of columns in the PEPS lattice.\npotts_hamiltonian::LabelledGraph: Potts Hamiltonian representing the Hamiltonian.\ntransformation::LatticeTransformation: Transformation of the PEPS lattice, as it can be rotated or reflected. \ngauge_type::Symbol=:id: Type of gauge to initialize (default is identity).\n\nType Parameters\n\nT <: AbstractGeometry: Type of node used within the PEPS tensor network. It can be SquareSingleNode, SquareDoubleNode, KingSingleNode, SquareCrossDoubleNode.\nS <: AbstractSparsity: Type of sparsity for the PEPS tensors: Dense or Sparse.\nR <: Real`: The numeric precision type for real values (e.g., Float64).\n\nReturns\n\nAn instance of PEPSNetwork{T, S, R}.\n\n\n\n\n\n","category":"type"},{"location":"sge/peps/#Basic-example-of-usage","page":"Tensor network","title":"Basic example of usage","text":"","category":"section"},{"location":"sge/peps/","page":"Tensor network","title":"Tensor network","text":"using SpinGlassEngine, SpinGlassTensors, SpinGlassNetworks\nusing SpinGlassExhaustive\n\nm, n, t = 5, 5, 4\nonGPU = true\ninstance = \"$(@__DIR__)/../../src/instances/square_diagonal/5x5/diagonal.txt\"\n\nStrategy = Zipper\ntransform = rotation(0)\nLayout = GaugesEnergy\nSparsity = Sparse\nR = Float64\n\nig = ising_graph(instance)\npotts_h = potts_hamiltonian(\n    ig,\n    spectrum = full_spectrum,\n    cluster_assignment_rule=super_square_lattice((m, n, t))\n)\n\nnet = PEPSNetwork{KingSingleNode{Layout}, Sparsity, R}(m, n, potts_h, transform)","category":"page"},{"location":"examples/#More-examples","page":"More examples","title":"More examples","text":"","category":"section"},{"location":"examples/","page":"More examples","title":"More examples","text":"In this section, we present a few examples demonstrating the functionality of SpinGlassPEPS.jl. These examples showcase how to construct tensor networks, work with Potts Hamiltonians, and perform branch and bound search for optimization problems.","category":"page"},{"location":"examples/","page":"More examples","title":"More examples","text":"The full list of examples, including detailed code and visualizations, can be found on the GitHub.","category":"page"},{"location":"examples/#Inpainting","page":"More examples","title":"Inpainting","text":"","category":"section"},{"location":"examples/","page":"More examples","title":"More examples","text":"This example demonstrates how to solve an inpainting problem  using SpinGlassPEPS.jl. ","category":"page"},{"location":"examples/","page":"More examples","title":"More examples","text":"using SpinGlassPEPS\n\nfunction bench_inpaining(::Type{T}, β::Real, max_states::Integer, bond_dim::Integer) where {T}\n\tpotts_h= potts_hamiltonian(instance, 120, 120)\n\n\tparams = MpsParameters{T}(; bond_dim = bond_dim, method = :svd)\n\tsearch_params = SearchParameters(; max_states = max_states)\n\tnet = PEPSNetwork{SquareSingleNode{GaugesEnergy}, Sparse, T}(120, 120, potts_h, rotation(0))\n\tctr = MpsContractor{SVDTruncate, NoUpdate, T}(net, params; onGPU = true, beta = convert(Float64, β), graduate_truncation = true)\n    droplets = SingleLayerDroplets(; max_energy = 100, min_size = 100 , metric = :hamming, mode=:RMF)\n\tmerge_strategy = merge_branches(ctr; merge_prob = :none, droplets_encoding = droplets)\n\n\tsol, info = low_energy_spectrum(ctr, search_params, merge_strategy)\n    ground = sol.energies[begin]\n\n    println(\"Best energy found: $(ground)\")\n    sol\nend\nsol = bench_inpaining(Float64, 6, 64, 4)","category":"page"},{"location":"examples/#Key-steps","page":"More examples","title":"Key steps","text":"","category":"section"},{"location":"examples/","page":"More examples","title":"More examples","text":"The function potts_hamiltonian generates a Hamiltonian for a 120x120 grid.\nA PEPS tensor network is initialized with the RMF instance, using Sparse tensors and a SquareSingleNode representation.\nThe contraction is performed using parameters saved in MpsContractor. We use SVDTruncate to optimize boundary MPSs. The onGPU flag enables GPU acceleration.\nThe function low_energy_spectrum searches for low-energy configurations with branch merging and droplet search.","category":"page"},{"location":"examples/","page":"More examples","title":"More examples","text":"info: Data visualisation\nTo fully interpret the results, the data might be visualized. This example generates raw data, but a full visualization guide is available on GitHub","category":"page"},{"location":"examples/#D-Wave-Pegasus","page":"More examples","title":"D-Wave Pegasus","text":"","category":"section"},{"location":"examples/","page":"More examples","title":"More examples","text":"This example demonstrates how to perform an optimization on the Pegasus lattice with 216 spins using SpinGlassPEPS.jl. It is a computationally demanding example that involves truncating cluster states from 2^24 to the 2^16  most probable states. The example requires GPU support for efficient computation and may take several minutes to complete.","category":"page"},{"location":"examples/","page":"More examples","title":"More examples","text":"using SpinGlassPEPS\n\nfunction run_pegasus_bench(::Type{T}; topology::NTuple{3, Int}) where {T}\n    m, n, t = topology\n    instance = \"$(@__DIR__)/instances/P4_CBFM-P.txt\"\n    results_folder = \"$(@__DIR__)/lbp\"\n    isdir(results_folder) || mkdir(results_folder)\n\n    lattice = pegasus_lattice(topology)\n\n    potts_h = potts_hamiltonian(\n        ising_graph(instance),\n        spectrum = full_spectrum,\n        cluster_assignment_rule = lattice,\n    )\n\n    potts_h = truncate_potts_hamiltonian(potts_h, T(2), 2^16, results_folder, \"P4_CBFM-P\"; tol=1e-6, iter=2)\n\n    params = MpsParameters{T}(bond_dim=16, num_sweeps=1)\n    search_params = SearchParameters(max_states=2^8, cutoff_prob=1e-4)\n\n    best_energies = T[]\n\n    for transform in all_lattice_transformations\n        net = PEPSNetwork{SquareCrossDoubleNode{GaugesEnergy}, Sparse, T}(m, n, potts_h, transform)\n        ctr = MpsContractor(Zipper, net, params; onGPU=true, beta=T(2), graduate_truncation=true)\n\n        droplets = SingleLayerDroplets(max_energy=10, min_size=54, metric=:hamming)\n        merge_strategy = merge_branches(ctr; merge_prob=:none, droplets_encoding=droplets)\n\n        sol, _ = low_energy_spectrum(ctr, search_params, merge_strategy)\n        sol2 = unpack_droplets(sol, T(2))\n\n        println(\"Droplet energies: $(sol2.energies)\")\n\n        push!(best_energies, sol.energies[1])\n        clear_memoize_cache()\n    end\n\n    ground = best_energies[1]\n    @assert all(ground .≈ best_energies)\n    println(\"Best energy found: $(best_energies[1])\")\nend\n\nT = Float64\n@time run_pegasus_bench(T; topology = (3, 3, 3))","category":"page"},{"location":"examples/#Key-steps-2","page":"More examples","title":"Key steps","text":"","category":"section"},{"location":"examples/","page":"More examples","title":"More examples","text":"The Potts Hamiltonian is constructed from an Ising graph build based on the input file (P4_CBFM-P.txt).\nThe Hamiltonian is then truncated using a truncatepottshamiltonian function, keeping only the most probable states, with the number of states in every cluster reduced from 2^24 to 2^16 . This truncation significantly reduces the numerical cost of the subsequent tensor network contraction. Note that, this is optional step.\nA PEPS (Projected Entangled Pair States) network is created with a SquareCrossDoubleNode and GaugesEnergy for representing the system on the lattice. \nStructures such as MpsParameters and  SearchParameters stores the information about e.g. a predefined bond dimension and a number of states considered during the search.\nMpsContractor stores information needed in subsequent tensor network contraction. The contraction is performed using a Zipper method for optimizing boundary MPS. \nThe function low_energy_spectrum searches for low-energy configurations with branch merging and droplet search. We are searching for droplets with an energy max_energy higher than the ground state by at most 10, and the minimal size min_size of 54.","category":"page"},{"location":"algorithm/#Brief-description-of-the-algorithm","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"SpinGlassPEPS.jl is a package developed for finding low-energy configurations in Ising type optimization problems [1, 2]. By leveraging Projected Entangled Pair States (PEPS) tensor networks, the algorithm efficiently represents the Boltzmann distribution [5], enabling heuristic exploration of quasi-2D problem spaces. In particular, this approach is tailored to tackle the challenges posed by graph geometries relevant to modern quantum annealing devices, such as the Pegasus and Zephyr graphs employed by D-Wave systems.","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"This section builds upon the broader methodology outlined in the analysis of tensor-network limitations in solving large-scale Ising problems on Pegasus and Zephyr geometries​ [1].","category":"page"},{"location":"algorithm/#Problem-representation","page":"Brief description of the algorithm","title":"Problem representation","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"Let us consider a classical Ising Hamiltonian","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"H(underlines_N) =  sum_langle i jrangle in mathcalE J_ij s_i s_j + sum_i =1^N J_ii s_i","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"where underlines_N denotes a particular configuration of N binary variables s_i=pm 1. More generally, we  mark sub-configurations of the first k variables as underlines_k = (s_1 s_2 ldots s_k). Non-zero couplings J_ij in mathbbR are input parameters of a given problem instance and form a connectivity graph mathcalE.","category":"page"},{"location":"algorithm/#Graphs-with-large-unit-cells","page":"Brief description of the algorithm","title":"Graphs with large unit cells","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"We focus on the systems with quasi-2D interaction graphs, in particular those of the relevance to present-day quantum annealers, such as Pegasus and Zephyr. In the picture below, we mark group of spins which naturally form unit cells with red shapes.","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"info: Info\nMore information on lattice geometries you can find in section Lattice Geometries.","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"<img src=\"../images/lattice.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"In order to adress graph geometries with large unit cells using tensor networks, we represent the problem as a Potts Hamiltonian. To that end we group together sets of binary variables into clusters with a reduced number of variables of larger dimensions. In this framework Ising problem translates to:","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"H(underlinex_barN) = sum_langle mnrangle in mathcalF E_x_m x_n + sum_n=1^barN E_x_n","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"where mathcalF forms a 2D graph, in which we indicate nearest-neighbour interactions with blue lines, and diagonal connections with green lines in the picture above. In this example, x_n takes d values with  d=2^4 for square diagonal, d=2^24 for Pegasus and 2^16 for Zephyr geometry (in the maximal case when all qubits are operational).  E_x_n is an intra-node energy of the corresponding binary-variables configuration, and E_x_n x_m is inter-node energy.","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"<img src=\"../images/clustering.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"algorithm/#Calculating-conditional-probabilities","page":"Brief description of the algorithm","title":"Calculating conditional probabilities","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"We assume that finding low energy states is equivalent to finding most probable states. We represent the probability distribution as a PEPS tensor network.","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"    p(underlinex_barN) = frac1Z exp(-beta H(underlinex_barN))","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"where Z is a partition function and beta is inverse temperature. Once the PEPS tensor network is constructed, the probability distribution can be obtained by approximately contracting the tensor network, which is described in more details in subsection Tensor network contractions for optimization problems. Subsequently, we select only the configurations with the highest marginal probabilities","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"    p(underlinex_n+1) = p(x_n+1  underlinex_n) times p(underlinex_n)","category":"page"},{"location":"algorithm/#Branch-and-bound-search","page":"Brief description of the algorithm","title":"Branch and bound search","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"By employing branch and bound search strategy iteratively row after row, we address the solution of Hamiltonian in the terms of conditional probabilities. This approach enables the identification of most probable (low-energy) spin configurations within the problem space. ","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"<img src=\"../images/bb.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"algorithm/#Tensor-network-contractions-for-optimization-problems","page":"Brief description of the algorithm","title":"Tensor network contractions for optimization problems","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"Branch and bound search relies on the calculation of conditional probabilities. To that end, we use tensor network techniques. Conditional probabilities are obtained by contracting a PEPS tensor network, which, although an NP-hard problem, can be computed approximately. The approach utilized in SpinGlassPEPS.jl is boundary matrix product state (MPS) illustrated in the figure below. Tensors in the pink box are approximated by matrix product state with truncated bond dimension. In each step, a product of boundary MPS from the previous row and the matrix product operator (MPO) formed by the next row of tensors, is approximated by a new boundary MPS of limited bond dimension. ","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"info: Info\nIn SpinGlassPEPS.jl one can use two types of approximating boundary MPS. More information you can find in the section Search parameters.","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"<img src=\"../images/prob.png\" width=\"150%\" class=\"center\"/>","category":"page"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"<img src=\"../images/explain.png\" width=\"75%\" class=\"center\"/>","category":"page"},{"location":"algorithm/#References-and-Related-works","page":"Brief description of the algorithm","title":"References & Related works","text":"","category":"section"},{"location":"algorithm/","page":"Brief description of the algorithm","title":"Brief description of the algorithm","text":"\"Limitations of tensor network approaches for optimization and sampling: A comparison against quantum and classical Ising machines\" A.M. Dziubyna, T. Śmierzchalski, B. Gardas, M.M. Rams, M. Mohseni arXiv:2411.16431\n\"SpinGlassPEPS.jl: low-energy solutions for near-term quantum annealers\" T. Śmierzchalski, A.M. Dziubyna, K. Jałowiecki, Z. Mzaouali, Ł. Pawela, B. Gardas, M.M. Rams []\n\"Approximate optimization, sampling, and spin-glass droplet discovery with tensor networks\" Marek M. Rams, Masoud Mohseni, Daniel Eppens, Konrad Jałowiecki, Bartłomiej Gardas Phys. Rev. E 104, 025308 (2021) or arXiv version arXiv:1811.06518\ntnac4o\n\"Two-Dimensional Tensor Product Variational Formulation\" T. Nishino, Y. Hieida, K. Okunishi, N. Maeshima, Y. Akutsu, A. Gendiar, Progr. Theor. Phys. 105, 409 (2001)","category":"page"},{"location":"sgn/ising/#Ising-model","page":"Ising graph","title":"Ising model","text":"","category":"section"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"The Ising model is a mathematical model used to describe the behavior of interacting particles, such as atoms or molecules, in a magnetic field. In the Ising model, each particle is represented as a binary variable s_i that can take on the values of either +1 or -1. The total energy of the system is given by the Hamiltonian:","category":"page"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"H =  sum_(ij) in mathcalE J_ij s_i s_j + sum_i h_i s_i","category":"page"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"where J_ij is the coupling constant between particles i and j, h_i is the external magnetic field at particle i, and the sum is taken over all pairs of particles and all particles in the system mathcalE, respectively.","category":"page"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"In SpinGlassPEPS.jl package, an Ising graph can be created using the command ising_graph.","category":"page"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"ising_graph","category":"page"},{"location":"sgn/ising/#SpinGlassNetworks.ising_graph","page":"Ising graph","title":"SpinGlassNetworks.ising_graph","text":"ising_graph(\n    ::Type{T},\n    inst::Union{String, Dict};\n    scale,\n    rank_override\n) -> LabelledGraphs.LabelledGraph{S} where S<:(MetaGraphs.MetaGraph{Int64})\n\n\nCreate an Ising graph from interaction data.\n\nThis function creates an Ising graph (LabelledGraph) from interaction data provided in the form of an inst argument. The Ising graph represents a system of spins, where each spin is associated with a vertex,  and interactions between spins are represented as edges with corresponding weights.\n\nArguments:\n\n::Type{T}: The type of the edge weights, typically Float64 or Float32.\ninst::Instance: Interaction data, which can be either a file path to a CSV file or a collection of triples (i, j, J) representing interactions between spins, where i and j are spin indices, and J is the interaction strength.\nscale::Real: The scale factor establishes the convention in the Hamiltonian (default is 1).\nrank_override::Dict: A dictionary specifying the rank (number of states) for each vertex. If not provided, a default rank of 2 is used for all vertices.\n\nReturns:\n\nig::IsingGraph{T}: The Ising graph (LabelledGraph) representing the spin system.\n\nThe function reads interaction data and constructs an Ising graph ig. It assigns interaction strengths to edges between spins and optionally scales them by the scale factor. 'Scale' option allows for the change of convention in the Hamiltonian. The rank_override dictionary can be used to specify the rank (number of states) for individual vertices, allowing customization of the Ising model. Convention: H = scale * sum{i, j} (J{ij} * si * sj + J{ii} * si)\n\n\n\n\n\n","category":"function"},{"location":"sgn/ising/#Simple-example","page":"Ising graph","title":"Simple example","text":"","category":"section"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"In this simple example below we show how to create Ising graph of a instance given as txt file in a format (i, j, Jij). The resulting graph has vertices corresponding to positions of spins in the system and edges defining coupling strength between spins. Each vertex contains information about local field.","category":"page"},{"location":"sgn/ising/","page":"Ising graph","title":"Ising graph","text":"using SpinGlassNetworks\n# Create Ising instance\ninstance = \"$(@__DIR__)/../../src/instances/square_diagonal/5x5/diagonal.txt\"\nig = ising_graph(instance)\n\n# View graph properties\n@show biases(ig), couplings(ig)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author = \"Tomasz Śmierzchalski, Anna M. Dziubyna, Konrad Jałowiecki, Zakaria Mzaouali, Łukasz Pawela, Bartłomiej Gardas and Marek M. Rams\"","category":"page"},{"location":"#Welcome-to-SpinGlassPEPS.jl-documentation!","page":"Home","title":"Welcome to SpinGlassPEPS.jl documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to SpinGlassPEPS.jl, a open-source Julia package designed for heuristically solving Ising-type optimization problems defined on quasi-2D lattices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Star us on GitHub!\nIf you have found this library useful, please consider starring the GitHub repository. This gives us an accurate lower bound of the satisfied users.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this section we will provide a condensed overview of the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinGlassPEPS.jl is a collection of Julia packages bundled together under a single package SpinGlassPEPS.jl. It can be installed using the Julia package manager for Julia v1.10. Inside the Julia REPL, type ] to enter the Pkg REPL mode and then run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; \nPkg.add(\"SpinGlassPEPS\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package SpinGlassPEPS.jl includes three independent sub-packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinGlassEngine.jl -  serves as the core package, consisting of routines for executing the branch-and-bound method (with the ability to leverage the problem's locality) for a given Potts instance. It also includes capabilities for reconstructing the low-energy spectrum from identified localized excitations and provides a tensor network constructor. \nSpinGlassNetworks.jl - facilitates the generation of an Ising graph from a given instance using a set of standard inputs (e.g., instances compatible with the Ocean environment provided by D-Wave) and supports clustering to create effective Potts Hamiltonians.\nSpinGlassTensors.jl - offers essential tools for creating and manipulating tensors that constitute the PEPS network, with support for both CPU and GPU utilization. It manages core operations on tensor networks, including contraction, using the boundary Matrix Product State approach. This package primarily functions as a backend, and users generally do not interact with it directly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"images/algorithm.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"#Our-goals","page":"Home","title":"Our goals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpinGlassPEPS.jl was created to heuristically solve Ising-type optimization problems defined on quasi-2D lattices. This package combines advanced heuristics to address optimization challenges and employs tensor network contractions to compute conditional probabilities to identify the most probable states according to the Gibbs distribution. SpinGlassPEPS.jl is a tool for reconstructing the low-energy spectrum of Ising spin glass Hamiltonians and some more general Potts Hamiltonians. Beyond energy computations, the package offers insights into spin configurations, associated probabilities, and retains the largest discarded probability during the branch and bound optimization procedure. Notably, SpinGlassPEPS.jl goes beyond ground states, introducing a feature for reconstructing the low-energy spectrum from identified localized excitations in the system, called spin-glass droplets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"images/result.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"#Citing-SpinGlassPEPS.jl","page":"Home","title":"Citing SpinGlassPEPS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SpinGlassPEPS.jl for academic research and wish to cite it, please use the following papers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Article describing this package and code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{SpinGlassPEPS.jl,\n    author = {Tomasz \\'{S}mierzchalski and Anna Maria Dziubyna and Konrad Ja\\l{}owiecki and Zakaria\n    Mzaouali and {\\L}ukasz Pawela and Bart\\l{}omiej Gardas and Marek M. Rams},\n    title = {{SpinGlassPEPS.jl}: low-energy solutions for near-term quantum annealers},\n    journal = {},\n    year = {},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Article describing in details used algorithms and containing extensive benchmarks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{SpinGlassPEPS, \n    author = {Anna Maria Dziubyna and Tomasz \\'{S}mierzchalski and Bart\\l{}omiej Gardas and Marek M. Rams and Masoud Mohseni},\n    title = {Limitations of tensor network approaches for optimization and sampling: A comparison against quantum and classical {Ising} machines},\n    year = {2024},\n    eprint={2411.16431},\n    archivePrefix={arXiv},\n    primaryClass={cond-mat.dis-nn},\n    doi = {10.48550/arXiv.2411.16431} \n}","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are always welcome:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please report any issues and bugs that you encounter in Issues\nQuestions about SpinGlassPEPS.jl can be asked by directly opening up an Issue on its GitHub page\nIf you plan to contribute new features, extensions, bug fixes, etc, please first open an issue and discuss the feature with us.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Report the bug\nFilling an issue to report a bug, counterintuitive behavior, or even to request a feature is extremely valuable in helping us prioritize what to work on, so don't hestitate.","category":"page"},{"location":"sgn/lattice/#Lattice-geometries","page":"Lattice geometries","title":"Lattice geometries","text":"","category":"section"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"The Ising graph allowed for loading instances directly from a file and translating them into a graph. The next step towards constructing the tensor network is to build a lattice, based on which we will transform the Ising graph into a Potts Hamiltonian. Within the SpinGlassNetworks.jl package, users have the flexibility to construct three types of lattice geometries, each tailored to specific needs. ","category":"page"},{"location":"sgn/lattice/#Super-square-lattice","page":"Lattice geometries","title":"Super square lattice","text":"","category":"section"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"The super_square_lattice geometry represents a square lattice with nearest neighbors interactions (horizontal and vertical interactions between unit cells) and next nearest neighbor interactions (diagonal interactions). Unit cells depicted on the schematic picture below as red ellipses can consist of multiple spins. This geometry allows for an exploration of spin interactions beyond the traditional square lattice framework. ","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"<img src=\"../images/sd.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"In SpinGlassPEPS.jl solver, a grid of this type can be loaded using the command super_square_lattice.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"super_square_lattice","category":"page"},{"location":"sgn/lattice/#SpinGlassNetworks.super_square_lattice","page":"Lattice geometries","title":"SpinGlassNetworks.super_square_lattice","text":"super_square_lattice(\n    size::NTuple{5, Int64}\n) -> Dict{Int64, Tuple{Int64, Int64}}\n\n\nCreate a mapping from Ising graph coordinates to a super square lattice arrangement. Variable number of Ising graph -> cluster hamiltonian coordinate system\n\nThis function generates a mapping that relates Ising graph coordinates to a super square lattice arrangement.  The super square lattice is defined by the size of five dimensions: (m, um, n, un, t), where m is the number of columns, n is the number of rows and t denotes the number of spins stored in the cluster.\n\nArguments:\n\nsize::NTuple{5, Int}: A tuple specifying the size of the super square lattice in five dimensions: (m, um, n, un, t).\n\nReturns:\n\ncoord_map::Dict: A dictionary that maps Ising graph coordinates to the corresponding lattice coordinates.\n\nThe size tuple represents the dimensions of the super square lattice. The function creates a dictionary where  ising graph coordinates are associated with their corresponding lattice coordinates.\n\n\n\n\n\nsuper_square_lattice(\n    size::Tuple{Int64, Int64, Int64}\n) -> Dict{Int64, Tuple{Int64, Int64}}\n\n\nCreate a mapping from Ising graph coordinates to a simplified super square lattice arrangement.\n\nThis function generates a mapping that relates Ising graph coordinates to a simplified super square lattice arrangement.  The simplified super square lattice is defined by the size of three dimensions: (m, n, t), where m is the number of columns,  n is the number of rows and t denotes the number of spins stored in the cluster.\n\nArguments:\n\nsize::NTuple{3, Int}: A tuple specifying the size of the simplified super square lattice in three dimensions: (m, n, t), where m is number of columns, n number of rows and t denotes number of spins in cluster.\n\nReturns:\n\ncoord_map::Dict: A dictionary that maps Ising graph coordinates to the corresponding lattice coordinates.\n\nThe size tuple represents the dimensions of the simplified super square lattice.  The function internally adds the required dimensions (1, 1) to make it compatible with the super_square_lattice function, which deals with five dimensions.\n\n\n\n\n\n","category":"function"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"Below you find simple example of usage super_square_latttice function.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"using SpinGlassEngine, SpinGlassNetworks, LabelledGraphs\n\ninstance = \"$(@__DIR__)/../../src/instances/square_diagonal/5x5/diagonal.txt\"\nig = ising_graph(instance)\n\nm = 5\nn = 5\nt = 4\n\npotts_h = potts_hamiltonian(\n    ig,\n    cluster_assignment_rule = super_square_lattice((m, n, t))\n)\n\nprintln(\"Number of nodes in original instance: \", length(LabelledGraphs.vertices(ig)), \"\\n\", \" Number of nodes in Potts Hamiltonian: \", length(LabelledGraphs.vertices(potts_h)))","category":"page"},{"location":"sgn/lattice/#Pegasus-graphs","page":"Lattice geometries","title":"Pegasus graphs","text":"","category":"section"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"The Pegasus graph is a type of graph architecture used in quantum computing systems, particularly in the quantum annealing machines developed by D-Wave Systems. It is designed to provide a grid of qubits with specific connectivity patterns optimized for solving certain optimization problems. Futer details can be found here.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"<img src=\"../images/peg.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"In SpinGlassPEPS.jl solver, a grid of this type can be loaded using the command pegasus_lattice.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"pegasus_lattice","category":"page"},{"location":"sgn/lattice/#SpinGlassNetworks.pegasus_lattice","page":"Lattice geometries","title":"SpinGlassNetworks.pegasus_lattice","text":"pegasus_lattice(\n    size::Tuple{Int64, Int64, Int64}\n) -> Dict{Int64, Tuple{Int64, Int64, Int64}}\n\n\nCreate a mapping from Ising graph coordinates to Pegasus lattice coordinates.\n\nThis function generates a mapping that relates Ising graph coordinates to Pegasus lattice coordinates  based on the specified size of the Pegasus lattice in three dimensions: (m, n, t).\n\nArguments:\n\nsize::NTuple{3, Int}: A tuple specifying the size of the Pegasus lattice in three dimensions: (m, n, t), where m is number of columns, n number of rows and t denotes number of spins in the cluster. One Pegasus cluster consists of 24 spins. Convention: t is already divided by 8, so t=3 for Pegasus lattice.\n\nReturns:\n\ncoord_map::Dict: A dictionary that maps Ising graph coordinates to the corresponding Pegasus lattice coordinates.\n\nThe pegasus_lattice allows you to build the graph relevant for D-Wave Pegasus architecture.\n\n\n\n\n\n","category":"function"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"Below you find simple example of usage pegasus_latttice function.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"using SpinGlassEngine, SpinGlassNetworks, LabelledGraphs\n\n# load Pegasus instance and create Ising graph\ninstance = \"$(@__DIR__)/../../src/instances/pegasus_random/P4/RAU/001_sg.txt\"\nig = ising_graph(instance)\n\n# Loaded instance is compatible with Pegasus geometry. Next we create Potts hamiltonian based on Pegasus geometry. \nm = 3\nn = 3\nt = 3\n\npotts_h = potts_hamiltonian(\n    ig,\n    cluster_assignment_rule = pegasus_lattice((m, n, t))\n)\n\nprintln(\"Number of nodes in original instance: \", length(LabelledGraphs.vertices(ig)), \"\\n\", \" Number of nodes in Potts Hamiltonian: \", length(LabelledGraphs.vertices(potts_h))/2)","category":"page"},{"location":"sgn/lattice/#Zephyr-graphs","page":"Lattice geometries","title":"Zephyr graphs","text":"","category":"section"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"The Zephyr graph is a type of graph architecture used in quantum computing systems, particularly in the quantum annealing machines developed by D-Wave Systems. Futer details can be found here.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"<img src=\"../images/zep.png\" width=\"200%\" class=\"center\"/>","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"In SpinGlassPEPS.jl solver, a grid of this type can be loaded using the command zephyr_lattice.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"zephyr_lattice","category":"page"},{"location":"sgn/lattice/#SpinGlassNetworks.zephyr_lattice","page":"Lattice geometries","title":"SpinGlassNetworks.zephyr_lattice","text":"zephyr_lattice(\n    size::Tuple{Int64, Int64, Int64}\n) -> Dict{Int64, Tuple{Int64, Int64, Int64}}\n\n\nCreate a mapping from Ising graph coordinates to Zephyr lattice coordinates.\n\nThis function generates a mapping that relates Ising graph coordinates to Zephyr lattice  coordinates based on the specified size of the Zephyr lattice in three dimensions: (m, n, t).\n\nArguments:\n\nsize::NTuple{3, Int}: A tuple specifying the size of the Zephyr lattice in three dimensions: (m, n, t), where m is double number of columns, n double number of rows and t denotes number of spins in cluster. One full Zephyr cluster consists of 16 spins. Convention: t is already divided by 4, so t=4 for Zephyr lattice. E.g. to create 3x3x16 Zephyr lattice, you should use m=6, n=6, t=4.\n\nReturns:\n\ncoord_map::Dict: A dictionary that maps Ising graph coordinates to the corresponding Zephyr lattice coordinates.\n\nThe zephyr_lattice allows you to build the graph relevant for D-Wave Zephyr architecture.\n\n\n\n\n\n","category":"function"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"Below you find simple example of usage zephyr_latttice function.","category":"page"},{"location":"sgn/lattice/","page":"Lattice geometries","title":"Lattice geometries","text":"using SpinGlassEngine, SpinGlassNetworks, LabelledGraphs\n\n# load instance and create Ising graph\ninstance = \"$(@__DIR__)/../../src/instances/zephyr_random/Z3/RAU/001_sg.txt\"\nig = ising_graph(instance)\n\n# Loaded instance is compatible with Zephyr geometry. Next we create Potts hamiltonian based on Zephyr geometry. \nm = 6\nn = 6\nt = 4\n\npotts_h = potts_hamiltonian(\n    ig,\n    cluster_assignment_rule = zephyr_lattice((m, n, t))\n)\n\nprintln(\"Number of nodes in original instance: \", length(LabelledGraphs.vertices(ig)))","category":"page"}]
}
