<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · SpinGlassPEPS.jl</title><meta name="title" content="Getting started · SpinGlassPEPS.jl"/><meta property="og:title" content="Getting started · SpinGlassPEPS.jl"/><meta property="twitter:title" content="Getting started · SpinGlassPEPS.jl"/><meta name="description" content="Documentation for SpinGlassPEPS.jl."/><meta property="og:description" content="Documentation for SpinGlassPEPS.jl."/><meta property="twitter:description" content="Documentation for SpinGlassPEPS.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpinGlassPEPS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Basic-example"><span>Basic example</span></a></li><li><a class="tocitem" href="#Expected-output"><span>Expected output</span></a></li></ul></li><li><a class="tocitem" href="../algorithm/">Brief description of the algorithm</a></li><li><span class="tocitem">SpinGlassNetworks</span><ul><li><a class="tocitem" href="../sgn/userguide/">User guide</a></li><li><a class="tocitem" href="../sgn/ising/">Ising graph</a></li><li><a class="tocitem" href="../sgn/lattice/">Lattice geometries</a></li><li><a class="tocitem" href="../sgn/clh/">Clustered hamiltonian</a></li><li><a class="tocitem" href="../sgn/bp/">Local dimensional reduction</a></li><li><a class="tocitem" href="../sgn/api/">API Reference for auxiliary functions</a></li></ul></li><li><span class="tocitem">SpinGlassEngine</span><ul><li><a class="tocitem" href="../sge/guide/">User Guide</a></li><li><a class="tocitem" href="../sge/peps/">Tensor network</a></li><li><a class="tocitem" href="../sge/params/">Search parameters</a></li><li><a class="tocitem" href="../sge/search/">Low energy spectrum</a></li><li><a class="tocitem" href="../sge/api/">API Reference for auxiliary functions</a></li></ul></li><li><span class="tocitem">SpinGlassTensors</span><ul><li><a class="tocitem" href="../sgt/">User guide</a></li><li><a class="tocitem" href="../sgt/mpo/">Matrix Product States and Matrix Product Operations</a></li><li><a class="tocitem" href="../sgt/api/">API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/euro-hpc-pl/SpinGlassPEPS.jl/blob/master/docs/src/intro.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h1><p>Before providing the documentation of the offered functionality, it is good to demonstrate exactly what the package does.</p><h2 id="Basic-example"><a class="docs-heading-anchor" href="#Basic-example">Basic example</a><a id="Basic-example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-example" title="Permalink"></a></h2><p>In this example, we demonstrate how to use the <code>SpinGlassPEPS.jl</code> package to obtain a low-energy spectrum for a spin glass Hamiltonian defined on a square lattice with diagonal interactions on 100 spins. Let&#39;s discuss the main steps of the code.</p><p>The first line</p><pre><code class="language- hljs">instance = &quot;$(@__DIR__)/../src/instances/square_diagonal/5x5/diagonal.txt&quot;</code></pre><p>reads instance that is provided in txt format.</p><p>Next line defines the problem size</p><pre><code class="language- hljs">m, n, t = 5, 5, 4</code></pre><p>In this example, number of columns and row, <code>m</code> and <code>n</code> respectively, is equal 5. Parameter <code>t</code> tells how many spins are creating a cluster.</p><p><code>SpinGlassPEPS.jl</code> enables to perform calculations not only on CPU, but also on GPU. If you want to switch on GPU mode, then type</p><pre><code class="language- hljs">onGPU = true</code></pre><p>The next part of the code contains parmeters which user should provide before starting the calculations. The main parameter is temperature, given as the inverse of temperature.</p><pre><code class="language- hljs">β = 1.0</code></pre><p>A higher <code>β</code> lets us focus more on low-energy states, but it might make the numerical stability of tensor network contraction a bit shaky. Figuring out the best β depends on the problem, and we might need to try different values in experiments for various instances.</p><p>Subsequently, the user can input parameters that will be utilized in exploring the state space, such as the cutoff probability for terminating the search <code>δp</code> and the maximum number of states considered during the search (<code>num_states</code>).</p><pre><code class="language- hljs"># Search parameters
δp = 0 # The cutoff probability for terminating the search
num_states = 20 # The maximum number of states to be considered during the search</code></pre><p>Another group of parameters describes the method of contracting the network using the boundary MPS-MPO approach.</p><pre><code class="language- hljs">bond_dim = 12 # Bond dimension
max_num_sweeps = 10 # Maximal number of sweeps during variational compression
tol_var = 1E-16 # The tolerance for the variational solver used in MPS optimization
tol_svd = 1E-16 # The tolerance used in singular value decomposition (SVD)
iters_svd = 2 # The number of iterations to perform in SVD computations
iters_var = 1 # The number of iterations for variational optimization
dtemp_mult = 2 # A multiplier for the bond dimension
method = :psvd_sparse # The SVD method to use</code></pre><p>We can also choose the arrangement of tensors forming the MPO (<code>Layout</code>) and the strategy to optimize boundary MPS (<code>Strategy</code>). The user also has the decision-making authority on whether the MPS will be truncated in a gradual manner (<code>graduate_truncation</code>). We can initiate our algorithm from various starting points. The parameter responsible for this choice is <code>transform</code>, which allows for the rotation and reflection of the tensor network, consequently altering the starting point for the exploration. Last, but not least, the user can also choose whether to use the <code>Sparse</code> or <code>Dense</code> mode. This choice should depend on the size of the unit cell in the specific problem at hand.</p><pre><code class="language- hljs">Layout = GaugesEnergy # Way of decomposition of the network into MPO
Strategy = Zipper # Strategy to optimize MPS
graduate_truncation = :graduate_truncate # Gradually truncates MPS
transform = rotation(0) # Transformation of the lattice
Sparsity = Sparse # Use sparse mode, when tensors are large</code></pre><p>The parameters provided by the user are then stored in data structures <code>MpsParameters</code> and <code>SearchParameters</code>.</p><pre><code class="language- hljs">params = MpsParameters(bond_dim, tol_var, max_num_sweeps, 
                        tol_svd, iters_svd, iters_var, dtemp_mult, method)
search_params = SearchParameters(num_states, δp)</code></pre><p>User can not only calculate the ground state of the given problem, but also find exitations in the system. To achieve this, the user must specify the energy range <code>eng</code> above the ground state within which the solver should search for low-energy excitations. The <code>SpinGlassPEPS.jl</code> algorithm seeks large independent excitations, meaning states that are far from each other in a Hamming sense, so states that differ from each other by at least a <code>hamming_dist</code> distance – this distance is provided by the user.</p><pre><code class="language- hljs">eng = 10
hamming_dist = 10</code></pre><p>With this prepared set of parameters, we are ready for the actual computations. The first step is to create the Ising graph. In the Ising graph, nodes are formed by the spin positions, and interactions between them are represented by the edges.</p><pre><code class="language- hljs">ig = ising_graph(instance)</code></pre><p>Next, we need to translate our problem into a clustered problem, where several spins form an unit cell. This is achieved through the use of the <code>clustered_hamiltonian</code> function.</p><pre><code class="language- hljs">cl_h = clustered_hamiltonian(
    ig,
    spectrum = full_spectrum,
    cluster_assignment_rule=super_square_lattice((m, n, t))
)</code></pre><p>The next part of the code builds the PEPS tensor network compatible with previously defined clustered Hamiltonian.</p><pre><code class="language- hljs">net = PEPSNetwork{SquareCrossSingleNode{Layout}, Sparsity}(m, n, cl_h, transform)</code></pre><p>In order to start calculating conditional probabilities we need to define <code>MpsContractor</code> structure which stores the elements and information necessary for contracting the tensor network and, consequently, calculating the probability of a given configuration. </p><pre><code class="language- hljs">ctr = MpsContractor{Strategy, NoUpdate}(net, [β], graduate_truncation, params; onGPU=onGPU)</code></pre><p>Finally the call</p><pre><code class="language- hljs">sol_peps, schmidts = low_energy_spectrum(ctr, search_params, merge_branches(ctr, :fit, SingleLayerDroplets(eng, hamming_dist, :hamming)))
</code></pre><p>which runs branch and bound algorithm included in <code>SpinGlassPEPS.jl</code> It is actual solver, which iteratively explores the state space in search of the most probable states. The probabilities of a given configuration are calculated approximately through the contractions of the tensor network.</p><h2 id="Expected-output"><a class="docs-heading-anchor" href="#Expected-output">Expected output</a><a id="Expected-output-1"></a><a class="docs-heading-anchor-permalink" href="#Expected-output" title="Permalink"></a></h2><p>The function <code>low_energy_spectrum</code>, as its output, provides a wealth of information, which we will briefly discuss now.</p><pre><code class="language- hljs">sol_peps, schmidt_val = low_energy_spectrum(ctr, search_params, merge_branches(ctr))</code></pre><p>It returns a Solution-type structure (<code>sol_peps</code>) and Schmidt values <code>schmidt_val</code>. In the <code>Solution</code> structure, the following information is recorded:</p><ul><li>energies - a vector containing the energies of the discovered states</li></ul><p>If you want to display it, you can type:</p><pre><code class="language- hljs">println(sol_peps.energies)</code></pre><p>In this case, you should obtain:</p><pre><code class="language- hljs">[-215.23679958927175]</code></pre><ul><li>states - a vector of cluster state configurations corresponding to the energies</li></ul><pre><code class="language- hljs">println(sol_peps.states)</code></pre><pre><code class="language- hljs">println([[4, 4, 2, 16, 9, 8, 8, 2, 3, 8, 7, 1, 4, 10, 9, 2, 11, 2, 1, 2, 11, 3, 11, 8, 3]])</code></pre><ul><li>probabilities - the probabilities associated with each discovered state</li></ul><pre><code class="language- hljs">println(sol_peps.probabilities)</code></pre><pre><code class="language- hljs">[-5.637640487579043]</code></pre><ul><li>degeneracy</li></ul><pre><code class="language- hljs">println(sol_peps.degeneracy)</code></pre><pre><code class="language- hljs">[2]</code></pre><ul><li>largest discarded probability - largest probability below which states are considered to be discarded</li></ul><pre><code class="language- hljs">println(sol_peps.largest_discarded_probability)</code></pre><pre><code class="language- hljs">-4.70579014404923</code></pre><ul><li>Schmidt values - a dictionary containing Schmidt spectra for each MPS</li></ul><pre><code class="language- hljs">println(schmidt_val)</code></pre><p>which are</p><pre><code class="language- hljs">Dict{Any, Any}(5 =&gt; Any[1.0, 1.0, 0.0035931343796194565, 0.0015050888555964259, 0.0007184752751868924, 5.2741877514519126e-5, 4.137035816131772e-5, 0.00040017490729592366, 0.00021874495320028077, 6.827849766898342e-5], 4 =&gt; Any[1.0, 1.0, 1.704951518711975e-5, 0.00037890798675182353, 0.00011310427642297989, 0.001014257142680146, 0.0012672631937840461, 0.0005487312667512858, 0.0006741839581781018, 0.00012017531445170455], 6 =&gt; Any[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 2 =&gt; Any[1.0, 1.0, 0.0001405854472578707, 0.0012280075890260514, 0.001177462193268373, 0.0029570115655969827, 0.002997829968910592, 0.0011163442379909382, 0.0010056280784881478, 0.00026431187613365595], 3 =&gt; Any[1.0, 1.0, 1.864183962070951e-5, 0.006059161388679921, 0.006793028602573968, 0.012337242616802302, 0.011721497080177857, 0.013791830543357657, 0.020430181282353188, 0.014653186648427675])</code></pre><ul><li>statistics - a possible warning sign, with values ranging from [0, 2]. A nonzero value signifies that certain conditional probabilities derived from tensor network contraction were negative, suggesting a lack of numerical stability during contraction. Here we display the worst-case scenario.</li></ul><pre><code class="language- hljs">println(minimum(values(ctr.statistics)))</code></pre><p>The output should give you</p><pre><code class="language- hljs">0.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../algorithm/">Brief description of the algorithm »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 2 May 2024 19:13">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
